import {
  ACESFilmicToneMapping,
  AmbientLight,
  BackSide,
  BoxGeometry,
  CineonToneMapping,
  Color,
  CubeCamera,
  DepthFormat,
  DepthTexture,
  DirectionalLight,
  DynamicDrawUsage,
  EventDispatcher,
  FileLoader,
  Float16BufferAttribute,
  FramebufferTexture,
  HemisphereLight,
  InstancedInterleavedBuffer,
  InterleavedBuffer,
  InterleavedBufferAttribute,
  LessCompare,
  LineBasicMaterial,
  LineDashedMaterial,
  LinearEncoding,
  LinearFilter,
  LinearMipmapLinearFilter,
  LinearSRGBColorSpace,
  LinearToneMapping,
  Loader,
  Material,
  MaterialLoader,
  MathUtils,
  Matrix3,
  Matrix4,
  Mesh,
  MeshBasicMaterial,
  MeshLambertMaterial,
  MeshNormalMaterial,
  MeshPhongMaterial,
  MeshPhysicalMaterial,
  MeshStandardMaterial,
  NearestFilter,
  NoBlending,
  NoColorSpace,
  NoToneMapping,
  ObjectLoader,
  ObjectSpaceNormalMap,
  PointLight,
  PointsMaterial,
  REVISION,
  ReinhardToneMapping,
  RenderTarget,
  SRGBColorSpace,
  Scene,
  ShaderMaterial,
  SpotLight,
  SpriteMaterial,
  StaticDrawUsage,
  TangentSpaceNormalMap,
  UnsignedIntType,
  Vector2,
  Vector3,
  Vector4,
  WebGLCubeRenderTarget,
  sRGBEncoding
} from "./chunk-ZUKO66BU.js";
import {
  __export
} from "./chunk-6TJCVOLN.js";

// node_modules/three/examples/jsm/nodes/core/constants.js
var NodeShaderStage = {
  VERTEX: "vertex",
  FRAGMENT: "fragment"
};
var NodeUpdateType = {
  NONE: "none",
  FRAME: "frame",
  RENDER: "render",
  OBJECT: "object"
};
var NodeType = {
  BOOLEAN: "bool",
  INTEGER: "int",
  FLOAT: "float",
  VECTOR2: "vec2",
  VECTOR3: "vec3",
  VECTOR4: "vec4",
  MATRIX3: "mat3",
  MATRIX4: "mat4"
};
var defaultShaderStages = ["fragment", "vertex"];
var defaultBuildStages = ["construct", "analyze", "generate"];
var shaderStages = [...defaultShaderStages, "compute"];
var vectorComponents = ["x", "y", "z", "w"];

// node_modules/three/examples/jsm/nodes/core/NodeUtils.js
var NodeUtils_exports = {};
__export(NodeUtils_exports, {
  arrayBufferToBase64: () => arrayBufferToBase64,
  base64ToArrayBuffer: () => base64ToArrayBuffer,
  getCacheKey: () => getCacheKey,
  getNodeChildren: () => getNodeChildren,
  getValueFromType: () => getValueFromType,
  getValueType: () => getValueType
});
function getCacheKey(object) {
  let cacheKey = "{";
  if (object.isNode === true) {
    cacheKey += `uuid:"${object.uuid}"`;
  }
  for (const { property: property2, index, childNode } of getNodeChildren(object)) {
    let childCacheKey = getCacheKey(childNode);
    if (!childCacheKey.includes(","))
      childCacheKey = childCacheKey.slice(childCacheKey.indexOf('"'), childCacheKey.indexOf("}"));
    cacheKey += `,${property2}${index !== void 0 ? "/" + index : ""}:${childCacheKey}`;
  }
  cacheKey += "}";
  return cacheKey;
}
function* getNodeChildren(node, toJSON = false) {
  for (const property2 in node) {
    if (property2.startsWith("_") === true)
      continue;
    const object = node[property2];
    if (Array.isArray(object) === true) {
      for (let i = 0; i < object.length; i++) {
        const child = object[i];
        if (child && (child.isNode === true || toJSON && typeof child.toJSON === "function")) {
          yield { property: property2, index: i, childNode: child };
        }
      }
    } else if (object && object.isNode === true) {
      yield { property: property2, childNode: object };
    } else if (typeof object === "object") {
      for (const subProperty in object) {
        const child = object[subProperty];
        if (child && (child.isNode === true || toJSON && typeof child.toJSON === "function")) {
          yield { property: property2, index: subProperty, childNode: child };
        }
      }
    }
  }
}
function getValueType(value) {
  if (value === void 0 || value === null)
    return null;
  const typeOf = typeof value;
  if (value.isNode === true) {
    return "node";
  } else if (typeOf === "number") {
    return "float";
  } else if (typeOf === "boolean") {
    return "bool";
  } else if (typeOf === "string") {
    return "string";
  } else if (typeOf === "function") {
    return "shader";
  } else if (value.isVector2 === true) {
    return "vec2";
  } else if (value.isVector3 === true) {
    return "vec3";
  } else if (value.isVector4 === true) {
    return "vec4";
  } else if (value.isMatrix3 === true) {
    return "mat3";
  } else if (value.isMatrix4 === true) {
    return "mat4";
  } else if (value.isColor === true) {
    return "color";
  } else if (value instanceof ArrayBuffer) {
    return "ArrayBuffer";
  }
  return null;
}
function getValueFromType(type, ...params) {
  const last4 = type ? type.slice(-4) : void 0;
  if ((last4 === "vec2" || last4 === "vec3" || last4 === "vec4") && params.length === 1) {
    params = last4 === "vec2" ? [params[0], params[0]] : [params[0], params[0], params[0]];
  }
  if (type === "color") {
    return new Color(...params);
  } else if (last4 === "vec2") {
    return new Vector2(...params);
  } else if (last4 === "vec3") {
    return new Vector3(...params);
  } else if (last4 === "vec4") {
    return new Vector4(...params);
  } else if (last4 === "mat3") {
    return new Matrix3(...params);
  } else if (last4 === "mat4") {
    return new Matrix4(...params);
  } else if (type === "bool") {
    return params[0] || false;
  } else if (type === "float" || type === "int" || type === "uint") {
    return params[0] || 0;
  } else if (type === "string") {
    return params[0] || "";
  } else if (type === "ArrayBuffer") {
    return base64ToArrayBuffer(params[0]);
  }
  return null;
}
function arrayBufferToBase64(arrayBuffer2) {
  let chars = "";
  const array = new Uint8Array(arrayBuffer2);
  for (let i = 0; i < array.length; i++) {
    chars += String.fromCharCode(array[i]);
  }
  return btoa(chars);
}
function base64ToArrayBuffer(base64) {
  return Uint8Array.from(atob(base64), (c) => c.charCodeAt(0)).buffer;
}

// node_modules/three/examples/jsm/nodes/core/Node.js
var NodeClasses = /* @__PURE__ */ new Map();
var _nodeId = 0;
var Node = class extends EventDispatcher {
  constructor(nodeType = null) {
    super();
    this.nodeType = nodeType;
    this.updateType = NodeUpdateType.NONE;
    this.updateBeforeType = NodeUpdateType.NONE;
    this.uuid = MathUtils.generateUUID();
    this.isNode = true;
    Object.defineProperty(this, "id", { value: _nodeId++ });
  }
  get type() {
    return this.constructor.name;
  }
  getSelf() {
    return this.self || this;
  }
  isGlobal() {
    return false;
  }
  *getChildren() {
    const self = this;
    for (const { property: property2, index, childNode } of getNodeChildren(this)) {
      yield { childNode, replaceNode(node) {
        if (index === void 0)
          self[property2] = node;
        else
          self[property2][index] = node;
      } };
    }
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  traverse(callback, replaceNode = null) {
    callback(this, replaceNode);
    for (const { childNode, replaceNode: replaceNode2 } of this.getChildren()) {
      childNode.traverse(callback, replaceNode2);
    }
  }
  getCacheKey() {
    return getCacheKey(this);
  }
  getHash() {
    return this.uuid;
  }
  getUpdateType() {
    return this.updateType;
  }
  getUpdateBeforeType() {
    return this.updateBeforeType;
  }
  getNodeType(builder) {
    const nodeProperties = builder.getNodeProperties(this);
    if (nodeProperties.outputNode) {
      return nodeProperties.outputNode.getNodeType(builder);
    }
    return this.nodeType;
  }
  getReference(builder) {
    const hash2 = this.getHash(builder);
    const nodeFromHash = builder.getNodeFromHash(hash2);
    return nodeFromHash || this;
  }
  construct(builder) {
    const nodeProperties = builder.getNodeProperties(this);
    for (const { childNode } of this.getChildren()) {
      nodeProperties["_node" + childNode.id] = childNode;
    }
    return null;
  }
  analyze(builder) {
    const nodeData = builder.getDataFromNode(this);
    nodeData.dependenciesCount = nodeData.dependenciesCount === void 0 ? 1 : nodeData.dependenciesCount + 1;
    if (nodeData.dependenciesCount === 1) {
      const nodeProperties = builder.getNodeProperties(this);
      for (const childNode of Object.values(nodeProperties)) {
        if (childNode && childNode.isNode === true) {
          childNode.build(builder);
        }
      }
    }
  }
  generate(builder, output2) {
    const { outputNode } = builder.getNodeProperties(this);
    if (outputNode && outputNode.isNode === true) {
      return outputNode.build(builder, output2);
    }
  }
  updateBefore() {
    console.warn("Abstract function.");
  }
  update() {
    console.warn("Abstract function.");
  }
  build(builder, output2 = null) {
    const refNode = this.getReference(builder);
    if (this !== refNode) {
      return refNode.build(builder, output2);
    }
    builder.addNode(this);
    builder.addChain(this);
    let result = null;
    const buildStage = builder.getBuildStage();
    if (buildStage === "construct") {
      const properties = builder.getNodeProperties(this);
      if (properties.initialized !== true || builder.context.tempRead === false) {
        const stackNodesBeforeConstruct = builder.stack.nodes.length;
        properties.initialized = true;
        properties.outputNode = this.construct(builder);
        if (properties.outputNode !== null && builder.stack.nodes.length !== stackNodesBeforeConstruct) {
          properties.outputNode = builder.stack;
        }
        for (const childNode of Object.values(properties)) {
          if (childNode && childNode.isNode === true) {
            childNode.build(builder);
          }
        }
      }
    } else if (buildStage === "analyze") {
      this.analyze(builder);
    } else if (buildStage === "generate") {
      const isGenerateOnce = this.generate.length === 1;
      if (isGenerateOnce) {
        const type = this.getNodeType(builder);
        const nodeData = builder.getDataFromNode(this);
        result = nodeData.snippet;
        if (result === void 0) {
          result = this.generate(builder) || "";
          nodeData.snippet = result;
        }
        result = builder.format(result, type, output2);
      } else {
        result = this.generate(builder, output2) || "";
      }
    }
    builder.removeChain(this);
    return result;
  }
  getSerializeChildren() {
    return getNodeChildren(this);
  }
  serialize(json) {
    const nodeChildren = this.getSerializeChildren();
    const inputNodes = {};
    for (const { property: property2, index, childNode } of nodeChildren) {
      if (index !== void 0) {
        if (inputNodes[property2] === void 0) {
          inputNodes[property2] = Number.isInteger(index) ? [] : {};
        }
        inputNodes[property2][index] = childNode.toJSON(json.meta).uuid;
      } else {
        inputNodes[property2] = childNode.toJSON(json.meta).uuid;
      }
    }
    if (Object.keys(inputNodes).length > 0) {
      json.inputNodes = inputNodes;
    }
  }
  deserialize(json) {
    if (json.inputNodes !== void 0) {
      const nodes = json.meta.nodes;
      for (const property2 in json.inputNodes) {
        if (Array.isArray(json.inputNodes[property2])) {
          const inputArray = [];
          for (const uuid of json.inputNodes[property2]) {
            inputArray.push(nodes[uuid]);
          }
          this[property2] = inputArray;
        } else if (typeof json.inputNodes[property2] === "object") {
          const inputObject = {};
          for (const subProperty in json.inputNodes[property2]) {
            const uuid = json.inputNodes[property2][subProperty];
            inputObject[subProperty] = nodes[uuid];
          }
          this[property2] = inputObject;
        } else {
          const uuid = json.inputNodes[property2];
          this[property2] = nodes[uuid];
        }
      }
    }
  }
  toJSON(meta) {
    const { uuid, type } = this;
    const isRoot = meta === void 0 || typeof meta === "string";
    if (isRoot) {
      meta = {
        textures: {},
        images: {},
        nodes: {}
      };
    }
    let data = meta.nodes[uuid];
    if (data === void 0) {
      data = {
        uuid,
        type,
        meta,
        metadata: {
          version: 4.6,
          type: "Node",
          generator: "Node.toJSON"
        }
      };
      if (isRoot !== true)
        meta.nodes[data.uuid] = data;
      this.serialize(data);
      delete data.meta;
    }
    function extractFromCache(cache3) {
      const values = [];
      for (const key in cache3) {
        const data2 = cache3[key];
        delete data2.metadata;
        values.push(data2);
      }
      return values;
    }
    if (isRoot) {
      const textures = extractFromCache(meta.textures);
      const images = extractFromCache(meta.images);
      const nodes = extractFromCache(meta.nodes);
      if (textures.length > 0)
        data.textures = textures;
      if (images.length > 0)
        data.images = images;
      if (nodes.length > 0)
        data.nodes = nodes;
    }
    return data;
  }
};
var Node_default = Node;
function addNodeClass(nodeClass) {
  if (typeof nodeClass !== "function" || !nodeClass.name)
    throw new Error(`Node class ${nodeClass.name} is not a class`);
  if (NodeClasses.has(nodeClass.name))
    throw new Error(`Redefinition of node class ${nodeClass.name}`);
  NodeClasses.set(nodeClass.name, nodeClass);
}
function createNodeFromType(type) {
  const Class = NodeClasses.get(type);
  if (Class !== void 0) {
    return new Class();
  }
}

// node_modules/three/examples/jsm/nodes/core/InputNode.js
var InputNode = class extends Node_default {
  constructor(value, nodeType = null) {
    super(nodeType);
    this.isInputNode = true;
    this.value = value;
    this.precision = null;
  }
  getNodeType() {
    if (this.nodeType === null) {
      return getValueType(this.value);
    }
    return this.nodeType;
  }
  getInputType(builder) {
    return this.getNodeType(builder);
  }
  setPrecision(precision) {
    this.precision = precision;
    return this;
  }
  serialize(data) {
    super.serialize(data);
    data.value = this.value;
    if (this.value && this.value.toArray)
      data.value = this.value.toArray();
    data.valueType = getValueType(this.value);
    data.nodeType = this.nodeType;
    if (data.valueType === "ArrayBuffer")
      data.value = arrayBufferToBase64(data.value);
    data.precision = this.precision;
  }
  deserialize(data) {
    super.deserialize(data);
    this.nodeType = data.nodeType;
    this.value = Array.isArray(data.value) ? getValueFromType(data.valueType, ...data.value) : data.value;
    this.precision = data.precision || null;
    if (this.value && this.value.fromArray)
      this.value = this.value.fromArray(data.value);
  }
  generate() {
    console.warn("Abstract function.");
  }
};
var InputNode_default = InputNode;
addNodeClass(InputNode);

// node_modules/three/examples/jsm/nodes/utils/ArrayElementNode.js
var ArrayElementNode = class extends Node_default {
  // @TODO: If extending from TempNode it breaks webgpu_compute
  constructor(node, indexNode) {
    super();
    this.node = node;
    this.indexNode = indexNode;
  }
  getNodeType(builder) {
    return this.node.getNodeType(builder);
  }
  generate(builder) {
    const nodeSnippet = this.node.build(builder);
    const indexSnippet = this.indexNode.build(builder, "uint");
    return `${nodeSnippet}[ ${indexSnippet} ]`;
  }
};
var ArrayElementNode_default = ArrayElementNode;
addNodeClass(ArrayElementNode);

// node_modules/three/examples/jsm/nodes/utils/ConvertNode.js
var ConvertNode = class extends Node_default {
  constructor(node, convertTo) {
    super();
    this.node = node;
    this.convertTo = convertTo;
  }
  getNodeType(builder) {
    const requestType = this.node.getNodeType(builder);
    let convertTo = null;
    for (const overloadingType of this.convertTo.split("|")) {
      if (convertTo === null || builder.getTypeLength(requestType) === builder.getTypeLength(overloadingType)) {
        convertTo = overloadingType;
      }
    }
    return convertTo;
  }
  serialize(data) {
    super.serialize(data);
    data.convertTo = this.convertTo;
  }
  deserialize(data) {
    super.deserialize(data);
    this.convertTo = data.convertTo;
  }
  generate(builder, output2) {
    const node = this.node;
    const type = this.getNodeType(builder);
    const snippet = node.build(builder, type);
    return builder.format(snippet, type, output2);
  }
};
var ConvertNode_default = ConvertNode;
addNodeClass(ConvertNode);

// node_modules/three/examples/jsm/nodes/core/TempNode.js
var TempNode = class extends Node_default {
  constructor(type) {
    super(type);
    this.isTempNode = true;
  }
  hasDependencies(builder) {
    return builder.getDataFromNode(this).dependenciesCount > 1;
  }
  build(builder, output2) {
    const buildStage = builder.getBuildStage();
    if (buildStage === "generate") {
      const type = builder.getVectorType(this.getNodeType(builder, output2));
      const nodeData = builder.getDataFromNode(this);
      if (builder.context.tempRead !== false && nodeData.propertyName !== void 0) {
        return builder.format(nodeData.propertyName, type, output2);
      } else if (builder.context.tempWrite !== false && type !== "void" && output2 !== "void" && this.hasDependencies(builder)) {
        const snippet = super.build(builder, type);
        const nodeVar = builder.getVarFromNode(this, type);
        const propertyName = builder.getPropertyName(nodeVar);
        builder.addLineFlowCode(`${propertyName} = ${snippet}`);
        nodeData.snippet = snippet;
        nodeData.propertyName = propertyName;
        return builder.format(nodeData.propertyName, type, output2);
      }
    }
    return super.build(builder, output2);
  }
};
var TempNode_default = TempNode;
addNodeClass(TempNode);

// node_modules/three/examples/jsm/nodes/utils/JoinNode.js
var JoinNode = class extends TempNode_default {
  constructor(nodes = [], nodeType = null) {
    super(nodeType);
    this.nodes = nodes;
  }
  getNodeType(builder) {
    if (this.nodeType !== null) {
      return builder.getVectorType(this.nodeType);
    }
    return builder.getTypeFromLength(this.nodes.reduce((count, cur) => count + builder.getTypeLength(cur.getNodeType(builder)), 0));
  }
  generate(builder, output2) {
    const type = this.getNodeType(builder);
    const nodes = this.nodes;
    const snippetValues = [];
    for (const input of nodes) {
      const inputSnippet = input.build(builder);
      snippetValues.push(inputSnippet);
    }
    const snippet = `${builder.getType(type)}( ${snippetValues.join(", ")} )`;
    return builder.format(snippet, type, output2);
  }
};
var JoinNode_default = JoinNode;
addNodeClass(JoinNode);

// node_modules/three/examples/jsm/nodes/utils/SplitNode.js
var stringVectorComponents = vectorComponents.join("");
var SplitNode = class extends Node_default {
  constructor(node, components = "x") {
    super();
    this.node = node;
    this.components = components;
  }
  getVectorLength() {
    let vectorLength = this.components.length;
    for (const c of this.components) {
      vectorLength = Math.max(vectorComponents.indexOf(c) + 1, vectorLength);
    }
    return vectorLength;
  }
  getNodeType(builder) {
    return builder.getTypeFromLength(this.components.length);
  }
  generate(builder, output2) {
    const node = this.node;
    const nodeTypeLength = builder.getTypeLength(node.getNodeType(builder));
    let snippet = null;
    if (nodeTypeLength > 1) {
      let type = null;
      const componentsLength = this.getVectorLength();
      if (componentsLength >= nodeTypeLength) {
        type = builder.getTypeFromLength(this.getVectorLength());
      }
      const nodeSnippet = node.build(builder, type);
      if (this.components.length === nodeTypeLength && this.components === stringVectorComponents.slice(0, this.components.length)) {
        snippet = builder.format(nodeSnippet, type, output2);
      } else {
        snippet = builder.format(`${nodeSnippet}.${this.components}`, this.getNodeType(builder), output2);
      }
    } else {
      snippet = node.build(builder, output2);
    }
    return snippet;
  }
  serialize(data) {
    super.serialize(data);
    data.components = this.components;
  }
  deserialize(data) {
    super.deserialize(data);
    this.components = data.components;
  }
};
var SplitNode_default = SplitNode;
addNodeClass(SplitNode);

// node_modules/three/examples/jsm/nodes/core/ConstNode.js
var ConstNode = class extends InputNode_default {
  constructor(value, nodeType = null) {
    super(value, nodeType);
    this.isConstNode = true;
  }
  generateConst(builder) {
    return builder.getConst(this.getNodeType(builder), this.value);
  }
  generate(builder, output2) {
    const type = this.getNodeType(builder);
    return builder.format(this.generateConst(builder), type, output2);
  }
};
var ConstNode_default = ConstNode;
addNodeClass(ConstNode);

// node_modules/three/examples/jsm/nodes/shadernode/ShaderNode.js
var NodeElements = /* @__PURE__ */ new Map();
function addNodeElement(name, nodeElement) {
  if (NodeElements.has(name))
    throw new Error(`Redefinition of node element ${name}`);
  if (typeof nodeElement !== "function")
    throw new Error(`Node element ${name} is not a function`);
  NodeElements.set(name, nodeElement);
}
var shaderNodeHandler = {
  construct(NodeClosure, params) {
    const inputs = params.shift();
    return NodeClosure(nodeObjects(inputs), ...params);
  },
  get: function(node, prop, nodeObj) {
    if (typeof prop === "string" && node[prop] === void 0) {
      if (NodeElements.has(prop)) {
        const nodeElement = NodeElements.get(prop);
        return (...params) => nodeElement(nodeObj, ...params);
      } else if (prop === "self") {
        return node;
      } else if (prop.endsWith("Assign") && NodeElements.has(prop.slice(0, prop.length - "Assign".length))) {
        const nodeElement = NodeElements.get(prop.slice(0, prop.length - "Assign".length));
        return (...params) => nodeObj.assign(nodeElement(nodeObj, ...params));
      } else if (/^[xyzwrgbastpq]{1,4}$/.test(prop) === true) {
        prop = prop.replace(/r|s/g, "x").replace(/g|t/g, "y").replace(/b|p/g, "z").replace(/a|q/g, "w");
        return nodeObject(new SplitNode_default(node, prop));
      } else if (prop === "width" || prop === "height") {
        return nodeObject(new SplitNode_default(node, prop === "width" ? "x" : "y"));
      } else if (/^\d+$/.test(prop) === true) {
        return nodeObject(new ArrayElementNode_default(node, new ConstNode_default(Number(prop), "uint")));
      }
    }
    return node[prop];
  }
};
var nodeObjectsCacheMap = /* @__PURE__ */ new WeakMap();
var ShaderNodeObject = function(obj, altType = null) {
  const type = getValueType(obj);
  if (type === "node") {
    let nodeObject2 = nodeObjectsCacheMap.get(obj);
    if (nodeObject2 === void 0) {
      nodeObject2 = new Proxy(obj, shaderNodeHandler);
      nodeObjectsCacheMap.set(obj, nodeObject2);
      nodeObjectsCacheMap.set(nodeObject2, nodeObject2);
    }
    return nodeObject2;
  } else if (altType === null && (type === "float" || type === "boolean") || type && type !== "shader" && type !== "string") {
    return nodeObject(getConstNode(obj, altType));
  } else if (type === "shader") {
    return tslFn(obj);
  }
  return obj;
};
var ShaderNodeObjects = function(objects, altType = null) {
  for (const name in objects) {
    objects[name] = nodeObject(objects[name], altType);
  }
  return objects;
};
var ShaderNodeArray = function(array, altType = null) {
  const len = array.length;
  for (let i = 0; i < len; i++) {
    array[i] = nodeObject(array[i], altType);
  }
  return array;
};
var ShaderNodeProxy = function(NodeClass, scope = null, factor = null, settings = null) {
  const assignNode = (node) => nodeObject(settings !== null ? Object.assign(node, settings) : node);
  if (scope === null) {
    return (...params) => {
      return assignNode(new NodeClass(...nodeArray(params)));
    };
  } else if (factor !== null) {
    factor = nodeObject(factor);
    return (...params) => {
      return assignNode(new NodeClass(scope, ...nodeArray(params), factor));
    };
  } else {
    return (...params) => {
      return assignNode(new NodeClass(scope, ...nodeArray(params)));
    };
  }
};
var ShaderNodeImmutable = function(NodeClass, ...params) {
  return nodeObject(new NodeClass(...nodeArray(params)));
};
var ShaderNodeInternal = class extends Node_default {
  constructor(jsFunc) {
    super();
    this._jsFunc = jsFunc;
  }
  call(inputs, stack2, builder) {
    inputs = nodeObjects(inputs);
    return nodeObject(this._jsFunc(inputs, stack2, builder));
  }
  getNodeType(builder) {
    const { outputNode } = builder.getNodeProperties(this);
    return outputNode ? outputNode.getNodeType(builder) : super.getNodeType(builder);
  }
  construct(builder) {
    builder.addStack();
    builder.stack.outputNode = nodeObject(this._jsFunc(builder.stack, builder));
    return builder.removeStack();
  }
};
var bools = [false, true];
var uints = [0, 1, 2, 3];
var ints = [-1, -2];
var floats = [0.5, 1.5, 1 / 3, 1e-6, 1e6, Math.PI, Math.PI * 2, 1 / Math.PI, 2 / Math.PI, 1 / (Math.PI * 2), Math.PI / 2];
var boolsCacheMap = /* @__PURE__ */ new Map();
for (const bool2 of bools)
  boolsCacheMap.set(bool2, new ConstNode_default(bool2));
var uintsCacheMap = /* @__PURE__ */ new Map();
for (const uint2 of uints)
  uintsCacheMap.set(uint2, new ConstNode_default(uint2, "uint"));
var intsCacheMap = new Map([...uintsCacheMap].map((el) => new ConstNode_default(el.value, "int")));
for (const int2 of ints)
  intsCacheMap.set(int2, new ConstNode_default(int2, "int"));
var floatsCacheMap = new Map([...intsCacheMap].map((el) => new ConstNode_default(el.value)));
for (const float2 of floats)
  floatsCacheMap.set(float2, new ConstNode_default(float2));
for (const float2 of floats)
  floatsCacheMap.set(-float2, new ConstNode_default(-float2));
var cacheMaps = { bool: boolsCacheMap, uint: uintsCacheMap, ints: intsCacheMap, float: floatsCacheMap };
var constNodesCacheMap = new Map([...boolsCacheMap, ...floatsCacheMap]);
var getConstNode = (value, type) => {
  if (constNodesCacheMap.has(value)) {
    return constNodesCacheMap.get(value);
  } else if (value.isNode === true) {
    return value;
  } else {
    return new ConstNode_default(value, type);
  }
};
var safeGetNodeType = (node) => {
  try {
    return node.getNodeType();
  } catch (_) {
    return void 0;
  }
};
var ConvertType = function(type, cacheMap = null) {
  return (...params) => {
    if (params.length === 0 || !["bool", "float", "int", "uint"].includes(type) && params.every((param) => typeof param !== "object")) {
      params = [getValueFromType(type, ...params)];
    }
    if (params.length === 1 && cacheMap !== null && cacheMap.has(params[0])) {
      return nodeObject(cacheMap.get(params[0]));
    }
    if (params.length === 1) {
      const node = getConstNode(params[0], type);
      if (safeGetNodeType(node) === type)
        return nodeObject(node);
      return nodeObject(new ConvertNode_default(node, type));
    }
    const nodes = params.map((param) => getConstNode(param));
    return nodeObject(new JoinNode_default(nodes, type));
  };
};
var getConstNodeType = (value) => value !== void 0 && value !== null ? value.nodeType || value.convertTo || (typeof value === "string" ? value : null) : null;
function ShaderNode(jsFunc) {
  return new Proxy(new ShaderNodeInternal(jsFunc), shaderNodeHandler);
}
var nodeObject = (val, altType = null) => (
  /* new */
  ShaderNodeObject(val, altType)
);
var nodeObjects = (val, altType = null) => new ShaderNodeObjects(val, altType);
var nodeArray = (val, altType = null) => new ShaderNodeArray(val, altType);
var nodeProxy = (...params) => new ShaderNodeProxy(...params);
var nodeImmutable = (...params) => new ShaderNodeImmutable(...params);
var shader = (jsFunc) => {
  console.warn("TSL: shader() is deprecated. Use tslFn() instead.");
  return new ShaderNode(jsFunc);
};
var tslFn = (jsFunc) => {
  let shaderNode = null;
  return (...params) => {
    if (shaderNode === null)
      shaderNode = new ShaderNode(jsFunc);
    return shaderNode.call(...params);
  };
};
addNodeClass(ShaderNode);
var color = new ConvertType("color");
var float = new ConvertType("float", cacheMaps.float);
var int = new ConvertType("int", cacheMaps.int);
var uint = new ConvertType("uint", cacheMaps.uint);
var bool = new ConvertType("bool", cacheMaps.bool);
var vec2 = new ConvertType("vec2");
var ivec2 = new ConvertType("ivec2");
var uvec2 = new ConvertType("uvec2");
var bvec2 = new ConvertType("bvec2");
var vec3 = new ConvertType("vec3");
var ivec3 = new ConvertType("ivec3");
var uvec3 = new ConvertType("uvec3");
var bvec3 = new ConvertType("bvec3");
var vec4 = new ConvertType("vec4");
var ivec4 = new ConvertType("ivec4");
var uvec4 = new ConvertType("uvec4");
var bvec4 = new ConvertType("bvec4");
var mat3 = new ConvertType("mat3");
var imat3 = new ConvertType("imat3");
var umat3 = new ConvertType("umat3");
var bmat3 = new ConvertType("bmat3");
var mat4 = new ConvertType("mat4");
var imat4 = new ConvertType("imat4");
var umat4 = new ConvertType("umat4");
var bmat4 = new ConvertType("bmat4");
var string = (value = "") => nodeObject(new ConstNode_default(value, "string"));
var arrayBuffer = (value) => nodeObject(new ConstNode_default(value, "ArrayBuffer"));
addNodeElement("color", color);
addNodeElement("float", float);
addNodeElement("int", int);
addNodeElement("uint", uint);
addNodeElement("bool", bool);
addNodeElement("vec2", vec2);
addNodeElement("ivec2", ivec2);
addNodeElement("uvec2", uvec2);
addNodeElement("bvec2", bvec2);
addNodeElement("vec3", vec3);
addNodeElement("ivec3", ivec3);
addNodeElement("uvec3", uvec3);
addNodeElement("bvec3", bvec3);
addNodeElement("vec4", vec4);
addNodeElement("ivec4", ivec4);
addNodeElement("uvec4", uvec4);
addNodeElement("bvec4", bvec4);
addNodeElement("mat3", mat3);
addNodeElement("imat3", imat3);
addNodeElement("umat3", umat3);
addNodeElement("bmat3", bmat3);
addNodeElement("mat4", mat4);
addNodeElement("imat4", imat4);
addNodeElement("umat4", umat4);
addNodeElement("bmat4", bmat4);
addNodeElement("string", string);
addNodeElement("arrayBuffer", arrayBuffer);
var element = nodeProxy(ArrayElementNode_default);
var convert = (node, types) => nodeObject(new ConvertNode_default(nodeObject(node), types));
var split = (node, channels) => nodeObject(new SplitNode_default(nodeObject(node), channels));
addNodeElement("element", element);
addNodeElement("convert", convert);

// node_modules/three/examples/jsm/nodes/core/UniformNode.js
var UniformNode = class extends InputNode_default {
  constructor(value, nodeType = null) {
    super(value, nodeType);
    this.isUniformNode = true;
  }
  getUniformHash(builder) {
    return this.getHash(builder);
  }
  generate(builder, output2) {
    const type = this.getNodeType(builder);
    const hash2 = this.getUniformHash(builder);
    let sharedNode = builder.getNodeFromHash(hash2);
    if (sharedNode === void 0) {
      builder.setHashNode(this, hash2);
      sharedNode = this;
    }
    const sharedNodeType = sharedNode.getInputType(builder);
    const nodeUniform = builder.getUniformFromNode(sharedNode, sharedNodeType, builder.shaderStage, builder.context.label);
    const propertyName = builder.getPropertyName(nodeUniform);
    return builder.format(propertyName, type, output2);
  }
};
var UniformNode_default = UniformNode;
var uniform = (arg1, arg2) => {
  const nodeType = getConstNodeType(arg2 || arg1);
  const value = arg1 && arg1.isNode === true ? arg1.node && arg1.node.value || arg1.value : arg1;
  return nodeObject(new UniformNode(value, nodeType));
};
addNodeClass(UniformNode);

// node_modules/three/examples/jsm/nodes/core/ArrayUniformNode.js
var ArrayUniformNode = class extends UniformNode_default {
  constructor(nodes = []) {
    super();
    this.isArrayUniformNode = true;
    this.nodes = nodes;
  }
  getNodeType(builder) {
    return this.nodes[0].getNodeType(builder);
  }
};
var ArrayUniformNode_default = ArrayUniformNode;
addNodeClass(ArrayUniformNode);

// node_modules/three/examples/jsm/nodes/core/VaryingNode.js
var VaryingNode = class extends Node_default {
  constructor(node, name = null) {
    super();
    this.node = node;
    this.name = name;
  }
  isGlobal() {
    return true;
  }
  getHash(builder) {
    return this.name || super.getHash(builder);
  }
  getNodeType(builder) {
    return this.node.getNodeType(builder);
  }
  generate(builder) {
    const { name, node } = this;
    const type = this.getNodeType(builder);
    const nodeVarying = builder.getVaryingFromNode(this, type);
    nodeVarying.needsInterpolation || (nodeVarying.needsInterpolation = builder.shaderStage === "fragment");
    if (name !== null) {
      nodeVarying.name = name;
    }
    const propertyName = builder.getPropertyName(nodeVarying, NodeShaderStage.VERTEX);
    builder.flowNodeFromShaderStage(NodeShaderStage.VERTEX, node, type, propertyName);
    return builder.getPropertyName(nodeVarying);
  }
};
var VaryingNode_default = VaryingNode;
var varying = nodeProxy(VaryingNode);
addNodeElement("varying", varying);
addNodeClass(VaryingNode);

// node_modules/three/examples/jsm/nodes/core/AttributeNode.js
var AttributeNode = class extends Node_default {
  constructor(attributeName, nodeType = null) {
    super(nodeType);
    this._attributeName = attributeName;
  }
  getHash(builder) {
    return this.getAttributeName(builder);
  }
  getNodeType(builder) {
    let nodeType = super.getNodeType(builder);
    if (nodeType === null) {
      const attributeName = this.getAttributeName(builder);
      if (builder.hasGeometryAttribute(attributeName)) {
        const attribute2 = builder.geometry.getAttribute(attributeName);
        nodeType = builder.getTypeFromAttribute(attribute2);
      } else {
        nodeType = "float";
      }
    }
    return nodeType;
  }
  setAttributeName(attributeName) {
    this._attributeName = attributeName;
    return this;
  }
  getAttributeName() {
    return this._attributeName;
  }
  generate(builder) {
    const attributeName = this.getAttributeName(builder);
    const nodeType = this.getNodeType(builder);
    const geometryAttribute = builder.hasGeometryAttribute(attributeName);
    if (geometryAttribute === true) {
      const attribute2 = builder.geometry.getAttribute(attributeName);
      const attributeType = builder.getTypeFromAttribute(attribute2);
      const nodeAttribute = builder.getAttribute(attributeName, attributeType);
      if (builder.shaderStage === "vertex") {
        return builder.format(nodeAttribute.name, attributeType, nodeType);
      } else {
        const nodeVarying = varying(this);
        return nodeVarying.build(builder, nodeType);
      }
    } else {
      console.warn(`AttributeNode: Attribute "${attributeName}" not found.`);
      return builder.getConst(nodeType);
    }
  }
};
var AttributeNode_default = AttributeNode;
var attribute = (name, nodeType) => nodeObject(new AttributeNode(name, nodeType));
addNodeClass(AttributeNode);

// node_modules/three/examples/jsm/nodes/core/BypassNode.js
var BypassNode = class extends Node_default {
  constructor(returnNode, callNode) {
    super();
    this.isBypassNode = true;
    this.outputNode = returnNode;
    this.callNode = callNode;
  }
  getNodeType(builder) {
    return this.outputNode.getNodeType(builder);
  }
  generate(builder) {
    const snippet = this.callNode.build(builder, "void");
    if (snippet !== "") {
      builder.addLineFlowCode(snippet);
    }
    return this.outputNode.build(builder);
  }
};
var BypassNode_default = BypassNode;
var bypass = nodeProxy(BypassNode);
addNodeElement("bypass", bypass);
addNodeClass(BypassNode);

// node_modules/three/examples/jsm/nodes/core/NodeCache.js
var id = 0;
var NodeCache = class {
  constructor() {
    this.id = id++;
    this.nodesData = /* @__PURE__ */ new WeakMap();
  }
  getNodeData(node) {
    return this.nodesData.get(node);
  }
  setNodeData(node, data) {
    this.nodesData.set(node, data);
  }
};
var NodeCache_default = NodeCache;

// node_modules/three/examples/jsm/nodes/core/CacheNode.js
var CacheNode = class extends Node_default {
  constructor(node, cache3 = new NodeCache_default()) {
    super();
    this.isCacheNode = true;
    this.node = node;
    this.cache = cache3;
  }
  getNodeType(builder) {
    return this.node.getNodeType(builder);
  }
  build(builder, ...params) {
    const previousCache = builder.getCache();
    builder.setCache(this.cache);
    const data = this.node.build(builder, ...params);
    builder.setCache(previousCache);
    return data;
  }
};
var CacheNode_default = CacheNode;
var cache = nodeProxy(CacheNode);
addNodeElement("cache", cache);
addNodeClass(CacheNode);

// node_modules/three/examples/jsm/nodes/core/ContextNode.js
var ContextNode = class extends Node_default {
  constructor(node, context2 = {}) {
    super();
    this.isContextNode = true;
    this.node = node;
    this.context = context2;
  }
  getNodeType(builder) {
    return this.node.getNodeType(builder);
  }
  construct(builder) {
    const previousContext = builder.getContext();
    builder.setContext({ ...builder.context, ...this.context });
    const node = this.node.build(builder);
    builder.setContext(previousContext);
    return node;
  }
  generate(builder, output2) {
    const previousContext = builder.getContext();
    builder.setContext({ ...builder.context, ...this.context });
    const snippet = this.node.build(builder, output2);
    builder.setContext(previousContext);
    return snippet;
  }
};
var ContextNode_default = ContextNode;
var context = nodeProxy(ContextNode);
var label = (node, name) => context(node, { label: name });
addNodeElement("context", context);
addNodeElement("label", label);
addNodeClass(ContextNode);

// node_modules/three/examples/jsm/nodes/core/IndexNode.js
var IndexNode = class _IndexNode extends Node_default {
  constructor(scope) {
    super("uint");
    this.scope = scope;
    this.isInstanceIndexNode = true;
  }
  generate(builder) {
    const nodeType = this.getNodeType(builder);
    const scope = this.scope;
    let propertyName;
    if (scope === _IndexNode.VERTEX) {
      propertyName = builder.getVertexIndex();
    } else if (scope === _IndexNode.INSTANCE) {
      propertyName = builder.getInstanceIndex();
    } else {
      throw new Error("THREE.IndexNode: Unknown scope: " + scope);
    }
    let output2;
    if (builder.shaderStage === "vertex" || builder.shaderStage === "compute") {
      output2 = propertyName;
    } else {
      const nodeVarying = varying(this);
      output2 = nodeVarying.build(builder, nodeType);
    }
    return output2;
  }
};
IndexNode.VERTEX = "vertex";
IndexNode.INSTANCE = "instance";
var IndexNode_default = IndexNode;
var vertexIndex = nodeImmutable(IndexNode, IndexNode.VERTEX);
var instanceIndex = nodeImmutable(IndexNode, IndexNode.INSTANCE);
addNodeClass(IndexNode);

// node_modules/three/examples/jsm/nodes/core/LightingModel.js
var LightingModel = class {
  init() {
  }
  direct() {
  }
  indirectDiffuse() {
  }
  indirectSpecular() {
  }
  ambientOcclusion() {
  }
};
var LightingModel_default = LightingModel;

// node_modules/three/examples/jsm/nodes/core/NodeAttribute.js
var NodeAttribute = class {
  constructor(name, type, node = null) {
    this.isNodeAttribute = true;
    this.name = name;
    this.type = type;
    this.node = node;
  }
};
var NodeAttribute_default = NodeAttribute;

// node_modules/three/examples/jsm/nodes/core/NodeUniform.js
var NodeUniform = class {
  constructor(name, type, node, needsUpdate = void 0) {
    this.isNodeUniform = true;
    this.name = name;
    this.type = type;
    this.node = node.getSelf();
    this.needsUpdate = needsUpdate;
  }
  get value() {
    return this.node.value;
  }
  set value(val) {
    this.node.value = val;
  }
};
var NodeUniform_default = NodeUniform;

// node_modules/three/examples/jsm/nodes/core/NodeVar.js
var NodeVar = class {
  constructor(name, type) {
    this.isNodeVar = true;
    this.name = name;
    this.type = type;
  }
};
var NodeVar_default = NodeVar;

// node_modules/three/examples/jsm/nodes/core/NodeVarying.js
var NodeVarying = class extends NodeVar_default {
  constructor(name, type) {
    super(name, type);
    this.needsInterpolation = false;
    this.isNodeVarying = true;
  }
};
var NodeVarying_default = NodeVarying;

// node_modules/three/examples/jsm/nodes/core/NodeCode.js
var NodeCode = class {
  constructor(name, type, code2 = "") {
    this.name = name;
    this.type = type;
    this.code = code2;
    Object.defineProperty(this, "isNodeCode", { value: true });
  }
};
var NodeCode_default = NodeCode;

// node_modules/three/examples/jsm/nodes/core/NodeKeywords.js
var NodeKeywords = class {
  constructor() {
    this.keywords = [];
    this.nodes = [];
    this.keywordsCallback = {};
  }
  getNode(name) {
    let node = this.nodes[name];
    if (node === void 0 && this.keywordsCallback[name] !== void 0) {
      node = this.keywordsCallback[name](name);
      this.nodes[name] = node;
    }
    return node;
  }
  addKeyword(name, callback) {
    this.keywords.push(name);
    this.keywordsCallback[name] = callback;
    return this;
  }
  parse(code2) {
    const keywordNames = this.keywords;
    const regExp = new RegExp(`\\b${keywordNames.join("\\b|\\b")}\\b`, "g");
    const codeKeywords = code2.match(regExp);
    const keywordNodes = [];
    if (codeKeywords !== null) {
      for (const keyword of codeKeywords) {
        const node = this.getNode(keyword);
        if (node !== void 0 && keywordNodes.indexOf(node) === -1) {
          keywordNodes.push(node);
        }
      }
    }
    return keywordNodes;
  }
  include(builder, code2) {
    const keywordNodes = this.parse(code2);
    for (const keywordNode of keywordNodes) {
      keywordNode.build(builder);
    }
  }
};
var NodeKeywords_default = NodeKeywords;

// node_modules/three/examples/jsm/nodes/core/PropertyNode.js
var PropertyNode = class extends Node_default {
  constructor(nodeType, name = null) {
    super(nodeType);
    this.name = name;
  }
  getHash(builder) {
    return this.name || super.getHash(builder);
  }
  isGlobal() {
    return true;
  }
  generate(builder) {
    const nodeVary = builder.getVarFromNode(this, this.getNodeType(builder));
    const name = this.name;
    if (name !== null) {
      nodeVary.name = name;
    }
    return builder.getPropertyName(nodeVary);
  }
};
var PropertyNode_default = PropertyNode;
var property = (type, name) => nodeObject(new PropertyNode(type, name));
var diffuseColor = nodeImmutable(PropertyNode, "vec4", "DiffuseColor");
var roughness = nodeImmutable(PropertyNode, "float", "Roughness");
var metalness = nodeImmutable(PropertyNode, "float", "Metalness");
var clearcoat = nodeImmutable(PropertyNode, "float", "Clearcoat");
var clearcoatRoughness = nodeImmutable(PropertyNode, "float", "ClearcoatRoughness");
var sheen = nodeImmutable(PropertyNode, "vec3", "Sheen");
var sheenRoughness = nodeImmutable(PropertyNode, "float", "SheenRoughness");
var iridescence = nodeImmutable(PropertyNode, "float", "Iridescence");
var iridescenceIOR = nodeImmutable(PropertyNode, "float", "IridescenceIOR");
var iridescenceThickness = nodeImmutable(PropertyNode, "float", "IridescenceThickness");
var specularColor = nodeImmutable(PropertyNode, "color", "SpecularColor");
var shininess = nodeImmutable(PropertyNode, "float", "Shininess");
var output = nodeImmutable(PropertyNode, "vec4", "Output");
var dashSize = nodeImmutable(PropertyNode, "float", "dashScale");
var gapSize = nodeImmutable(PropertyNode, "float", "gapSize");
addNodeClass(PropertyNode);

// node_modules/three/examples/jsm/nodes/accessors/UVNode.js
var UVNode = class extends AttributeNode_default {
  constructor(index = 0) {
    super(null, "vec2");
    this.isUVNode = true;
    this.index = index;
  }
  getAttributeName() {
    const index = this.index;
    return "uv" + (index > 0 ? index : "");
  }
  serialize(data) {
    super.serialize(data);
    data.index = this.index;
  }
  deserialize(data) {
    super.deserialize(data);
    this.index = data.index;
  }
};
var UVNode_default = UVNode;
var uv = (...params) => nodeObject(new UVNode(...params));
addNodeClass(UVNode);

// node_modules/three/examples/jsm/nodes/accessors/TextureSizeNode.js
var TextureSizeNode = class extends Node_default {
  constructor(textureNode, levelNode = null) {
    super("uvec2");
    this.isTextureSizeNode = true;
    this.textureNode = textureNode;
    this.levelNode = levelNode;
  }
  generate(builder, output2) {
    const textureProperty = this.textureNode.build(builder, "property");
    const levelNode = this.levelNode.build(builder, "int");
    return builder.format(`textureDimensions( ${textureProperty}, ${levelNode} )`, this.getNodeType(builder), output2);
  }
};
var textureSize = nodeProxy(TextureSizeNode);
addNodeElement("textureSize", textureSize);
addNodeClass(TextureSizeNode);

// node_modules/three/examples/jsm/nodes/math/OperatorNode.js
var OperatorNode = class _OperatorNode extends TempNode_default {
  constructor(op, aNode, bNode, ...params) {
    super();
    this.op = op;
    if (params.length > 0) {
      let finalBNode = bNode;
      for (let i = 0; i < params.length; i++) {
        finalBNode = new _OperatorNode(op, finalBNode, params[i]);
      }
      bNode = finalBNode;
    }
    this.aNode = aNode;
    this.bNode = bNode;
  }
  hasDependencies(builder) {
    return this.op !== "=" ? super.hasDependencies(builder) : false;
  }
  getNodeType(builder, output2) {
    const op = this.op;
    const aNode = this.aNode;
    const bNode = this.bNode;
    const typeA = aNode.getNodeType(builder);
    const typeB = bNode.getNodeType(builder);
    if (typeA === "void" || typeB === "void") {
      return "void";
    } else if (op === "=" || op === "%") {
      return typeA;
    } else if (op === "&" || op === "|" || op === "^" || op === ">>" || op === "<<") {
      return builder.getIntegerType(typeA);
    } else if (op === "==" || op === "&&" || op === "||" || op === "^^") {
      return "bool";
    } else if (op === "<" || op === ">" || op === "<=" || op === ">=") {
      const typeLength = output2 ? builder.getTypeLength(output2) : Math.max(builder.getTypeLength(typeA), builder.getTypeLength(typeB));
      return typeLength > 1 ? `bvec${typeLength}` : "bool";
    } else {
      if (typeA === "float" && builder.isMatrix(typeB)) {
        return typeB;
      } else if (builder.isMatrix(typeA) && builder.isVector(typeB)) {
        return builder.getVectorFromMatrix(typeA);
      } else if (builder.isVector(typeA) && builder.isMatrix(typeB)) {
        return builder.getVectorFromMatrix(typeB);
      } else if (builder.getTypeLength(typeB) > builder.getTypeLength(typeA)) {
        return typeB;
      }
      return typeA;
    }
  }
  generate(builder, output2) {
    const op = this.op;
    const aNode = this.aNode;
    const bNode = this.bNode;
    const type = this.getNodeType(builder, output2);
    let typeA = null;
    let typeB = null;
    if (type !== "void") {
      typeA = aNode.getNodeType(builder);
      typeB = bNode.getNodeType(builder);
      if (op === "=") {
        typeB = typeA;
      } else if (op === "<" || op === ">" || op === "<=" || op === ">=" || op === "==") {
        if (builder.isVector(typeA)) {
          typeB = typeA;
        } else {
          typeA = typeB = "float";
        }
      } else if (op === ">>" || op === "<<") {
        typeA = type;
        typeB = builder.changeComponentType(typeB, "uint");
      } else if (builder.isMatrix(typeA) && builder.isVector(typeB)) {
        typeB = builder.getVectorFromMatrix(typeA);
      } else if (builder.isVector(typeA) && builder.isMatrix(typeB)) {
        typeA = builder.getVectorFromMatrix(typeB);
      } else {
        typeA = typeB = type;
      }
    } else {
      typeA = typeB = type;
    }
    const a = aNode.build(builder, typeA);
    const b = bNode.build(builder, typeB);
    const outputLength = builder.getTypeLength(output2);
    if (output2 !== "void") {
      if (op === "=") {
        builder.addLineFlowCode(`${a} ${this.op} ${b}`);
        return a;
      } else if (op === "<" && outputLength > 1) {
        return builder.format(`${builder.getMethod("lessThan")}( ${a}, ${b} )`, type, output2);
      } else if (op === "<=" && outputLength > 1) {
        return builder.format(`${builder.getMethod("lessThanEqual")}( ${a}, ${b} )`, type, output2);
      } else if (op === ">" && outputLength > 1) {
        return builder.format(`${builder.getMethod("greaterThan")}( ${a}, ${b} )`, type, output2);
      } else if (op === ">=" && outputLength > 1) {
        return builder.format(`${builder.getMethod("greaterThanEqual")}( ${a}, ${b} )`, type, output2);
      } else {
        return builder.format(`( ${a} ${this.op} ${b} )`, type, output2);
      }
    } else if (typeA !== "void") {
      return builder.format(`${a} ${this.op} ${b}`, type, output2);
    }
  }
  serialize(data) {
    super.serialize(data);
    data.op = this.op;
  }
  deserialize(data) {
    super.deserialize(data);
    this.op = data.op;
  }
};
var OperatorNode_default = OperatorNode;
var add = nodeProxy(OperatorNode, "+");
var sub = nodeProxy(OperatorNode, "-");
var mul = nodeProxy(OperatorNode, "*");
var div = nodeProxy(OperatorNode, "/");
var remainder = nodeProxy(OperatorNode, "%");
var equal = nodeProxy(OperatorNode, "==");
var assign = nodeProxy(OperatorNode, "=");
var lessThan = nodeProxy(OperatorNode, "<");
var greaterThan = nodeProxy(OperatorNode, ">");
var lessThanEqual = nodeProxy(OperatorNode, "<=");
var greaterThanEqual = nodeProxy(OperatorNode, ">=");
var and = nodeProxy(OperatorNode, "&&");
var or = nodeProxy(OperatorNode, "||");
var xor = nodeProxy(OperatorNode, "^^");
var bitAnd = nodeProxy(OperatorNode, "&");
var bitOr = nodeProxy(OperatorNode, "|");
var bitXor = nodeProxy(OperatorNode, "^");
var shiftLeft = nodeProxy(OperatorNode, "<<");
var shiftRight = nodeProxy(OperatorNode, ">>");
addNodeElement("add", add);
addNodeElement("sub", sub);
addNodeElement("mul", mul);
addNodeElement("div", div);
addNodeElement("remainder", remainder);
addNodeElement("equal", equal);
addNodeElement("assign", assign);
addNodeElement("lessThan", lessThan);
addNodeElement("greaterThan", greaterThan);
addNodeElement("lessThanEqual", lessThanEqual);
addNodeElement("greaterThanEqual", greaterThanEqual);
addNodeElement("and", and);
addNodeElement("or", or);
addNodeElement("xor", xor);
addNodeElement("bitAnd", bitAnd);
addNodeElement("bitOr", bitOr);
addNodeElement("bitXor", bitXor);
addNodeElement("shiftLeft", shiftLeft);
addNodeElement("shiftRight", shiftRight);
addNodeClass(OperatorNode);

// node_modules/three/examples/jsm/nodes/math/MathNode.js
var MathNode = class _MathNode extends TempNode_default {
  constructor(method, aNode, bNode = null, cNode = null) {
    super();
    this.method = method;
    this.aNode = aNode;
    this.bNode = bNode;
    this.cNode = cNode;
  }
  getInputType(builder) {
    const aType = this.aNode.getNodeType(builder);
    const bType = this.bNode ? this.bNode.getNodeType(builder) : null;
    const cType = this.cNode ? this.cNode.getNodeType(builder) : null;
    const aLen = builder.isMatrix(aType) ? 0 : builder.getTypeLength(aType);
    const bLen = builder.isMatrix(bType) ? 0 : builder.getTypeLength(bType);
    const cLen = builder.isMatrix(cType) ? 0 : builder.getTypeLength(cType);
    if (aLen > bLen && aLen > cLen) {
      return aType;
    } else if (bLen > cLen) {
      return bType;
    } else if (cLen > aLen) {
      return cType;
    }
    return aType;
  }
  getNodeType(builder) {
    const method = this.method;
    if (method === _MathNode.LENGTH || method === _MathNode.DISTANCE || method === _MathNode.DOT) {
      return "float";
    } else if (method === _MathNode.CROSS) {
      return "vec3";
    } else {
      return this.getInputType(builder);
    }
  }
  generate(builder, output2) {
    const method = this.method;
    const type = this.getNodeType(builder);
    const inputType = this.getInputType(builder);
    const a = this.aNode;
    const b = this.bNode;
    const c = this.cNode;
    const isWebGL = builder.renderer.isWebGLRenderer === true;
    if (method === _MathNode.TRANSFORM_DIRECTION) {
      let tA = a;
      let tB = b;
      if (builder.isMatrix(tA.getNodeType(builder))) {
        tB = vec4(vec3(tB), 0);
      } else {
        tA = vec4(vec3(tA), 0);
      }
      const mulNode = mul(tA, tB).xyz;
      return normalize(mulNode).build(builder, output2);
    } else if (method === _MathNode.NEGATE) {
      return builder.format("-" + a.build(builder, inputType), type, output2);
    } else if (method === _MathNode.ONE_MINUS) {
      return sub(1, a).build(builder, output2);
    } else if (method === _MathNode.RECIPROCAL) {
      return div(1, a).build(builder, output2);
    } else if (method === _MathNode.DIFFERENCE) {
      return abs(sub(a, b)).build(builder, output2);
    } else {
      const params = [];
      if (method === _MathNode.CROSS) {
        params.push(
          a.build(builder, type),
          b.build(builder, type)
        );
      } else if (method === _MathNode.STEP) {
        params.push(
          a.build(builder, builder.getTypeLength(a.getNodeType(builder)) === 1 ? "float" : inputType),
          b.build(builder, inputType)
        );
      } else if (isWebGL && (method === _MathNode.MIN || method === _MathNode.MAX) || method === _MathNode.MOD) {
        params.push(
          a.build(builder, inputType),
          b.build(builder, builder.getTypeLength(b.getNodeType(builder)) === 1 ? "float" : inputType)
        );
      } else if (method === _MathNode.REFRACT) {
        params.push(
          a.build(builder, inputType),
          b.build(builder, inputType),
          c.build(builder, "float")
        );
      } else if (method === _MathNode.MIX) {
        params.push(
          a.build(builder, inputType),
          b.build(builder, inputType),
          c.build(builder, builder.getTypeLength(c.getNodeType(builder)) === 1 ? "float" : inputType)
        );
      } else {
        params.push(a.build(builder, inputType));
        if (b !== null)
          params.push(b.build(builder, inputType));
        if (c !== null)
          params.push(c.build(builder, inputType));
      }
      return builder.format(`${builder.getMethod(method)}( ${params.join(", ")} )`, type, output2);
    }
  }
  serialize(data) {
    super.serialize(data);
    data.method = this.method;
  }
  deserialize(data) {
    super.deserialize(data);
    this.method = data.method;
  }
};
MathNode.RADIANS = "radians";
MathNode.DEGREES = "degrees";
MathNode.EXP = "exp";
MathNode.EXP2 = "exp2";
MathNode.LOG = "log";
MathNode.LOG2 = "log2";
MathNode.SQRT = "sqrt";
MathNode.INVERSE_SQRT = "inversesqrt";
MathNode.FLOOR = "floor";
MathNode.CEIL = "ceil";
MathNode.NORMALIZE = "normalize";
MathNode.FRACT = "fract";
MathNode.SIN = "sin";
MathNode.COS = "cos";
MathNode.TAN = "tan";
MathNode.ASIN = "asin";
MathNode.ACOS = "acos";
MathNode.ATAN = "atan";
MathNode.ABS = "abs";
MathNode.SIGN = "sign";
MathNode.LENGTH = "length";
MathNode.NEGATE = "negate";
MathNode.ONE_MINUS = "oneMinus";
MathNode.DFDX = "dFdx";
MathNode.DFDY = "dFdy";
MathNode.ROUND = "round";
MathNode.RECIPROCAL = "reciprocal";
MathNode.TRUNC = "trunc";
MathNode.FWIDTH = "fwidth";
MathNode.ATAN2 = "atan2";
MathNode.MIN = "min";
MathNode.MAX = "max";
MathNode.MOD = "mod";
MathNode.STEP = "step";
MathNode.REFLECT = "reflect";
MathNode.DISTANCE = "distance";
MathNode.DIFFERENCE = "difference";
MathNode.DOT = "dot";
MathNode.CROSS = "cross";
MathNode.POW = "pow";
MathNode.TRANSFORM_DIRECTION = "transformDirection";
MathNode.MIX = "mix";
MathNode.CLAMP = "clamp";
MathNode.REFRACT = "refract";
MathNode.SMOOTHSTEP = "smoothstep";
MathNode.FACEFORWARD = "faceforward";
var MathNode_default = MathNode;
var EPSILON = float(1e-6);
var INFINITY = float(1e6);
var radians = nodeProxy(MathNode, MathNode.RADIANS);
var degrees = nodeProxy(MathNode, MathNode.DEGREES);
var exp = nodeProxy(MathNode, MathNode.EXP);
var exp2 = nodeProxy(MathNode, MathNode.EXP2);
var log = nodeProxy(MathNode, MathNode.LOG);
var log2 = nodeProxy(MathNode, MathNode.LOG2);
var sqrt = nodeProxy(MathNode, MathNode.SQRT);
var inverseSqrt = nodeProxy(MathNode, MathNode.INVERSE_SQRT);
var floor = nodeProxy(MathNode, MathNode.FLOOR);
var ceil = nodeProxy(MathNode, MathNode.CEIL);
var normalize = nodeProxy(MathNode, MathNode.NORMALIZE);
var fract = nodeProxy(MathNode, MathNode.FRACT);
var sin = nodeProxy(MathNode, MathNode.SIN);
var cos = nodeProxy(MathNode, MathNode.COS);
var tan = nodeProxy(MathNode, MathNode.TAN);
var asin = nodeProxy(MathNode, MathNode.ASIN);
var acos = nodeProxy(MathNode, MathNode.ACOS);
var atan = nodeProxy(MathNode, MathNode.ATAN);
var abs = nodeProxy(MathNode, MathNode.ABS);
var sign = nodeProxy(MathNode, MathNode.SIGN);
var length = nodeProxy(MathNode, MathNode.LENGTH);
var negate = nodeProxy(MathNode, MathNode.NEGATE);
var oneMinus = nodeProxy(MathNode, MathNode.ONE_MINUS);
var dFdx = nodeProxy(MathNode, MathNode.DFDX);
var dFdy = nodeProxy(MathNode, MathNode.DFDY);
var round = nodeProxy(MathNode, MathNode.ROUND);
var reciprocal = nodeProxy(MathNode, MathNode.RECIPROCAL);
var trunc = nodeProxy(MathNode, MathNode.TRUNC);
var fwidth = nodeProxy(MathNode, MathNode.FWIDTH);
var atan2 = nodeProxy(MathNode, MathNode.ATAN2);
var min = nodeProxy(MathNode, MathNode.MIN);
var max = nodeProxy(MathNode, MathNode.MAX);
var mod = nodeProxy(MathNode, MathNode.MOD);
var step = nodeProxy(MathNode, MathNode.STEP);
var reflect = nodeProxy(MathNode, MathNode.REFLECT);
var distance = nodeProxy(MathNode, MathNode.DISTANCE);
var difference = nodeProxy(MathNode, MathNode.DIFFERENCE);
var dot = nodeProxy(MathNode, MathNode.DOT);
var cross = nodeProxy(MathNode, MathNode.CROSS);
var pow = nodeProxy(MathNode, MathNode.POW);
var pow2 = nodeProxy(MathNode, MathNode.POW, 2);
var pow3 = nodeProxy(MathNode, MathNode.POW, 3);
var pow4 = nodeProxy(MathNode, MathNode.POW, 4);
var transformDirection = nodeProxy(MathNode, MathNode.TRANSFORM_DIRECTION);
var mix = nodeProxy(MathNode, MathNode.MIX);
var clamp = (value, low = 0, high = 1) => nodeObject(new MathNode(MathNode.CLAMP, nodeObject(value), nodeObject(low), nodeObject(high)));
var saturate = (value) => clamp(value);
var refract = nodeProxy(MathNode, MathNode.REFRACT);
var smoothstep = nodeProxy(MathNode, MathNode.SMOOTHSTEP);
var faceForward = nodeProxy(MathNode, MathNode.FACEFORWARD);
var mixElement = (t, e1, e2) => mix(e1, e2, t);
var smoothstepElement = (x, low, high) => smoothstep(low, high, x);
addNodeElement("radians", radians);
addNodeElement("degrees", degrees);
addNodeElement("exp", exp);
addNodeElement("exp2", exp2);
addNodeElement("log", log);
addNodeElement("log2", log2);
addNodeElement("sqrt", sqrt);
addNodeElement("inverseSqrt", inverseSqrt);
addNodeElement("floor", floor);
addNodeElement("ceil", ceil);
addNodeElement("normalize", normalize);
addNodeElement("fract", fract);
addNodeElement("sin", sin);
addNodeElement("cos", cos);
addNodeElement("tan", tan);
addNodeElement("asin", asin);
addNodeElement("acos", acos);
addNodeElement("atan", atan);
addNodeElement("abs", abs);
addNodeElement("sign", sign);
addNodeElement("length", length);
addNodeElement("negate", negate);
addNodeElement("oneMinus", oneMinus);
addNodeElement("dFdx", dFdx);
addNodeElement("dFdy", dFdy);
addNodeElement("round", round);
addNodeElement("reciprocal", reciprocal);
addNodeElement("trunc", trunc);
addNodeElement("fwidth", fwidth);
addNodeElement("atan2", atan2);
addNodeElement("min", min);
addNodeElement("max", max);
addNodeElement("mod", mod);
addNodeElement("step", step);
addNodeElement("reflect", reflect);
addNodeElement("distance", distance);
addNodeElement("dot", dot);
addNodeElement("cross", cross);
addNodeElement("pow", pow);
addNodeElement("pow2", pow2);
addNodeElement("pow3", pow3);
addNodeElement("pow4", pow4);
addNodeElement("transformDirection", transformDirection);
addNodeElement("mix", mixElement);
addNodeElement("clamp", clamp);
addNodeElement("refract", refract);
addNodeElement("smoothstep", smoothstepElement);
addNodeElement("faceForward", faceForward);
addNodeElement("difference", difference);
addNodeElement("saturate", saturate);
addNodeClass(MathNode);

// node_modules/three/examples/jsm/nodes/display/ColorSpaceNode.js
var sRGBToLinearShader = tslFn((inputs) => {
  const { value } = inputs;
  const { rgb } = value;
  const a = rgb.mul(0.9478672986).add(0.0521327014).pow(2.4);
  const b = rgb.mul(0.0773993808);
  const factor = rgb.lessThanEqual(0.04045);
  const rgbResult = mix(a, b, factor);
  return vec4(rgbResult, value.a);
});
var LinearTosRGBShader = tslFn((inputs) => {
  const { value } = inputs;
  const { rgb } = value;
  const a = rgb.pow(0.41666).mul(1.055).sub(0.055);
  const b = rgb.mul(12.92);
  const factor = rgb.lessThanEqual(31308e-7);
  const rgbResult = mix(a, b, factor);
  return vec4(rgbResult, value.a);
});
var getColorSpaceMethod = (colorSpace) => {
  let method = null;
  if (colorSpace === LinearSRGBColorSpace) {
    method = "Linear";
  } else if (colorSpace === SRGBColorSpace) {
    method = "sRGB";
  }
  return method;
};
var getMethod = (source, target) => {
  return getColorSpaceMethod(source) + "To" + getColorSpaceMethod(target);
};
var ColorSpaceNode = class _ColorSpaceNode extends TempNode_default {
  constructor(method, node) {
    super("vec4");
    this.method = method;
    this.node = node;
  }
  construct() {
    const { method, node } = this;
    if (method === _ColorSpaceNode.LINEAR_TO_LINEAR)
      return node;
    return Methods[method]({ value: node });
  }
};
ColorSpaceNode.LINEAR_TO_LINEAR = "LinearToLinear";
ColorSpaceNode.LINEAR_TO_sRGB = "LinearTosRGB";
ColorSpaceNode.sRGB_TO_LINEAR = "sRGBToLinear";
var Methods = {
  [ColorSpaceNode.LINEAR_TO_sRGB]: LinearTosRGBShader,
  [ColorSpaceNode.sRGB_TO_LINEAR]: sRGBToLinearShader
};
var ColorSpaceNode_default = ColorSpaceNode;
var linearToColorSpace = (node, colorSpace) => nodeObject(new ColorSpaceNode(getMethod(LinearSRGBColorSpace, colorSpace), nodeObject(node)));
var colorSpaceToLinear = (node, colorSpace) => nodeObject(new ColorSpaceNode(getMethod(colorSpace, LinearSRGBColorSpace), nodeObject(node)));
var linearTosRGB = nodeProxy(ColorSpaceNode, ColorSpaceNode.LINEAR_TO_sRGB);
var sRGBToLinear = nodeProxy(ColorSpaceNode, ColorSpaceNode.sRGB_TO_LINEAR);
addNodeElement("linearTosRGB", linearTosRGB);
addNodeElement("sRGBToLinear", sRGBToLinear);
addNodeElement("linearToColorSpace", linearToColorSpace);
addNodeElement("colorSpaceToLinear", colorSpaceToLinear);
addNodeClass(ColorSpaceNode);

// node_modules/three/examples/jsm/nodes/code/ExpressionNode.js
var ExpressionNode = class extends Node_default {
  constructor(snippet = "", nodeType = "void") {
    super(nodeType);
    this.snippet = snippet;
  }
  generate(builder, output2) {
    const type = this.getNodeType(builder);
    const snippet = this.snippet;
    if (type === "void") {
      builder.addLineFlowCode(snippet);
    } else {
      return builder.format(`( ${snippet} )`, type, output2);
    }
  }
};
var ExpressionNode_default = ExpressionNode;
var expression = nodeProxy(ExpressionNode);
addNodeClass(ExpressionNode);

// node_modules/three/examples/jsm/nodes/accessors/TextureNode.js
var TextureNode = class extends UniformNode_default {
  constructor(value, uvNode = null, levelNode = null, compareNode = null) {
    super(value);
    this.isTextureNode = true;
    this.uvNode = uvNode;
    this.levelNode = levelNode;
    this.compareNode = compareNode;
    this.updateMatrix = false;
    this.updateType = NodeUpdateType.NONE;
    this.setUpdateMatrix(uvNode === null);
  }
  getUniformHash() {
    return this.value.uuid;
  }
  getNodeType() {
    if (this.value.isDepthTexture === true)
      return "float";
    return "vec4";
  }
  getInputType() {
    return "texture";
  }
  getDefaultUV() {
    return uv(this.value.channel);
  }
  getTextureMatrix(uvNode) {
    const texture2 = this.value;
    return uniform(texture2.matrix).mul(vec3(uvNode, 1)).xy;
  }
  setUpdateMatrix(value) {
    this.updateMatrix = value;
    this.updateType = value ? NodeUpdateType.FRAME : NodeUpdateType.NONE;
    return this;
  }
  construct(builder) {
    const properties = builder.getNodeProperties(this);
    let uvNode = this.uvNode;
    if (uvNode === null && builder.context.getUVNode) {
      uvNode = builder.context.getUVNode(this);
    }
    if (!uvNode)
      uvNode = this.getDefaultUV();
    if (this.updateMatrix) {
      uvNode = this.getTextureMatrix(uvNode);
    }
    let levelNode = this.levelNode;
    if (levelNode === null && builder.context.getSamplerLevelNode) {
      levelNode = builder.context.getSamplerLevelNode(this);
    }
    properties.uvNode = uvNode;
    properties.levelNode = levelNode ? builder.context.getMIPLevelAlgorithmNode(this, levelNode) : null;
  }
  generate(builder, output2) {
    const { uvNode, levelNode } = builder.getNodeProperties(this);
    const compareNode = this.compareNode;
    const texture2 = this.value;
    if (!texture2 || texture2.isTexture !== true) {
      throw new Error("TextureNode: Need a three.js texture.");
    }
    const textureProperty = super.generate(builder, "property");
    if (output2 === "sampler") {
      return textureProperty + "_sampler";
    } else if (builder.isReference(output2)) {
      return textureProperty;
    } else {
      const nodeType = this.getNodeType(builder);
      const nodeData = builder.getDataFromNode(this);
      let propertyName = nodeData.propertyName;
      if (propertyName === void 0) {
        const uvSnippet = uvNode.build(builder, "vec2");
        const nodeVar = builder.getVarFromNode(this, nodeType);
        propertyName = builder.getPropertyName(nodeVar);
        let snippet2 = null;
        if (levelNode && levelNode.isNode === true) {
          const levelSnippet = levelNode.build(builder, "float");
          snippet2 = builder.getTextureLevel(texture2, textureProperty, uvSnippet, levelSnippet);
        } else if (compareNode !== null) {
          const compareSnippet = compareNode.build(builder, "float");
          snippet2 = builder.getTextureCompare(texture2, textureProperty, uvSnippet, compareSnippet);
        } else {
          snippet2 = builder.getTexture(texture2, textureProperty, uvSnippet);
        }
        builder.addLineFlowCode(`${propertyName} = ${snippet2}`);
        if (builder.context.tempWrite !== false) {
          nodeData.snippet = snippet2;
          nodeData.propertyName = propertyName;
        }
      }
      let snippet = propertyName;
      if (builder.needsColorSpaceToLinear(this.value)) {
        snippet = colorSpaceToLinear(expression(snippet, nodeType), this.value.colorSpace).construct(builder).build(builder, nodeType);
      }
      return builder.format(snippet, nodeType, output2);
    }
  }
  uv(uvNode) {
    const textureNode = this.clone();
    textureNode.uvNode = uvNode;
    return nodeObject(textureNode);
  }
  level(levelNode) {
    const textureNode = this.clone();
    textureNode.levelNode = levelNode;
    return context(textureNode, {
      getMIPLevelAlgorithmNode: (textureNode2, levelNode2) => levelNode2
    });
  }
  size(levelNode) {
    return textureSize(this, levelNode);
  }
  compare(compareNode) {
    const textureNode = this.clone();
    textureNode.compareNode = nodeObject(compareNode);
    return nodeObject(textureNode);
  }
  serialize(data) {
    super.serialize(data);
    data.value = this.value.toJSON(data.meta).uuid;
  }
  deserialize(data) {
    super.deserialize(data);
    this.value = data.meta.textures[data.value];
  }
  update() {
    const texture2 = this.value;
    if (texture2.matrixAutoUpdate === true) {
      texture2.updateMatrix();
    }
  }
  clone() {
    return new this.constructor(this.value, this.uvNode, this.levelNode, this.compareNode);
  }
};
var TextureNode_default = TextureNode;
var texture = nodeProxy(TextureNode);
var sampler = (aTexture) => (aTexture.isNode === true ? aTexture : texture(aTexture)).convert("sampler");
addNodeElement("texture", texture);
addNodeClass(TextureNode);

// node_modules/three/examples/jsm/nodes/accessors/ReferenceNode.js
var ReferenceNode = class extends Node_default {
  constructor(property2, uniformType, object = null) {
    super();
    this.property = property2;
    this.uniformType = uniformType;
    this.object = object;
    this.node = null;
    this.updateType = NodeUpdateType.OBJECT;
    this.setNodeType(uniformType);
  }
  setNodeType(uniformType) {
    let node = null;
    if (uniformType === "texture") {
      node = texture(null);
    } else {
      node = uniform(uniformType);
    }
    this.node = node;
  }
  getNodeType(builder) {
    return this.node.getNodeType(builder);
  }
  update(frame) {
    const object = this.object !== null ? this.object : frame.object;
    const property2 = this.property;
    this.node.value = object[property2];
  }
  construct() {
    return this.node;
  }
};
var ReferenceNode_default = ReferenceNode;
var reference = (name, type, object) => nodeObject(new ReferenceNode(name, type, object));
addNodeClass(ReferenceNode);

// node_modules/three/examples/jsm/nodes/accessors/MaterialReferenceNode.js
var MaterialReferenceNode = class extends ReferenceNode_default {
  constructor(property2, inputType, material = null) {
    super(property2, inputType, material);
    this.material = material;
    this.updateType = NodeUpdateType.RENDER;
  }
  construct(builder) {
    const material = this.material !== null ? this.material : builder.material;
    this.node.value = material[this.property];
    return super.construct(builder);
  }
  update(frame) {
    this.object = this.material !== null ? this.material : frame.material;
    super.update(frame);
  }
};
var MaterialReferenceNode_default = MaterialReferenceNode;
var materialReference = (name, type, material) => nodeObject(new MaterialReferenceNode(name, type, material));
addNodeClass(MaterialReferenceNode);

// node_modules/three/examples/jsm/nodes/accessors/MaterialNode.js
var cache2 = /* @__PURE__ */ new WeakMap();
var MaterialNode = class _MaterialNode extends Node_default {
  constructor(scope) {
    super();
    this.scope = scope;
  }
  getCache(builder, property2, type) {
    const material = builder.context.material;
    let cacheMaterial = cache2.get(material);
    if (cacheMaterial === void 0) {
      cacheMaterial = {};
      cache2.set(material, cacheMaterial);
    }
    let node = cacheMaterial[property2];
    if (node === void 0) {
      node = materialReference(property2, type);
      cacheMaterial[property2] = node;
    }
    return node;
  }
  getFloat(builder, property2) {
    return this.getCache(builder, property2, "float");
  }
  getColor(builder, property2) {
    return this.getCache(builder, property2, "color");
  }
  getTexture(builder, property2) {
    return this.getCache(builder, property2, "texture");
  }
  construct(builder) {
    const material = builder.context.material;
    const scope = this.scope;
    let node = null;
    if (scope === _MaterialNode.ALPHA_TEST || scope === _MaterialNode.SHININESS || scope === _MaterialNode.REFLECTIVITY || scope === _MaterialNode.ROTATION || scope === _MaterialNode.IRIDESCENCE || scope === _MaterialNode.IRIDESCENCE_IOR) {
      node = this.getFloat(builder, scope);
    } else if (scope === _MaterialNode.SPECULAR_COLOR) {
      node = this.getColor(builder, "specular");
    } else if (scope === _MaterialNode.COLOR) {
      const colorNode = this.getColor(builder, "color");
      if (material.map && material.map.isTexture === true) {
        node = colorNode.mul(this.getTexture(builder, "map"));
      } else {
        node = colorNode;
      }
    } else if (scope === _MaterialNode.OPACITY) {
      const opacityNode = this.getFloat(builder, "opacity");
      if (material.alphaMap && material.alphaMap.isTexture === true) {
        node = opacityNode.mul(this.getTexture(builder, "alphaMap"));
      } else {
        node = opacityNode;
      }
    } else if (scope === _MaterialNode.SPECULAR_STRENGTH) {
      if (material.specularMap && material.specularMap.isTexture === true) {
        node = this.getTexture(builder, "specularMap").r;
      } else {
        node = float(1);
      }
    } else if (scope === _MaterialNode.ROUGHNESS) {
      const roughnessNode = this.getFloat(builder, "roughness");
      if (material.roughnessMap && material.roughnessMap.isTexture === true) {
        node = roughnessNode.mul(this.getTexture(builder, "roughnessMap").g);
      } else {
        node = roughnessNode;
      }
    } else if (scope === _MaterialNode.METALNESS) {
      const metalnessNode = this.getFloat(builder, "metalness");
      if (material.metalnessMap && material.metalnessMap.isTexture === true) {
        node = metalnessNode.mul(this.getTexture(builder, "metalnessMap").b);
      } else {
        node = metalnessNode;
      }
    } else if (scope === _MaterialNode.EMISSIVE) {
      const emissiveNode = this.getColor(builder, "emissive");
      if (material.emissiveMap && material.emissiveMap.isTexture === true) {
        node = emissiveNode.mul(this.getTexture(builder, "emissiveMap"));
      } else {
        node = emissiveNode;
      }
    } else if (scope === _MaterialNode.CLEARCOAT) {
      const clearcoatNode = this.getFloat(builder, "clearcoat");
      if (material.clearcoatMap && material.clearcoatMap.isTexture === true) {
        node = clearcoatNode.mul(this.getTexture(builder, "clearcoatMap").r);
      } else {
        node = clearcoatNode;
      }
    } else if (scope === _MaterialNode.CLEARCOAT_ROUGHNESS) {
      const clearcoatRoughnessNode = this.getFloat(builder, "clearcoatRoughness");
      if (material.clearcoatRoughnessMap && material.clearcoatRoughnessMap.isTexture === true) {
        node = clearcoatRoughnessNode.mul(this.getTexture(builder, "clearcoatRoughnessMap").r);
      } else {
        node = clearcoatRoughnessNode;
      }
    } else if (scope === _MaterialNode.SHEEN) {
      const sheenNode = this.getColor(builder, "sheenColor").mul(this.getFloat(builder, "sheen"));
      if (material.sheenColorMap && material.sheenColorMap.isTexture === true) {
        node = sheenNode.mul(this.getTexture(builder, "sheenColorMap").rgb);
      } else {
        node = sheenNode;
      }
    } else if (scope === _MaterialNode.SHEEN_ROUGHNESS) {
      const sheenRoughnessNode = this.getFloat(builder, "sheenRoughness");
      if (material.sheenRoughnessMap && material.sheenRoughnessMap.isTexture === true) {
        node = sheenRoughnessNode.mul(this.getTexture(builder, "sheenRoughnessMap").a);
      } else {
        node = sheenRoughnessNode;
      }
      node = node.clamp(0.07, 1);
    } else if (scope === _MaterialNode.IRIDESCENCE_THICKNESS) {
      const iridescenceThicknessMaximum = reference(1, "float", material.iridescenceThicknessRange);
      if (material.iridescenceThicknessMap) {
        const iridescenceThicknessMinimum = reference(0, "float", material.iridescenceThicknessRange);
        node = iridescenceThicknessMaximum.sub(iridescenceThicknessMinimum).mul(this.getTexture(builder, "iridescenceThicknessMap").g).add(iridescenceThicknessMinimum);
      } else {
        node = iridescenceThicknessMaximum;
      }
    } else {
      const outputType = this.getNodeType(builder);
      node = materialReference(scope, outputType);
    }
    return node;
  }
};
MaterialNode.ALPHA_TEST = "alphaTest";
MaterialNode.COLOR = "color";
MaterialNode.OPACITY = "opacity";
MaterialNode.SHININESS = "shininess";
MaterialNode.SPECULAR = "specular";
MaterialNode.SPECULAR_STRENGTH = "specularStrength";
MaterialNode.REFLECTIVITY = "reflectivity";
MaterialNode.ROUGHNESS = "roughness";
MaterialNode.METALNESS = "metalness";
MaterialNode.CLEARCOAT = "clearcoat";
MaterialNode.CLEARCOAT_ROUGHNESS = "clearcoatRoughness";
MaterialNode.EMISSIVE = "emissive";
MaterialNode.ROTATION = "rotation";
MaterialNode.SHEEN = "sheen";
MaterialNode.SHEEN_ROUGHNESS = "sheenRoughness";
MaterialNode.IRIDESCENCE = "iridescence";
MaterialNode.IRIDESCENCE_IOR = "iridescenceIOR";
MaterialNode.IRIDESCENCE_THICKNESS = "iridescenceThickness";
var MaterialNode_default = MaterialNode;
var materialAlphaTest = nodeImmutable(MaterialNode, MaterialNode.ALPHA_TEST);
var materialColor = nodeImmutable(MaterialNode, MaterialNode.COLOR);
var materialShininess = nodeImmutable(MaterialNode, MaterialNode.SHININESS);
var materialEmissive = nodeImmutable(MaterialNode, MaterialNode.EMISSIVE);
var materialOpacity = nodeImmutable(MaterialNode, MaterialNode.OPACITY);
var materialSpecularColor = nodeImmutable(MaterialNode, MaterialNode.SPECULAR_COLOR);
var materialSpecularStrength = nodeImmutable(MaterialNode, MaterialNode.SPECULAR_STRENGTH);
var materialReflectivity = nodeImmutable(MaterialNode, MaterialNode.REFLECTIVITY);
var materialRoughness = nodeImmutable(MaterialNode, MaterialNode.ROUGHNESS);
var materialMetalness = nodeImmutable(MaterialNode, MaterialNode.METALNESS);
var materialClearcoat = nodeImmutable(MaterialNode, MaterialNode.CLEARCOAT);
var materialClearcoatRoughness = nodeImmutable(MaterialNode, MaterialNode.CLEARCOAT_ROUGHNESS);
var materialRotation = nodeImmutable(MaterialNode, MaterialNode.ROTATION);
var materialSheen = nodeImmutable(MaterialNode, MaterialNode.SHEEN);
var materialSheenRoughness = nodeImmutable(MaterialNode, MaterialNode.SHEEN_ROUGHNESS);
var materialIridescence = nodeImmutable(MaterialNode, MaterialNode.IRIDESCENCE);
var materialIridescenceIOR = nodeImmutable(MaterialNode, MaterialNode.IRIDESCENCE_IOR);
var materialIridescenceThickness = nodeImmutable(MaterialNode, MaterialNode.IRIDESCENCE_THICKNESS);
addNodeClass(MaterialNode);

// node_modules/three/examples/jsm/nodes/accessors/Object3DNode.js
var Object3DNode = class _Object3DNode extends Node_default {
  constructor(scope = _Object3DNode.VIEW_MATRIX, object3d = null) {
    super();
    this.scope = scope;
    this.object3d = object3d;
    this.updateType = NodeUpdateType.OBJECT;
    this._uniformNode = new UniformNode_default(null);
  }
  getNodeType() {
    const scope = this.scope;
    if (scope === _Object3DNode.WORLD_MATRIX || scope === _Object3DNode.VIEW_MATRIX) {
      return "mat4";
    } else if (scope === _Object3DNode.NORMAL_MATRIX) {
      return "mat3";
    } else if (scope === _Object3DNode.POSITION || scope === _Object3DNode.VIEW_POSITION || scope === _Object3DNode.DIRECTION || scope === _Object3DNode.SCALE) {
      return "vec3";
    }
  }
  update(frame) {
    const object = this.object3d;
    const uniformNode = this._uniformNode;
    const scope = this.scope;
    if (scope === _Object3DNode.VIEW_MATRIX) {
      uniformNode.value = object.modelViewMatrix;
    } else if (scope === _Object3DNode.NORMAL_MATRIX) {
      uniformNode.value = object.normalMatrix;
    } else if (scope === _Object3DNode.WORLD_MATRIX) {
      uniformNode.value = object.matrixWorld;
    } else if (scope === _Object3DNode.POSITION) {
      uniformNode.value = uniformNode.value || new Vector3();
      uniformNode.value.setFromMatrixPosition(object.matrixWorld);
    } else if (scope === _Object3DNode.SCALE) {
      uniformNode.value = uniformNode.value || new Vector3();
      uniformNode.value.setFromMatrixScale(object.matrixWorld);
    } else if (scope === _Object3DNode.DIRECTION) {
      uniformNode.value = uniformNode.value || new Vector3();
      object.getWorldDirection(uniformNode.value);
    } else if (scope === _Object3DNode.VIEW_POSITION) {
      const camera = frame.camera;
      uniformNode.value = uniformNode.value || new Vector3();
      uniformNode.value.setFromMatrixPosition(object.matrixWorld);
      uniformNode.value.applyMatrix4(camera.matrixWorldInverse);
    }
  }
  generate(builder) {
    const scope = this.scope;
    if (scope === _Object3DNode.WORLD_MATRIX || scope === _Object3DNode.VIEW_MATRIX) {
      this._uniformNode.nodeType = "mat4";
    } else if (scope === _Object3DNode.NORMAL_MATRIX) {
      this._uniformNode.nodeType = "mat3";
    } else if (scope === _Object3DNode.POSITION || scope === _Object3DNode.VIEW_POSITION || scope === _Object3DNode.DIRECTION || scope === _Object3DNode.SCALE) {
      this._uniformNode.nodeType = "vec3";
    }
    return this._uniformNode.build(builder);
  }
  serialize(data) {
    super.serialize(data);
    data.scope = this.scope;
  }
  deserialize(data) {
    super.deserialize(data);
    this.scope = data.scope;
  }
};
Object3DNode.VIEW_MATRIX = "viewMatrix";
Object3DNode.NORMAL_MATRIX = "normalMatrix";
Object3DNode.WORLD_MATRIX = "worldMatrix";
Object3DNode.POSITION = "position";
Object3DNode.SCALE = "scale";
Object3DNode.VIEW_POSITION = "viewPosition";
Object3DNode.DIRECTION = "direction";
var Object3DNode_default = Object3DNode;
var objectDirection = nodeProxy(Object3DNode, Object3DNode.DIRECTION);
var objectViewMatrix = nodeProxy(Object3DNode, Object3DNode.VIEW_MATRIX);
var objectNormalMatrix = nodeProxy(Object3DNode, Object3DNode.NORMAL_MATRIX);
var objectWorldMatrix = nodeProxy(Object3DNode, Object3DNode.WORLD_MATRIX);
var objectPosition = nodeProxy(Object3DNode, Object3DNode.POSITION);
var objectScale = nodeProxy(Object3DNode, Object3DNode.SCALE);
var objectViewPosition = nodeProxy(Object3DNode, Object3DNode.VIEW_POSITION);
addNodeClass(Object3DNode);

// node_modules/three/examples/jsm/nodes/accessors/CameraNode.js
var CameraNode = class _CameraNode extends Object3DNode_default {
  constructor(scope = _CameraNode.POSITION) {
    super(scope);
  }
  getNodeType(builder) {
    const scope = this.scope;
    if (scope === _CameraNode.PROJECTION_MATRIX) {
      return "mat4";
    } else if (scope === _CameraNode.NEAR || scope === _CameraNode.FAR) {
      return "float";
    }
    return super.getNodeType(builder);
  }
  update(frame) {
    const camera = frame.camera;
    const uniformNode = this._uniformNode;
    const scope = this.scope;
    if (scope === _CameraNode.VIEW_MATRIX) {
      uniformNode.value = camera.matrixWorldInverse;
    } else if (scope === _CameraNode.PROJECTION_MATRIX) {
      uniformNode.value = camera.projectionMatrix;
    } else if (scope === _CameraNode.NEAR) {
      uniformNode.value = camera.near;
    } else if (scope === _CameraNode.FAR) {
      uniformNode.value = camera.far;
    } else {
      this.object3d = camera;
      super.update(frame);
    }
  }
  generate(builder) {
    const scope = this.scope;
    if (scope === _CameraNode.PROJECTION_MATRIX) {
      this._uniformNode.nodeType = "mat4";
    } else if (scope === _CameraNode.NEAR || scope === _CameraNode.FAR) {
      this._uniformNode.nodeType = "float";
    }
    return super.generate(builder);
  }
};
CameraNode.PROJECTION_MATRIX = "projectionMatrix";
CameraNode.NEAR = "near";
CameraNode.FAR = "far";
var CameraNode_default = CameraNode;
var cameraProjectionMatrix = label(nodeImmutable(CameraNode, CameraNode.PROJECTION_MATRIX), "projectionMatrix");
var cameraNear = nodeImmutable(CameraNode, CameraNode.NEAR);
var cameraFar = nodeImmutable(CameraNode, CameraNode.FAR);
var cameraViewMatrix = nodeImmutable(CameraNode, CameraNode.VIEW_MATRIX);
var cameraNormalMatrix = nodeImmutable(CameraNode, CameraNode.NORMAL_MATRIX);
var cameraWorldMatrix = nodeImmutable(CameraNode, CameraNode.WORLD_MATRIX);
var cameraPosition = nodeImmutable(CameraNode, CameraNode.POSITION);
addNodeClass(CameraNode);

// node_modules/three/examples/jsm/nodes/accessors/ModelNode.js
var ModelNode = class _ModelNode extends Object3DNode_default {
  constructor(scope = _ModelNode.VIEW_MATRIX) {
    super(scope);
  }
  update(frame) {
    this.object3d = frame.object;
    super.update(frame);
  }
};
var ModelNode_default = ModelNode;
var modelDirection = nodeImmutable(ModelNode, ModelNode.DIRECTION);
var modelViewMatrix = label(nodeImmutable(ModelNode, ModelNode.VIEW_MATRIX), "modelViewMatrix");
var modelNormalMatrix = nodeImmutable(ModelNode, ModelNode.NORMAL_MATRIX);
var modelWorldMatrix = nodeImmutable(ModelNode, ModelNode.WORLD_MATRIX);
var modelPosition = nodeImmutable(ModelNode, ModelNode.POSITION);
var modelScale = nodeImmutable(ModelNode, ModelNode.SCALE);
var modelViewPosition = nodeImmutable(ModelNode, ModelNode.VIEW_POSITION);
addNodeClass(ModelNode);

// node_modules/three/examples/jsm/nodes/accessors/NormalNode.js
var NormalNode = class _NormalNode extends Node_default {
  constructor(scope = _NormalNode.LOCAL) {
    super("vec3");
    this.scope = scope;
  }
  isGlobal() {
    return true;
  }
  getHash() {
    return `normal-${this.scope}`;
  }
  generate(builder) {
    const scope = this.scope;
    let outputNode = null;
    if (scope === _NormalNode.GEOMETRY) {
      outputNode = attribute("normal", "vec3");
    } else if (scope === _NormalNode.LOCAL) {
      outputNode = varying(normalGeometry);
    } else if (scope === _NormalNode.VIEW) {
      const vertexNode = modelNormalMatrix.mul(normalLocal);
      outputNode = normalize(varying(vertexNode));
    } else if (scope === _NormalNode.WORLD) {
      const vertexNode = normalView.transformDirection(cameraViewMatrix);
      outputNode = normalize(varying(vertexNode));
    }
    return outputNode.build(builder, this.getNodeType(builder));
  }
  serialize(data) {
    super.serialize(data);
    data.scope = this.scope;
  }
  deserialize(data) {
    super.deserialize(data);
    this.scope = data.scope;
  }
};
NormalNode.GEOMETRY = "geometry";
NormalNode.LOCAL = "local";
NormalNode.VIEW = "view";
NormalNode.WORLD = "world";
var NormalNode_default = NormalNode;
var normalGeometry = nodeImmutable(NormalNode, NormalNode.GEOMETRY);
var normalLocal = nodeImmutable(NormalNode, NormalNode.LOCAL);
var normalView = nodeImmutable(NormalNode, NormalNode.VIEW);
var normalWorld = nodeImmutable(NormalNode, NormalNode.WORLD);
var transformedNormalView = property("vec3", "TransformedNormalView");
var transformedNormalWorld = transformedNormalView.transformDirection(cameraViewMatrix).normalize();
var transformedClearcoatNormalView = property("vec3", "TransformedClearcoatNormalView");
addNodeClass(NormalNode);

// node_modules/three/examples/jsm/nodes/core/VarNode.js
var VarNode = class extends Node_default {
  constructor(node, name = null) {
    super();
    this.node = node;
    this.name = name;
  }
  assign(node) {
    node.traverse((childNode, replaceNode) => {
      if (replaceNode && childNode.uuid === this.uuid) {
        replaceNode(this.node);
      }
    });
    this.node = node;
    return this;
  }
  isGlobal() {
    return true;
  }
  getHash(builder) {
    return this.name || super.getHash(builder);
  }
  getNodeType(builder) {
    return this.node.getNodeType(builder);
  }
  generate(builder) {
    const node = this.node;
    const name = this.name;
    if (name === null && node.isTempNode === true) {
      return node.build(builder);
    }
    const type = builder.getVectorType(this.getNodeType(builder));
    const snippet = node.build(builder, type);
    const nodeVar = builder.getVarFromNode(this, type);
    if (name !== null) {
      nodeVar.name = name;
    }
    const propertyName = builder.getPropertyName(nodeVar);
    builder.addLineFlowCode(`${propertyName} = ${snippet}`);
    return propertyName;
  }
};
var VarNode_default = VarNode;
var temp = nodeProxy(VarNode);
addNodeElement("temp", temp);
addNodeClass(VarNode);

// node_modules/three/examples/jsm/nodes/accessors/TangentNode.js
var TangentNode = class _TangentNode extends Node_default {
  constructor(scope = _TangentNode.LOCAL) {
    super();
    this.scope = scope;
  }
  getHash() {
    return `tangent-${this.scope}`;
  }
  getNodeType() {
    const scope = this.scope;
    if (scope === _TangentNode.GEOMETRY) {
      return "vec4";
    }
    return "vec3";
  }
  generate(builder) {
    const scope = this.scope;
    let outputNode = null;
    if (scope === _TangentNode.GEOMETRY) {
      outputNode = attribute("tangent", "vec4");
    } else if (scope === _TangentNode.LOCAL) {
      outputNode = varying(tangentGeometry.xyz);
    } else if (scope === _TangentNode.VIEW) {
      const vertexNode = modelViewMatrix.mul(tangentLocal).xyz;
      outputNode = normalize(varying(vertexNode));
    } else if (scope === _TangentNode.WORLD) {
      const vertexNode = tangentView.transformDirection(cameraViewMatrix);
      outputNode = normalize(varying(vertexNode));
    }
    return outputNode.build(builder, this.getNodeType(builder));
  }
  serialize(data) {
    super.serialize(data);
    data.scope = this.scope;
  }
  deserialize(data) {
    super.deserialize(data);
    this.scope = data.scope;
  }
};
TangentNode.GEOMETRY = "geometry";
TangentNode.LOCAL = "local";
TangentNode.VIEW = "view";
TangentNode.WORLD = "world";
var TangentNode_default = TangentNode;
var tangentGeometry = nodeImmutable(TangentNode, TangentNode.GEOMETRY);
var tangentLocal = nodeImmutable(TangentNode, TangentNode.LOCAL);
var tangentView = nodeImmutable(TangentNode, TangentNode.VIEW);
var tangentWorld = nodeImmutable(TangentNode, TangentNode.WORLD);
var transformedTangentView = temp(tangentView, "TransformedTangentView");
var transformedTangentWorld = normalize(transformedTangentView.transformDirection(cameraViewMatrix));
addNodeClass(TangentNode);

// node_modules/three/examples/jsm/nodes/accessors/BitangentNode.js
var BitangentNode = class _BitangentNode extends Node_default {
  constructor(scope = _BitangentNode.LOCAL) {
    super("vec3");
    this.scope = scope;
  }
  getHash() {
    return `bitangent-${this.scope}`;
  }
  generate(builder) {
    const scope = this.scope;
    let crossNormalTangent;
    if (scope === _BitangentNode.GEOMETRY) {
      crossNormalTangent = normalGeometry.cross(tangentGeometry);
    } else if (scope === _BitangentNode.LOCAL) {
      crossNormalTangent = normalLocal.cross(tangentLocal);
    } else if (scope === _BitangentNode.VIEW) {
      crossNormalTangent = normalView.cross(tangentView);
    } else if (scope === _BitangentNode.WORLD) {
      crossNormalTangent = normalWorld.cross(tangentWorld);
    }
    const vertexNode = crossNormalTangent.mul(tangentGeometry.w).xyz;
    const outputNode = normalize(varying(vertexNode));
    return outputNode.build(builder, this.getNodeType(builder));
  }
  serialize(data) {
    super.serialize(data);
    data.scope = this.scope;
  }
  deserialize(data) {
    super.deserialize(data);
    this.scope = data.scope;
  }
};
BitangentNode.GEOMETRY = "geometry";
BitangentNode.LOCAL = "local";
BitangentNode.VIEW = "view";
BitangentNode.WORLD = "world";
var BitangentNode_default = BitangentNode;
var bitangentGeometry = nodeImmutable(BitangentNode, BitangentNode.GEOMETRY);
var bitangentLocal = nodeImmutable(BitangentNode, BitangentNode.LOCAL);
var bitangentView = nodeImmutable(BitangentNode, BitangentNode.VIEW);
var bitangentWorld = nodeImmutable(BitangentNode, BitangentNode.WORLD);
var transformedBitangentView = normalize(transformedNormalView.cross(transformedTangentView).mul(tangentGeometry.w));
var transformedBitangentWorld = normalize(transformedBitangentView.transformDirection(cameraViewMatrix));
addNodeClass(BitangentNode);

// node_modules/three/examples/jsm/nodes/accessors/PositionNode.js
var PositionNode = class _PositionNode extends Node_default {
  constructor(scope = _PositionNode.LOCAL) {
    super("vec3");
    this.scope = scope;
  }
  isGlobal() {
    return true;
  }
  getHash() {
    return `position-${this.scope}`;
  }
  generate(builder) {
    const scope = this.scope;
    let outputNode = null;
    if (scope === _PositionNode.GEOMETRY) {
      outputNode = attribute("position", "vec3");
    } else if (scope === _PositionNode.LOCAL) {
      outputNode = varying(positionGeometry);
    } else if (scope === _PositionNode.WORLD) {
      const vertexPositionNode = modelWorldMatrix.mul(positionLocal);
      outputNode = varying(vertexPositionNode);
    } else if (scope === _PositionNode.VIEW) {
      const vertexPositionNode = modelViewMatrix.mul(positionLocal);
      outputNode = varying(vertexPositionNode);
    } else if (scope === _PositionNode.VIEW_DIRECTION) {
      const vertexPositionNode = positionView.negate();
      outputNode = normalize(varying(vertexPositionNode));
    } else if (scope === _PositionNode.WORLD_DIRECTION) {
      const vertexPositionNode = positionLocal.transformDirection(modelWorldMatrix);
      outputNode = normalize(varying(vertexPositionNode));
    }
    return outputNode.build(builder, this.getNodeType(builder));
  }
  serialize(data) {
    super.serialize(data);
    data.scope = this.scope;
  }
  deserialize(data) {
    super.deserialize(data);
    this.scope = data.scope;
  }
};
PositionNode.GEOMETRY = "geometry";
PositionNode.LOCAL = "local";
PositionNode.WORLD = "world";
PositionNode.WORLD_DIRECTION = "worldDirection";
PositionNode.VIEW = "view";
PositionNode.VIEW_DIRECTION = "viewDirection";
var PositionNode_default = PositionNode;
var positionGeometry = nodeImmutable(PositionNode, PositionNode.GEOMETRY);
var positionLocal = nodeImmutable(PositionNode, PositionNode.LOCAL);
var positionWorld = nodeImmutable(PositionNode, PositionNode.WORLD);
var positionWorldDirection = nodeImmutable(PositionNode, PositionNode.WORLD_DIRECTION);
var positionView = nodeImmutable(PositionNode, PositionNode.VIEW);
var positionViewDirection = nodeImmutable(PositionNode, PositionNode.VIEW_DIRECTION);
addNodeClass(PositionNode);

// node_modules/three/examples/jsm/nodes/display/FrontFacingNode.js
var FrontFacingNode = class extends Node_default {
  constructor() {
    super("bool");
    this.isFrontFacingNode = true;
  }
  generate(builder) {
    return builder.getFrontFacing();
  }
};
var FrontFacingNode_default = FrontFacingNode;
var frontFacing = nodeImmutable(FrontFacingNode);
var faceDirection = float(frontFacing).mul(2).sub(1);
addNodeClass(FrontFacingNode);

// node_modules/three/examples/jsm/nodes/display/NormalMapNode.js
var perturbNormal2Arb = tslFn((inputs) => {
  const { eye_pos, surf_norm, mapN, uv: uv2 } = inputs;
  const q0 = eye_pos.dFdx();
  const q1 = eye_pos.dFdy();
  const st0 = uv2.dFdx();
  const st1 = uv2.dFdy();
  const N = surf_norm;
  const q1perp = q1.cross(N);
  const q0perp = N.cross(q0);
  const T = q1perp.mul(st0.x).add(q0perp.mul(st1.x));
  const B = q1perp.mul(st0.y).add(q0perp.mul(st1.y));
  const det = T.dot(T).max(B.dot(B));
  const scale = faceDirection.mul(det.inverseSqrt());
  return add(T.mul(mapN.x, scale), B.mul(mapN.y, scale), N.mul(mapN.z)).normalize();
});
var NormalMapNode = class extends TempNode_default {
  constructor(node, scaleNode = null) {
    super("vec3");
    this.node = node;
    this.scaleNode = scaleNode;
    this.normalMapType = TangentSpaceNormalMap;
  }
  construct(builder) {
    const { normalMapType, scaleNode } = this;
    let normalMap2 = this.node.mul(2).sub(1);
    if (scaleNode !== null) {
      normalMap2 = vec3(normalMap2.xy.mul(scaleNode), normalMap2.z);
    }
    let outputNode = null;
    if (normalMapType === ObjectSpaceNormalMap) {
      outputNode = modelNormalMatrix.mul(normalMap2).normalize();
    } else if (normalMapType === TangentSpaceNormalMap) {
      const tangent = builder.hasGeometryAttribute("tangent");
      if (tangent === true) {
        outputNode = TBNViewMatrix.mul(normalMap2).normalize();
      } else {
        outputNode = perturbNormal2Arb({
          eye_pos: positionView,
          surf_norm: normalView,
          mapN: normalMap2,
          uv: uv()
        });
      }
    }
    return outputNode;
  }
};
var NormalMapNode_default = NormalMapNode;
var normalMap = nodeProxy(NormalMapNode);
var TBNViewMatrix = mat3(tangentView, bitangentView, normalView);
addNodeClass(NormalMapNode);

// node_modules/three/examples/jsm/nodes/display/BumpMapNode.js
var dHdxy_fwd = tslFn(({ bumpTexture, bumpScale }) => {
  const uvNode = uv();
  const Hll = texture(bumpTexture, uvNode).x;
  return vec2(
    texture(bumpTexture, uvNode.add(uvNode.dFdx())).x.sub(Hll),
    texture(bumpTexture, uvNode.add(uvNode.dFdy())).x.sub(Hll)
  ).mul(bumpScale);
});
var perturbNormalArb = tslFn((inputs) => {
  const { surf_pos, surf_norm, dHdxy } = inputs;
  const vSigmaX = surf_pos.dFdx();
  const vSigmaY = surf_pos.dFdy();
  const vN = surf_norm;
  const R1 = vSigmaY.cross(vN);
  const R2 = vN.cross(vSigmaX);
  const fDet = vSigmaX.dot(R1).mul(faceDirection);
  const vGrad = fDet.sign().mul(dHdxy.x.mul(R1).add(dHdxy.y.mul(R2)));
  return fDet.abs().mul(surf_norm).sub(vGrad).normalize();
});
var BumpMapNode = class extends TempNode_default {
  constructor(texture2, scaleNode = null) {
    super("vec3");
    this.texture = texture2;
    this.scaleNode = scaleNode;
  }
  construct() {
    const bumpScale = this.scaleNode !== null ? this.scaleNode : 1;
    const dHdxy = dHdxy_fwd({ bumpTexture: this.texture, bumpScale });
    return perturbNormalArb({
      surf_pos: positionView.negate(),
      surf_norm: normalView,
      dHdxy
    });
  }
};
var bumpMap = nodeProxy(BumpMapNode);
addNodeClass(BumpMapNode);

// node_modules/three/examples/jsm/nodes/accessors/ExtendedMaterialNode.js
var ExtendedMaterialNode = class _ExtendedMaterialNode extends MaterialNode_default {
  constructor(scope) {
    super(scope);
  }
  getNodeType(builder) {
    const scope = this.scope;
    let type = null;
    if (scope === _ExtendedMaterialNode.NORMAL || scope === _ExtendedMaterialNode.CLEARCOAT_NORMAL) {
      type = "vec3";
    }
    return type || super.getNodeType(builder);
  }
  construct(builder) {
    const material = builder.material;
    const scope = this.scope;
    let node = null;
    if (scope === _ExtendedMaterialNode.NORMAL) {
      if (material.normalMap) {
        node = normalMap(this.getTexture(builder, "normalMap"), materialReference("normalScale", "vec2"));
      } else if (material.bumpMap) {
        node = bumpMap(material.bumpMap, materialReference("bumpScale", "float"));
      } else {
        node = normalView;
      }
    } else if (scope === _ExtendedMaterialNode.CLEARCOAT_NORMAL) {
      node = material.clearcoatNormalMap ? normalMap(this.getTexture(builder, "clearcoatNormalMap"), materialReference("clearcoatNormalScale", "vec2")) : normalView;
    }
    return node || super.construct(builder);
  }
};
ExtendedMaterialNode.NORMAL = "normal";
ExtendedMaterialNode.CLEARCOAT_NORMAL = "clearcoatNormal";
var ExtendedMaterialNode_default = ExtendedMaterialNode;
var materialNormal = nodeImmutable(ExtendedMaterialNode, ExtendedMaterialNode.NORMAL);
var materialClearcoatNormal = nodeImmutable(ExtendedMaterialNode, ExtendedMaterialNode.CLEARCOAT_NORMAL);
addNodeClass(ExtendedMaterialNode);

// node_modules/three/examples/jsm/nodes/accessors/ModelViewProjectionNode.js
var ModelViewProjectionNode = class extends Node_default {
  constructor(positionNode = positionLocal) {
    super("vec4");
    this.positionNode = positionNode;
  }
  construct() {
    return cameraProjectionMatrix.mul(modelViewMatrix).mul(this.positionNode);
  }
};
var ModelViewProjectionNode_default = ModelViewProjectionNode;
var modelViewProjection = nodeProxy(ModelViewProjectionNode);
addNodeClass(ModelViewProjectionNode);

// node_modules/three/examples/jsm/nodes/accessors/BufferAttributeNode.js
var BufferAttributeNode = class extends InputNode_default {
  constructor(value, bufferType = null, bufferStride = 0, bufferOffset = 0) {
    super(value, bufferType);
    this.isBufferNode = true;
    this.bufferType = bufferType;
    this.bufferStride = bufferStride;
    this.bufferOffset = bufferOffset;
    this.usage = StaticDrawUsage;
    this.instanced = false;
    this.attribute = null;
    if (value && value.isBufferAttribute === true) {
      this.attribute = value;
      this.usage = value.usage;
      this.instanced = value.isInstancedBufferAttribute;
    }
  }
  getNodeType(builder) {
    if (this.bufferType === null) {
      this.bufferType = builder.getTypeFromAttribute(this.attribute);
    }
    return this.bufferType;
  }
  construct(builder) {
    if (this.attribute !== null)
      return;
    const type = this.getNodeType(builder);
    const array = this.value;
    const itemSize = builder.getTypeLength(type);
    const stride = this.bufferStride || itemSize;
    const offset = this.bufferOffset;
    const buffer2 = array.isInterleavedBuffer === true ? array : new InterleavedBuffer(array, stride);
    const bufferAttribute2 = new InterleavedBufferAttribute(buffer2, itemSize, offset);
    buffer2.setUsage(this.usage);
    this.attribute = bufferAttribute2;
    this.attribute.isInstancedBufferAttribute = this.instanced;
  }
  generate(builder) {
    const nodeType = this.getNodeType(builder);
    const nodeUniform = builder.getBufferAttributeFromNode(this, nodeType);
    const propertyName = builder.getPropertyName(nodeUniform);
    let output2 = null;
    if (builder.shaderStage === "vertex") {
      output2 = propertyName;
    } else {
      const nodeVarying = varying(this);
      output2 = nodeVarying.build(builder, nodeType);
    }
    return output2;
  }
  getInputType() {
    return "bufferAttribute";
  }
  setUsage(value) {
    this.usage = value;
    return this;
  }
  setInstanced(value) {
    this.instanced = value;
    return this;
  }
};
var BufferAttributeNode_default = BufferAttributeNode;
var bufferAttribute = (array, type, stride, offset) => nodeObject(new BufferAttributeNode(array, type, stride, offset));
var dynamicBufferAttribute = (array, type, stride, offset) => bufferAttribute(array, type, stride, offset).setUsage(DynamicDrawUsage);
var instancedBufferAttribute = (array, type, stride, offset) => bufferAttribute(array, type, stride, offset).setInstanced(true);
var instancedDynamicBufferAttribute = (array, type, stride, offset) => dynamicBufferAttribute(array, type, stride, offset).setInstanced(true);
addNodeElement("toAttribute", (bufferNode) => bufferAttribute(bufferNode.value));
addNodeClass(BufferAttributeNode);

// node_modules/three/examples/jsm/nodes/accessors/InstanceNode.js
var InstanceNode = class extends Node_default {
  constructor(instanceMesh) {
    super("void");
    this.instanceMesh = instanceMesh;
    this.instanceMatrixNode = null;
  }
  construct(builder) {
    let instanceMatrixNode = this.instanceMatrixNode;
    if (instanceMatrixNode === null) {
      const instanceMesh = this.instanceMesh;
      const instanceAttribute = instanceMesh.instanceMatrix;
      const buffer2 = new InstancedInterleavedBuffer(instanceAttribute.array, 16, 1);
      const bufferFn = instanceAttribute.usage === DynamicDrawUsage ? instancedDynamicBufferAttribute : instancedBufferAttribute;
      const instanceBuffers = [
        // F.Signature -> bufferAttribute( array, type, stride, offset )
        bufferFn(buffer2, "vec4", 16, 0),
        bufferFn(buffer2, "vec4", 16, 4),
        bufferFn(buffer2, "vec4", 16, 8),
        bufferFn(buffer2, "vec4", 16, 12)
      ];
      instanceMatrixNode = mat4(...instanceBuffers);
      this.instanceMatrixNode = instanceMatrixNode;
    }
    const instancePosition = instanceMatrixNode.mul(positionLocal).xyz;
    const m = mat3(instanceMatrixNode[0].xyz, instanceMatrixNode[1].xyz, instanceMatrixNode[2].xyz);
    const transformedNormal = normalLocal.div(vec3(m[0].dot(m[0]), m[1].dot(m[1]), m[2].dot(m[2])));
    const instanceNormal = m.mul(transformedNormal).xyz;
    builder.stack.assign(positionLocal, instancePosition);
    builder.stack.assign(normalLocal, instanceNormal);
  }
};
var InstanceNode_default = InstanceNode;
var instance = nodeProxy(InstanceNode);
addNodeClass(InstanceNode);

// node_modules/three/examples/jsm/nodes/accessors/BufferNode.js
var BufferNode = class extends UniformNode_default {
  constructor(value, bufferType, bufferCount = 0) {
    super(value, bufferType);
    this.isBufferNode = true;
    this.bufferType = bufferType;
    this.bufferCount = bufferCount;
  }
  getInputType() {
    return "buffer";
  }
};
var BufferNode_default = BufferNode;
var buffer = (value, type, count) => nodeObject(new BufferNode(value, type, count));
addNodeClass(BufferNode);

// node_modules/three/examples/jsm/nodes/accessors/SkinningNode.js
var SkinningNode = class extends Node_default {
  constructor(skinnedMesh) {
    super("void");
    this.skinnedMesh = skinnedMesh;
    this.updateType = NodeUpdateType.OBJECT;
    this.skinIndexNode = attribute("skinIndex", "uvec4");
    this.skinWeightNode = attribute("skinWeight", "vec4");
    this.bindMatrixNode = uniform(skinnedMesh.bindMatrix, "mat4");
    this.bindMatrixInverseNode = uniform(skinnedMesh.bindMatrixInverse, "mat4");
    this.boneMatricesNode = buffer(skinnedMesh.skeleton.boneMatrices, "mat4", skinnedMesh.skeleton.bones.length);
  }
  construct(builder) {
    const { skinIndexNode, skinWeightNode, bindMatrixNode, bindMatrixInverseNode, boneMatricesNode } = this;
    const boneMatX = boneMatricesNode.element(skinIndexNode.x);
    const boneMatY = boneMatricesNode.element(skinIndexNode.y);
    const boneMatZ = boneMatricesNode.element(skinIndexNode.z);
    const boneMatW = boneMatricesNode.element(skinIndexNode.w);
    const skinVertex = bindMatrixNode.mul(positionLocal);
    const skinned = add(
      boneMatX.mul(skinWeightNode.x).mul(skinVertex),
      boneMatY.mul(skinWeightNode.y).mul(skinVertex),
      boneMatZ.mul(skinWeightNode.z).mul(skinVertex),
      boneMatW.mul(skinWeightNode.w).mul(skinVertex)
    );
    const skinPosition = bindMatrixInverseNode.mul(skinned).xyz;
    let skinMatrix = add(
      skinWeightNode.x.mul(boneMatX),
      skinWeightNode.y.mul(boneMatY),
      skinWeightNode.z.mul(boneMatZ),
      skinWeightNode.w.mul(boneMatW)
    );
    skinMatrix = bindMatrixInverseNode.mul(skinMatrix).mul(bindMatrixNode);
    const skinNormal = skinMatrix.transformDirection(normalLocal).xyz;
    builder.stack.assign(positionLocal, skinPosition);
    builder.stack.assign(normalLocal, skinNormal);
    if (builder.hasGeometryAttribute("tangent")) {
      builder.stack.assign(tangentLocal, skinNormal);
    }
  }
  update() {
    this.skinnedMesh.skeleton.update();
  }
};
var SkinningNode_default = SkinningNode;
var skinning = nodeProxy(SkinningNode);
addNodeClass(SkinningNode);

// node_modules/three/examples/jsm/nodes/accessors/MorphNode.js
var MorphNode = class extends Node_default {
  constructor(mesh) {
    super("void");
    this.mesh = mesh;
    this.morphBaseInfluence = uniform(1);
    this.updateType = NodeUpdateType.OBJECT;
  }
  constructAttribute(builder, name, assignNode = positionLocal) {
    const mesh = this.mesh;
    const attributes = mesh.geometry.morphAttributes[name];
    builder.stack.assign(assignNode, assignNode.mul(this.morphBaseInfluence));
    for (let i = 0; i < attributes.length; i++) {
      const attribute2 = attributes[i];
      const bufferAttrib = bufferAttribute(attribute2.array, "vec3");
      const influence = reference(i, "float", mesh.morphTargetInfluences);
      builder.stack.assign(assignNode, assignNode.add(bufferAttrib.mul(influence)));
    }
  }
  construct(builder) {
    this.constructAttribute(builder, "position");
  }
  update() {
    const morphBaseInfluence = this.morphBaseInfluence;
    if (this.mesh.geometry.morphTargetsRelative) {
      morphBaseInfluence.value = 1;
    } else {
      morphBaseInfluence.value = 1 - this.mesh.morphTargetInfluences.reduce((a, b) => a + b, 0);
    }
  }
};
var MorphNode_default = MorphNode;
var morph = nodeProxy(MorphNode);
addNodeClass(MorphNode);

// node_modules/three/examples/jsm/nodes/accessors/ReflectVectorNode.js
var ReflectVectorNode = class extends Node_default {
  constructor() {
    super("vec3");
  }
  getHash() {
    return "reflectVector";
  }
  construct() {
    const reflectView = positionViewDirection.negate().reflect(transformedNormalView);
    return reflectView.transformDirection(cameraViewMatrix);
  }
};
var ReflectVectorNode_default = ReflectVectorNode;
var reflectVector = nodeImmutable(ReflectVectorNode);
addNodeClass(ReflectVectorNode);

// node_modules/three/examples/jsm/nodes/accessors/CubeTextureNode.js
var CubeTextureNode = class extends TextureNode_default {
  constructor(value, uvNode = null, levelNode = null) {
    super(value, uvNode, levelNode);
    this.isCubeTextureNode = true;
  }
  getInputType() {
    return "cubeTexture";
  }
  getDefaultUV() {
    return reflectVector;
  }
  setUpdateMatrix() {
  }
  // Ignore .updateMatrix for CubeTextureNode
  generate(builder, output2) {
    const { uvNode, levelNode } = builder.getNodeProperties(this);
    const texture2 = this.value;
    if (!texture2 || texture2.isCubeTexture !== true) {
      throw new Error("CubeTextureNode: Need a three.js cube texture.");
    }
    const textureProperty = UniformNode_default.prototype.generate.call(this, builder, "cubeTexture");
    if (output2 === "sampler") {
      return textureProperty + "_sampler";
    } else if (builder.isReference(output2)) {
      return textureProperty;
    } else {
      const nodeType = this.getNodeType(builder);
      const nodeData = builder.getDataFromNode(this);
      let propertyName = nodeData.propertyName;
      if (propertyName === void 0) {
        const cubeUV = vec3(uvNode.x.negate(), uvNode.yz);
        const uvSnippet = cubeUV.build(builder, "vec3");
        const nodeVar = builder.getVarFromNode(this, "vec4");
        propertyName = builder.getPropertyName(nodeVar);
        let snippet2 = null;
        if (levelNode && levelNode.isNode === true) {
          const levelSnippet = levelNode.build(builder, "float");
          snippet2 = builder.getTextureLevel(this, textureProperty, uvSnippet, levelSnippet);
        } else {
          snippet2 = builder.getTexture(this, textureProperty, uvSnippet);
        }
        builder.addLineFlowCode(`${propertyName} = ${snippet2}`);
        if (builder.context.tempWrite !== false) {
          nodeData.snippet = snippet2;
          nodeData.propertyName = propertyName;
        }
      }
      let snippet = propertyName;
      if (builder.needsColorSpaceToLinear(this.value)) {
        snippet = colorSpaceToLinear(expression(snippet, nodeType), this.value.colorSpace).construct(builder).build(builder, nodeType);
      }
      return builder.format(snippet, "vec4", output2);
    }
  }
};
var CubeTextureNode_default = CubeTextureNode;
var cubeTexture = nodeProxy(CubeTextureNode);
addNodeElement("cubeTexture", cubeTexture);
addNodeClass(CubeTextureNode);

// node_modules/three/examples/jsm/nodes/lighting/LightingNode.js
var LightingNode = class extends Node_default {
  constructor() {
    super("vec3");
  }
  generate() {
    console.warn("Abstract function.");
  }
};
var LightingNode_default = LightingNode;
addNodeClass(LightingNode);

// node_modules/three/examples/jsm/nodes/lighting/AnalyticLightNode.js
var depthMaterial = null;
var AnalyticLightNode = class extends LightingNode_default {
  constructor(light = null) {
    super();
    this.updateType = NodeUpdateType.FRAME;
    this.light = light;
    this.rtt = null;
    this.shadowNode = null;
    this.color = new Color();
    this.colorNode = uniform(this.color);
  }
  getHash() {
    return this.light.uuid;
  }
  constructShadow(builder) {
    let shadowNode = this.shadowNode;
    if (shadowNode === null) {
      if (depthMaterial === null)
        depthMaterial = builder.createNodeMaterial("MeshBasicNodeMaterial");
      const shadow = this.light.shadow;
      const rtt = builder.getRenderTarget(shadow.mapSize.width, shadow.mapSize.height);
      const depthTexture2 = new DepthTexture();
      depthTexture2.minFilter = NearestFilter;
      depthTexture2.magFilter = NearestFilter;
      depthTexture2.image.width = shadow.mapSize.width;
      depthTexture2.image.height = shadow.mapSize.height;
      depthTexture2.compareFunction = LessCompare;
      rtt.depthTexture = depthTexture2;
      shadow.camera.updateProjectionMatrix();
      const bias = reference("bias", "float", shadow);
      const normalBias = reference("normalBias", "float", shadow);
      let shadowCoord = uniform(shadow.matrix).mul(positionWorld.add(normalWorld.mul(normalBias)));
      shadowCoord = shadowCoord.xyz.div(shadowCoord.w);
      const frustumTest = shadowCoord.x.greaterThanEqual(0).and(shadowCoord.x.lessThanEqual(1)).and(shadowCoord.y.greaterThanEqual(0)).and(shadowCoord.y.lessThanEqual(1)).and(shadowCoord.z.lessThanEqual(1));
      shadowCoord = vec3(
        shadowCoord.x,
        shadowCoord.y.oneMinus(),
        // WebGPU: Flip Y
        shadowCoord.z.add(bias).mul(2).sub(1)
        // WebGPU: Convertion [ 0, 1 ] to [ - 1, 1 ]
      );
      const textureCompare = (depthTexture3, shadowCoord2, compare) => texture(depthTexture3, shadowCoord2).compare(compare);
      shadowNode = textureCompare(depthTexture2, shadowCoord.xy, shadowCoord.z);
      this.rtt = rtt;
      this.colorNode = this.colorNode.mul(frustumTest.mix(1, shadowNode));
      this.shadowNode = shadowNode;
      this.updateBeforeType = NodeUpdateType.RENDER;
    }
  }
  construct(builder) {
    if (this.light.castShadow)
      this.constructShadow(builder);
  }
  updateShadow(frame) {
    const { rtt, light } = this;
    const { renderer, scene } = frame;
    scene.overrideMaterial = depthMaterial;
    rtt.setSize(light.shadow.mapSize.width, light.shadow.mapSize.height);
    light.shadow.updateMatrices(light);
    renderer.setRenderTarget(rtt);
    renderer.render(scene, light.shadow.camera);
    renderer.setRenderTarget(null);
    scene.overrideMaterial = null;
  }
  updateBefore(frame) {
    const { light } = this;
    if (light.castShadow)
      this.updateShadow(frame);
  }
  update() {
    const { light } = this;
    this.color.copy(light.color).multiplyScalar(light.intensity);
  }
};
var AnalyticLightNode_default = AnalyticLightNode;
addNodeClass(AnalyticLightNode);

// node_modules/three/examples/jsm/nodes/lighting/LightsNode.js
var LightNodes = /* @__PURE__ */ new WeakMap();
var sortLights = (lights2) => {
  return lights2.sort((a, b) => a.id - b.id);
};
var LightsNode = class extends Node_default {
  constructor(lightNodes = []) {
    super("vec3");
    this.lightNodes = lightNodes;
    this._hash = null;
  }
  get hasLight() {
    return this.lightNodes.length > 0;
  }
  construct(builder) {
    const lightNodes = this.lightNodes;
    for (const lightNode of lightNodes) {
      lightNode.build(builder);
    }
  }
  getHash(builder) {
    if (this._hash === null) {
      let hash2 = "";
      const lightNodes = this.lightNodes;
      for (const lightNode of lightNodes) {
        hash2 += lightNode.getHash(builder) + " ";
      }
      this._hash = hash2;
    }
    return this._hash;
  }
  getLightNodeByHash(hash2) {
    const lightNodes = this.lightNodes;
    for (const lightNode of lightNodes) {
      if (lightNode.light.uuid === hash2) {
        return lightNode;
      }
    }
    return null;
  }
  fromLights(lights2 = []) {
    const lightNodes = [];
    lights2 = sortLights(lights2);
    for (const light of lights2) {
      let lightNode = this.getLightNodeByHash(light.uuid);
      if (lightNode === null) {
        const lightClass = light.constructor;
        const lightNodeClass = LightNodes.has(lightClass) ? LightNodes.get(lightClass) : AnalyticLightNode_default;
        lightNode = nodeObject(new lightNodeClass(light));
      }
      lightNodes.push(lightNode);
    }
    this.lightNodes = lightNodes;
    this._hash = null;
    return this;
  }
};
var LightsNode_default = LightsNode;
var lights = (lights2) => nodeObject(new LightsNode().fromLights(lights2));
var lightsWithoutWrap = nodeProxy(LightsNode);
function addLightNode(lightClass, lightNodeClass) {
  if (LightNodes.has(lightClass))
    throw new Error(`Redefinition of light node ${lightNodeClass.name}`);
  if (typeof lightClass !== "function" || !lightClass.name)
    throw new Error(`Light ${lightClass.name} is not a class`);
  if (typeof lightNodeClass !== "function" || !lightNodeClass.name)
    throw new Error(`Light node ${lightNodeClass.name} is not a class`);
  LightNodes.set(lightClass, lightNodeClass);
}

// node_modules/three/examples/jsm/nodes/lighting/AONode.js
var AONode = class extends LightingNode_default {
  constructor(aoNode = null) {
    super();
    this.aoNode = aoNode;
  }
  construct(builder) {
    const aoIntensity = 1;
    const aoNode = this.aoNode.x.sub(1).mul(aoIntensity).add(1);
    builder.context.ambientOcclusion.mulAssign(aoNode);
  }
};
var AONode_default = AONode;
addNodeClass(AONode);

// node_modules/three/examples/jsm/nodes/lighting/LightingContextNode.js
var LightingContextNode = class extends ContextNode_default {
  constructor(node, lightingModel = null, backdropNode = null, backdropAlphaNode = null) {
    super(node);
    this.lightingModel = lightingModel;
    this.backdropNode = backdropNode;
    this.backdropAlphaNode = backdropAlphaNode;
  }
  getNodeType() {
    return "vec3";
  }
  construct(builder) {
    const { lightingModel, backdropNode, backdropAlphaNode } = this;
    const context2 = this.context = {};
    const properties = builder.getNodeProperties(this);
    const directDiffuse = vec3().temp(), directSpecular = vec3().temp(), indirectDiffuse = vec3().temp(), indirectSpecular = vec3().temp();
    let totalDiffuse = add(directDiffuse, indirectDiffuse);
    if (backdropNode !== null) {
      totalDiffuse = vec3(backdropAlphaNode !== null ? mix(totalDiffuse, backdropNode, backdropAlphaNode) : backdropNode);
    }
    const totalSpecular = add(directSpecular, indirectSpecular);
    const total = add(totalDiffuse, totalSpecular).temp();
    const reflectedLight = {
      directDiffuse,
      directSpecular,
      indirectDiffuse,
      indirectSpecular,
      total
    };
    const lighting = {
      radiance: vec3().temp(),
      irradiance: vec3().temp(),
      iblIrradiance: vec3().temp(),
      ambientOcclusion: float(1).temp()
    };
    context2.reflectedLight = reflectedLight;
    context2.lightingModel = lightingModel || context2.lightingModel;
    Object.assign(properties, reflectedLight, lighting);
    Object.assign(context2, lighting);
    if (lightingModel) {
      lightingModel.init(context2, builder.stack, builder);
      lightingModel.indirectDiffuse(context2, builder.stack, builder);
      lightingModel.indirectSpecular(context2, builder.stack, builder);
      lightingModel.ambientOcclusion(context2, builder.stack, builder);
    }
    return super.construct(builder);
  }
  generate(builder) {
    const { context: context2 } = this;
    const type = this.getNodeType(builder);
    super.generate(builder, type);
    return context2.reflectedLight.total.build(builder, type);
  }
};
var LightingContextNode_default = LightingContextNode;
var lightingContext = nodeProxy(LightingContextNode);
addNodeElement("lightingContext", lightingContext);
addNodeClass(LightingContextNode);

// node_modules/three/examples/jsm/nodes/utils/EquirectUVNode.js
var EquirectUVNode = class extends TempNode_default {
  constructor(dirNode = positionWorldDirection) {
    super("vec2");
    this.dirNode = dirNode;
  }
  construct() {
    const dir = this.dirNode;
    const u = dir.z.atan2(dir.x).mul(1 / (Math.PI * 2)).add(0.5);
    const v = dir.y.negate().clamp(-1, 1).asin().mul(1 / Math.PI).add(0.5);
    return vec2(u, v);
  }
};
var EquirectUVNode_default = EquirectUVNode;
var equirectUV = nodeProxy(EquirectUVNode);
addNodeClass(EquirectUVNode);

// node_modules/three/examples/jsm/nodes/utils/MaxMipLevelNode.js
var MaxMipLevelNode = class extends UniformNode_default {
  constructor(textureNode) {
    super(0);
    this.textureNode = textureNode;
    this.updateType = NodeUpdateType.FRAME;
  }
  get texture() {
    return this.textureNode.value;
  }
  update() {
    const texture2 = this.texture;
    const images = texture2.images;
    const image = images && images.length > 0 ? images[0] && images[0].image || images[0] : texture2.image;
    if (image && image.width !== void 0) {
      const { width, height } = image;
      this.value = Math.log2(Math.max(width, height));
    }
  }
};
var MaxMipLevelNode_default = MaxMipLevelNode;
var maxMipLevel = nodeProxy(MaxMipLevelNode);
addNodeClass(MaxMipLevelNode);

// node_modules/three/examples/jsm/nodes/utils/SpecularMIPLevelNode.js
var SpecularMIPLevelNode = class extends Node_default {
  constructor(textureNode, roughnessNode = null) {
    super("float");
    this.textureNode = textureNode;
    this.roughnessNode = roughnessNode;
  }
  construct() {
    const { textureNode, roughnessNode } = this;
    const maxMIPLevelScalar = maxMipLevel(textureNode);
    const sigma = roughnessNode.mul(roughnessNode).mul(Math.PI).div(roughnessNode.add(1));
    const desiredMIPLevel = maxMIPLevelScalar.add(sigma.log2());
    return desiredMIPLevel.clamp(0, maxMIPLevelScalar);
  }
};
var SpecularMIPLevelNode_default = SpecularMIPLevelNode;
var specularMIPLevel = nodeProxy(SpecularMIPLevelNode);
addNodeClass(SpecularMIPLevelNode);

// node_modules/three/examples/jsm/nodes/lighting/EnvironmentNode.js
var envNodeCache = /* @__PURE__ */ new WeakMap();
var EnvironmentNode = class extends LightingNode_default {
  constructor(envNode = null) {
    super();
    this.envNode = envNode;
  }
  construct(builder) {
    let envNode = this.envNode;
    const properties = builder.getNodeProperties(this);
    if (envNode.isTextureNode && envNode.value.isCubeTexture !== true) {
      let cacheEnvNode = envNodeCache.get(envNode.value);
      if (cacheEnvNode === void 0) {
        const texture2 = envNode.value;
        const renderer = builder.renderer;
        const cubeRTT = builder.getCubeRenderTarget(512).fromEquirectangularTexture(renderer, texture2);
        cacheEnvNode = cubeTexture(cubeRTT.texture);
        envNodeCache.set(envNode.value, cacheEnvNode);
      }
      envNode = cacheEnvNode;
    }
    const intensity = reference("envMapIntensity", "float", builder.material);
    const radiance = context(envNode, createRadianceContext(roughness, transformedNormalView)).mul(intensity);
    const irradiance = context(envNode, createIrradianceContext(transformedNormalWorld)).mul(Math.PI).mul(intensity);
    const isolateRadiance = cache(radiance);
    builder.context.radiance.addAssign(isolateRadiance);
    builder.context.iblIrradiance.addAssign(irradiance);
    const clearcoatRadiance = builder.context.lightingModel.clearcoatRadiance;
    if (clearcoatRadiance) {
      const clearcoatRadianceContext = context(envNode, createRadianceContext(clearcoatRoughness, transformedClearcoatNormalView)).mul(intensity);
      const isolateClearcoatRadiance = cache(clearcoatRadianceContext);
      clearcoatRadiance.addAssign(isolateClearcoatRadiance);
    }
    properties.radiance = isolateRadiance;
    properties.irradiance = irradiance;
  }
};
var createRadianceContext = (roughnessNode, normalViewNode) => {
  let reflectVec = null;
  let textureUVNode = null;
  return {
    getUVNode: (textureNode) => {
      let node = null;
      if (reflectVec === null) {
        reflectVec = positionViewDirection.negate().reflect(normalViewNode);
        reflectVec = roughnessNode.mul(roughnessNode).mix(reflectVec, normalViewNode).normalize();
        reflectVec = reflectVec.transformDirection(cameraViewMatrix);
      }
      if (textureNode.isCubeTextureNode) {
        node = reflectVec;
      } else if (textureNode.isTextureNode) {
        if (textureUVNode === null) {
          textureUVNode = equirectUV(reflectVec);
        }
        node = textureUVNode;
      }
      return node;
    },
    getSamplerLevelNode: () => {
      return roughnessNode;
    },
    getMIPLevelAlgorithmNode: (textureNode, levelNode) => {
      return specularMIPLevel(textureNode, levelNode);
    }
  };
};
var createIrradianceContext = (normalWorldNode) => {
  let textureUVNode = null;
  return {
    getUVNode: (textureNode) => {
      let node = null;
      if (textureNode.isCubeTextureNode) {
        node = normalWorldNode;
      } else if (textureNode.isTextureNode) {
        if (textureUVNode === null) {
          textureUVNode = equirectUV(normalWorldNode);
          textureUVNode = vec2(textureUVNode.x, textureUVNode.y.oneMinus());
        }
        node = textureUVNode;
      }
      return node;
    },
    getSamplerLevelNode: () => {
      return float(1);
    },
    getMIPLevelAlgorithmNode: (textureNode, levelNode) => {
      return specularMIPLevel(textureNode, levelNode);
    }
  };
};
var EnvironmentNode_default = EnvironmentNode;
addNodeClass(EnvironmentNode);

// node_modules/three/examples/jsm/nodes/materials/NodeMaterial.js
var NodeMaterials = /* @__PURE__ */ new Map();
var NodeMaterial = class _NodeMaterial extends ShaderMaterial {
  constructor() {
    super();
    this.isNodeMaterial = true;
    this.type = this.constructor.name;
    this.forceSinglePass = false;
    this.unlit = this.constructor === _NodeMaterial.prototype.constructor;
    this.fog = true;
    this.lights = true;
    this.normals = true;
    this.colorSpace = true;
    this.lightsNode = null;
    this.envNode = null;
    this.colorNode = null;
    this.normalNode = null;
    this.opacityNode = null;
    this.backdropNode = null;
    this.backdropAlphaNode = null;
    this.alphaTestNode = null;
    this.positionNode = null;
    this.outputNode = null;
    this.vertexNode = null;
  }
  customProgramCacheKey() {
    return this.type + getCacheKey(this);
  }
  build(builder) {
    this.construct(builder);
  }
  construct(builder) {
    builder.addStack();
    builder.stack.outputNode = this.constructPosition(builder);
    builder.addFlow("vertex", builder.removeStack());
    builder.addStack();
    let outputNode;
    if (this.unlit === false) {
      if (this.normals === true)
        this.constructNormal(builder);
      this.constructDiffuseColor(builder);
      this.constructVariants(builder);
      const outgoingLightNode = this.constructLighting(builder);
      outputNode = this.constructOutput(builder, vec4(outgoingLightNode, diffuseColor.a));
      builder.stack.assign(output, outputNode);
      if (this.outputNode !== null)
        outputNode = this.outputNode;
    } else {
      outputNode = this.constructOutput(builder, this.outputNode || vec4(0, 0, 0, 1));
    }
    builder.stack.outputNode = outputNode;
    builder.addFlow("fragment", builder.removeStack());
  }
  constructPosition(builder) {
    const object = builder.object;
    const geometry = object.geometry;
    builder.addStack();
    if (geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color) {
      builder.stack.add(morph(object));
    }
    if (object.isSkinnedMesh === true) {
      builder.stack.add(skinning(object));
    }
    if (object.instanceMatrix && object.instanceMatrix.isInstancedBufferAttribute === true && builder.isAvailable("instance") === true) {
      builder.stack.add(instance(object));
    }
    if (this.positionNode !== null) {
      builder.stack.assign(positionLocal, this.positionNode);
    }
    builder.context.vertex = builder.removeStack();
    return this.vertexNode || modelViewProjection();
  }
  constructDiffuseColor({ stack: stack2, geometry }) {
    let colorNode = this.colorNode ? vec4(this.colorNode) : materialColor;
    if (this.vertexColors === true && geometry.hasAttribute("color")) {
      colorNode = vec4(colorNode.xyz.mul(attribute("color")), colorNode.a);
    }
    stack2.assign(diffuseColor, colorNode);
    const opacityNode = this.opacityNode ? float(this.opacityNode) : materialOpacity;
    stack2.assign(diffuseColor.a, diffuseColor.a.mul(opacityNode));
    if (this.alphaTestNode !== null || this.alphaTest > 0) {
      const alphaTestNode = this.alphaTestNode !== null ? float(this.alphaTestNode) : materialAlphaTest;
      stack2.add(diffuseColor.a.lessThanEqual(alphaTestNode).discard());
    }
  }
  constructVariants() {
  }
  constructNormal({ stack: stack2 }) {
    if (this.flatShading === true) {
      const fdx = dFdx(positionView);
      const fdy = dFdy(positionView.negate());
      const normalNode = fdx.cross(fdy).normalize();
      stack2.assign(transformedNormalView, normalNode);
    } else {
      const normalNode = this.normalNode ? vec3(this.normalNode) : materialNormal;
      stack2.assign(transformedNormalView, normalNode);
    }
  }
  getEnvNode(builder) {
    let node = null;
    if (this.envNode) {
      node = this.envNode;
    } else if (this.envMap) {
      node = this.envMap.isCubeTexture ? cubeTexture(this.envMap) : texture(this.envMap);
    } else if (builder.environmentNode) {
      node = builder.environmentNode;
    }
    return node;
  }
  constructLights(builder) {
    const envNode = this.getEnvNode(builder);
    const materialLightsNode = [];
    if (envNode) {
      materialLightsNode.push(new EnvironmentNode_default(envNode));
    }
    if (builder.material.aoMap) {
      materialLightsNode.push(new AONode_default(texture(builder.material.aoMap)));
    }
    let lightsNode = this.lightsNode || builder.lightsNode;
    if (materialLightsNode.length > 0) {
      lightsNode = lightsWithoutWrap([...lightsNode.lightNodes, ...materialLightsNode]);
    }
    return lightsNode;
  }
  constructLightingModel() {
  }
  constructLighting(builder) {
    const { material } = builder;
    const { backdropNode, backdropAlphaNode, emissiveNode } = this;
    const lights2 = this.lights === true || this.lightsNode !== null;
    const lightsNode = lights2 ? this.constructLights(builder) : null;
    let outgoingLightNode = diffuseColor.rgb;
    if (lightsNode && lightsNode.hasLight !== false) {
      const lightingModelNode = this.constructLightingModel(builder);
      outgoingLightNode = lightingContext(lightsNode, lightingModelNode, backdropNode, backdropAlphaNode);
    } else if (backdropNode !== null) {
      outgoingLightNode = vec3(backdropAlphaNode !== null ? mix(outgoingLightNode, backdropNode, backdropAlphaNode) : backdropNode);
    }
    if (emissiveNode && emissiveNode.isNode === true || material.emissive && material.emissive.isColor === true) {
      outgoingLightNode = outgoingLightNode.add(vec3(emissiveNode ? emissiveNode : materialEmissive));
    }
    return outgoingLightNode;
  }
  constructOutput(builder, outputNode) {
    const renderer = builder.renderer;
    const toneMappingNode = builder.toneMappingNode;
    if (toneMappingNode) {
      outputNode = vec4(toneMappingNode.context({ color: outputNode.rgb }), outputNode.a);
    }
    if (this.fog === true) {
      const fogNode = builder.fogNode;
      if (fogNode)
        outputNode = vec4(fogNode.mixAssign(outputNode.rgb), outputNode.a);
    }
    if (this.colorSpace === true) {
      const renderTarget = renderer.getRenderTarget();
      let outputColorSpace;
      if (renderTarget !== null) {
        if (Array.isArray(renderTarget.texture)) {
          outputColorSpace = renderTarget.texture[0].colorSpace;
        } else {
          outputColorSpace = renderTarget.texture.colorSpace;
        }
      } else {
        outputColorSpace = renderer.outputColorSpace;
      }
      if (outputColorSpace !== LinearSRGBColorSpace && outputColorSpace !== NoColorSpace) {
        outputNode = outputNode.linearToColorSpace(outputColorSpace);
      }
    }
    return outputNode;
  }
  setDefaultValues(material) {
    for (const property2 in material) {
      const value = material[property2];
      if (this[property2] === void 0) {
        this[property2] = value;
        if (value && value.clone)
          this[property2] = value.clone();
      }
    }
    Object.assign(this.defines, material.defines);
    const descriptors = Object.getOwnPropertyDescriptors(material.constructor.prototype);
    for (const key in descriptors) {
      if (Object.getOwnPropertyDescriptor(this.constructor.prototype, key) === void 0 && descriptors[key].get !== void 0) {
        Object.defineProperty(this.constructor.prototype, key, descriptors[key]);
      }
    }
  }
  toJSON(meta) {
    const isRoot = meta === void 0 || typeof meta === "string";
    if (isRoot) {
      meta = {
        textures: {},
        images: {},
        nodes: {}
      };
    }
    const data = Material.prototype.toJSON.call(this, meta);
    const nodeChildren = getNodeChildren(this);
    data.inputNodes = {};
    for (const { property: property2, childNode } of nodeChildren) {
      data.inputNodes[property2] = childNode.toJSON(meta).uuid;
    }
    function extractFromCache(cache3) {
      const values = [];
      for (const key in cache3) {
        const data2 = cache3[key];
        delete data2.metadata;
        values.push(data2);
      }
      return values;
    }
    if (isRoot) {
      const textures = extractFromCache(meta.textures);
      const images = extractFromCache(meta.images);
      const nodes = extractFromCache(meta.nodes);
      if (textures.length > 0)
        data.textures = textures;
      if (images.length > 0)
        data.images = images;
      if (nodes.length > 0)
        data.nodes = nodes;
    }
    return data;
  }
  copy(source) {
    this.lightsNode = source.lightsNode;
    this.envNode = source.envNode;
    this.colorNode = source.colorNode;
    this.normalNode = source.normalNode;
    this.opacityNode = source.opacityNode;
    this.backdropNode = source.backdropNode;
    this.backdropAlphaNode = source.backdropAlphaNode;
    this.alphaTestNode = source.alphaTestNode;
    this.positionNode = source.positionNode;
    this.outputNode = source.outputNode;
    this.vertexNode = source.vertexNode;
    return super.copy(source);
  }
  static fromMaterial(material) {
    if (material.isNodeMaterial === true) {
      return material;
    }
    const type = material.type.replace("Material", "NodeMaterial");
    const nodeMaterial = createNodeMaterialFromType(type);
    if (nodeMaterial === void 0) {
      throw new Error(`NodeMaterial: Material "${material.type}" is not compatible.`);
    }
    for (const key in material) {
      nodeMaterial[key] = material[key];
    }
    return nodeMaterial;
  }
};
var NodeMaterial_default = NodeMaterial;
function addNodeMaterial(nodeMaterial) {
  if (typeof nodeMaterial !== "function" || !nodeMaterial.name)
    throw new Error(`Node material ${nodeMaterial.name} is not a class`);
  if (NodeMaterials.has(nodeMaterial.name))
    throw new Error(`Redefinition of node material ${nodeMaterial.name}`);
  NodeMaterials.set(nodeMaterial.name, nodeMaterial);
}
function createNodeMaterialFromType(type) {
  const Material2 = NodeMaterials.get(type);
  if (Material2 !== void 0) {
    return new Material2();
  }
}
addNodeMaterial(NodeMaterial);

// node_modules/three/examples/jsm/renderers/common/Uniform.js
var Uniform = class {
  constructor(name, value = null) {
    this.name = name;
    this.value = value;
    this.boundary = 0;
    this.itemSize = 0;
    this.offset = 0;
  }
  setValue(value) {
    this.value = value;
  }
  getValue() {
    return this.value;
  }
};
var FloatUniform = class extends Uniform {
  constructor(name, value = 0) {
    super(name, value);
    this.isFloatUniform = true;
    this.boundary = 4;
    this.itemSize = 1;
  }
};
var Vector2Uniform = class extends Uniform {
  constructor(name, value = new Vector2()) {
    super(name, value);
    this.isVector2Uniform = true;
    this.boundary = 8;
    this.itemSize = 2;
  }
};
var Vector3Uniform = class extends Uniform {
  constructor(name, value = new Vector3()) {
    super(name, value);
    this.isVector3Uniform = true;
    this.boundary = 16;
    this.itemSize = 3;
  }
};
var Vector4Uniform = class extends Uniform {
  constructor(name, value = new Vector4()) {
    super(name, value);
    this.isVector4Uniform = true;
    this.boundary = 16;
    this.itemSize = 4;
  }
};
var ColorUniform = class extends Uniform {
  constructor(name, value = new Color()) {
    super(name, value);
    this.isColorUniform = true;
    this.boundary = 16;
    this.itemSize = 3;
  }
};
var Matrix3Uniform = class extends Uniform {
  constructor(name, value = new Matrix3()) {
    super(name, value);
    this.isMatrix3Uniform = true;
    this.boundary = 48;
    this.itemSize = 12;
  }
};
var Matrix4Uniform = class extends Uniform {
  constructor(name, value = new Matrix4()) {
    super(name, value);
    this.isMatrix4Uniform = true;
    this.boundary = 64;
    this.itemSize = 16;
  }
};

// node_modules/three/examples/jsm/renderers/common/nodes/NodeUniform.js
var FloatNodeUniform = class extends FloatUniform {
  constructor(nodeUniform) {
    super(nodeUniform.name, nodeUniform.value);
    this.nodeUniform = nodeUniform;
  }
  getValue() {
    return this.nodeUniform.value;
  }
};
var Vector2NodeUniform = class extends Vector2Uniform {
  constructor(nodeUniform) {
    super(nodeUniform.name, nodeUniform.value);
    this.nodeUniform = nodeUniform;
  }
  getValue() {
    return this.nodeUniform.value;
  }
};
var Vector3NodeUniform = class extends Vector3Uniform {
  constructor(nodeUniform) {
    super(nodeUniform.name, nodeUniform.value);
    this.nodeUniform = nodeUniform;
  }
  getValue() {
    return this.nodeUniform.value;
  }
};
var Vector4NodeUniform = class extends Vector4Uniform {
  constructor(nodeUniform) {
    super(nodeUniform.name, nodeUniform.value);
    this.nodeUniform = nodeUniform;
  }
  getValue() {
    return this.nodeUniform.value;
  }
};
var ColorNodeUniform = class extends ColorUniform {
  constructor(nodeUniform) {
    super(nodeUniform.name, nodeUniform.value);
    this.nodeUniform = nodeUniform;
  }
  getValue() {
    return this.nodeUniform.value;
  }
};
var Matrix3NodeUniform = class extends Matrix3Uniform {
  constructor(nodeUniform) {
    super(nodeUniform.name, nodeUniform.value);
    this.nodeUniform = nodeUniform;
  }
  getValue() {
    return this.nodeUniform.value;
  }
};
var Matrix4NodeUniform = class extends Matrix4Uniform {
  constructor(nodeUniform) {
    super(nodeUniform.name, nodeUniform.value);
    this.nodeUniform = nodeUniform;
  }
  getValue() {
    return this.nodeUniform.value;
  }
};

// node_modules/three/examples/jsm/nodes/math/CondNode.js
var CondNode = class extends Node_default {
  constructor(condNode, ifNode, elseNode = null) {
    super();
    this.condNode = condNode;
    this.ifNode = ifNode;
    this.elseNode = elseNode;
  }
  getNodeType(builder) {
    const ifType = this.ifNode.getNodeType(builder);
    if (this.elseNode !== null) {
      const elseType = this.elseNode.getNodeType(builder);
      if (builder.getTypeLength(elseType) > builder.getTypeLength(ifType)) {
        return elseType;
      }
    }
    return ifType;
  }
  generate(builder) {
    const type = this.getNodeType(builder);
    const context2 = { tempWrite: false };
    const { ifNode, elseNode } = this;
    const needsProperty = ifNode.getNodeType(builder) !== "void" || elseNode && elseNode.getNodeType(builder) !== "void";
    const nodeProperty = needsProperty ? property(type).build(builder) : "";
    const nodeSnippet = context(
      this.condNode
      /*, context*/
    ).build(builder, "bool");
    builder.addFlowCode(`
${builder.tab}if ( ${nodeSnippet} ) {

`).addFlowTab();
    let ifSnippet = context(this.ifNode, context2).build(builder, type);
    ifSnippet = needsProperty ? nodeProperty + " = " + ifSnippet + ";" : ifSnippet;
    builder.removeFlowTab().addFlowCode(builder.tab + "	" + ifSnippet + "\n\n" + builder.tab + "}");
    if (elseNode !== null) {
      builder.addFlowCode(" else {\n\n").addFlowTab();
      let elseSnippet = context(elseNode, context2).build(builder, type);
      elseSnippet = nodeProperty ? nodeProperty + " = " + elseSnippet + ";" : elseSnippet;
      builder.removeFlowTab().addFlowCode(builder.tab + "	" + elseSnippet + "\n\n" + builder.tab + "}\n\n");
    } else {
      builder.addFlowCode("\n\n");
    }
    return nodeProperty;
  }
};
var CondNode_default = CondNode;
var cond = nodeProxy(CondNode);
addNodeElement("cond", cond);
addNodeClass(CondNode);

// node_modules/three/examples/jsm/nodes/utils/LoopNode.js
var LoopNode = class extends Node_default {
  constructor(params = []) {
    super();
    this.params = params;
  }
  getVarName(index) {
    return String.fromCharCode("i".charCodeAt() + index);
  }
  getProperties(builder) {
    const properties = builder.getNodeProperties(this);
    if (properties.stackNode !== void 0)
      return properties;
    const inputs = {};
    for (let i = 0, l = this.params.length - 1; i < l; i++) {
      const prop = this.getVarName(i);
      inputs[prop] = expression(prop, "int");
    }
    properties.returnsNode = this.params[this.params.length - 1](inputs, builder.addStack(), builder);
    properties.stackNode = builder.removeStack();
    return properties;
  }
  getNodeType(builder) {
    const { returnsNode } = this.getProperties(builder);
    return returnsNode ? returnsNode.getNodeType(builder) : "void";
  }
  construct(builder) {
    this.getProperties(builder);
  }
  generate(builder) {
    const properties = this.getProperties(builder);
    const context2 = { tempWrite: false };
    const params = this.params;
    const stackNode = properties.stackNode;
    const returnsSnippet = properties.returnsNode ? properties.returnsNode.build(builder) : "";
    for (let i = 0, l = params.length - 1; i < l; i++) {
      const param = params[i];
      const property2 = this.getVarName(i);
      let start = null, end = null, direction = null;
      if (param.isNode) {
        start = "0";
        end = param.generate(builder, "int");
        direction = "forward";
      } else {
        start = param.start;
        end = param.end;
        direction = param.direction;
        if (typeof start === "number")
          start = start.toString();
        else if (start && start.isNode)
          start = start.generate(builder, "int");
        if (typeof end === "number")
          end = end.toString();
        else if (end && end.isNode)
          end = end.generate(builder, "int");
        if (start !== void 0 && end === void 0) {
          start = start + " - 1";
          end = "0";
          direction = "backwards";
        } else if (end !== void 0 && start === void 0) {
          start = "0";
          direction = "forward";
        }
        if (direction === void 0) {
          if (Number(start) > Number(end)) {
            direction = "backwards";
          } else {
            direction = "forward";
          }
        }
      }
      const internalParam = { start, end, direction };
      const startSnippet = internalParam.start;
      const endSnippet = internalParam.end;
      let declarationSnippet = "";
      let conditionalSnippet = "";
      let updateSnippet = "";
      declarationSnippet += builder.getVar("int", property2) + " = " + startSnippet;
      if (internalParam.direction === "backwards") {
        conditionalSnippet += property2 + " >= " + endSnippet;
        updateSnippet += property2 + " --";
      } else {
        conditionalSnippet += property2 + " < " + endSnippet;
        updateSnippet += property2 + " ++";
      }
      const forSnippet = `for ( ${declarationSnippet}; ${conditionalSnippet}; ${updateSnippet} )`;
      builder.addFlowCode((i === 0 ? "\n" : "") + builder.tab + forSnippet + " {\n\n").addFlowTab();
    }
    const stackSnippet = context(stackNode, context2).build(builder, "void");
    builder.removeFlowTab().addFlowCode("\n" + builder.tab + stackSnippet);
    for (let i = 0, l = this.params.length - 1; i < l; i++) {
      builder.addFlowCode((i === 0 ? "" : builder.tab) + "}\n\n").removeFlowTab();
    }
    builder.addFlowTab();
    return returnsSnippet;
  }
};
var LoopNode_default = LoopNode;
var loop = (...params) => nodeObject(new LoopNode(nodeArray(params, "int")));
addNodeElement("loop", (returns, ...params) => bypass(returns, loop(...params)));
addNodeClass(LoopNode);

// node_modules/three/examples/jsm/nodes/core/StackNode.js
var StackNode = class extends Node_default {
  constructor(parent = null) {
    super();
    this.nodes = [];
    this.outputNode = null;
    this.parent = parent;
    this._currentCond = null;
    this.isStackNode = true;
  }
  getNodeType(builder) {
    return this.outputNode ? this.outputNode.getNodeType(builder) : "void";
  }
  add(node) {
    this.nodes.push(bypass(expression(), node));
    return this;
  }
  if(boolNode, method) {
    const methodNode = new ShaderNode(method);
    this._currentCond = cond(boolNode, methodNode);
    return this.add(this._currentCond);
  }
  elseif(boolNode, method) {
    const methodNode = new ShaderNode(method);
    const ifNode = cond(boolNode, methodNode);
    this._currentCond.elseNode = ifNode;
    this._currentCond = ifNode;
    return this;
  }
  else(method) {
    this._currentCond.elseNode = new ShaderNode(method);
    return this;
  }
  assign(targetNode, sourceValue) {
    return this.add(assign(targetNode, sourceValue));
  }
  loop(...params) {
    return this.add(loop(...params));
  }
  build(builder, ...params) {
    for (const node of this.nodes) {
      node.build(builder, "void");
    }
    return this.outputNode ? this.outputNode.build(builder, ...params) : super.build(builder, ...params);
  }
};
var StackNode_default = StackNode;
var stack = nodeProxy(StackNode);
addNodeClass(StackNode);

// node_modules/three/examples/jsm/renderers/common/CubeRenderTarget.js
var CubeRenderTarget = class extends WebGLCubeRenderTarget {
  constructor(size = 1, options = {}) {
    super(size, options);
    this.isCubeRenderTarget = true;
  }
  fromEquirectangularTexture(renderer, texture2) {
    const currentMinFilter = texture2.minFilter;
    const currentGenerateMipmaps = texture2.generateMipmaps;
    texture2.generateMipmaps = true;
    this.texture.type = texture2.type;
    this.texture.colorSpace = texture2.colorSpace;
    this.texture.generateMipmaps = texture2.generateMipmaps;
    this.texture.minFilter = texture2.minFilter;
    this.texture.magFilter = texture2.magFilter;
    const geometry = new BoxGeometry(5, 5, 5);
    const uvNode = equirectUV(positionWorldDirection);
    const material = createNodeMaterialFromType("MeshBasicNodeMaterial");
    material.colorNode = texture(texture2, uvNode, 0);
    material.side = BackSide;
    material.blending = NoBlending;
    const mesh = new Mesh(geometry, material);
    const scene = new Scene();
    scene.add(mesh);
    if (texture2.minFilter === LinearMipmapLinearFilter)
      texture2.minFilter = LinearFilter;
    const camera = new CubeCamera(1, 10, this);
    camera.update(renderer, scene);
    texture2.minFilter = currentMinFilter;
    texture2.currentGenerateMipmaps = currentGenerateMipmaps;
    mesh.geometry.dispose();
    mesh.material.dispose();
    return this;
  }
};
var CubeRenderTarget_default = CubeRenderTarget;

// node_modules/three/examples/jsm/nodes/core/NodeBuilder.js
var typeFromLength = /* @__PURE__ */ new Map([
  [2, "vec2"],
  [3, "vec3"],
  [4, "vec4"],
  [9, "mat3"],
  [16, "mat4"]
]);
var typeFromArray = /* @__PURE__ */ new Map([
  [Int8Array, "int"],
  [Int16Array, "int"],
  [Int32Array, "int"],
  [Uint8Array, "uint"],
  [Uint16Array, "uint"],
  [Uint32Array, "uint"],
  [Float32Array, "float"]
]);
var isNonPaddingElementArray = /* @__PURE__ */ new Set([Int32Array, Uint32Array, Float32Array]);
var toFloat = (value) => {
  value = Number(value);
  return value + (value % 1 ? "" : ".0");
};
var NodeBuilder = class {
  constructor(object, renderer, parser, scene = null) {
    this.object = object;
    this.material = object && object.material || null;
    this.geometry = object && object.geometry || null;
    this.renderer = renderer;
    this.parser = parser;
    this.scene = scene;
    this.nodes = [];
    this.updateNodes = [];
    this.updateBeforeNodes = [];
    this.hashNodes = {};
    this.lightsNode = null;
    this.environmentNode = null;
    this.fogNode = null;
    this.toneMappingNode = null;
    this.vertexShader = null;
    this.fragmentShader = null;
    this.computeShader = null;
    this.flowNodes = { vertex: [], fragment: [], compute: [] };
    this.flowCode = { vertex: "", fragment: "", compute: [] };
    this.uniforms = { vertex: [], fragment: [], compute: [], index: 0 };
    this.structs = { vertex: [], fragment: [], compute: [], index: 0 };
    this.codes = { vertex: [], fragment: [], compute: [] };
    this.bindings = { vertex: [], fragment: [], compute: [] };
    this.bindingsOffset = { vertex: 0, fragment: 0, compute: 0 };
    this.bindingsArray = null;
    this.attributes = [];
    this.bufferAttributes = [];
    this.varyings = [];
    this.vars = { vertex: [], fragment: [], compute: [] };
    this.flow = { code: "" };
    this.chaining = [];
    this.stack = stack();
    this.tab = "	";
    this.context = {
      keywords: new NodeKeywords_default(),
      material: this.material,
      getMIPLevelAlgorithmNode: (textureNode, levelNode) => levelNode.mul(maxMipLevel(textureNode))
    };
    this.cache = new NodeCache_default();
    this.globalCache = this.cache;
    this.flowsData = /* @__PURE__ */ new WeakMap();
    this.shaderStage = null;
    this.buildStage = null;
  }
  getRenderTarget(width, height, options) {
    return new RenderTarget(width, height, options);
  }
  getCubeRenderTarget(size, options) {
    return new CubeRenderTarget_default(size, options);
  }
  includes(node) {
    return this.nodes.includes(node);
  }
  createBindings() {
    const bindingsArray = [];
    for (const binding of this.getBindings()) {
      bindingsArray.push(binding.clone());
    }
    return bindingsArray;
  }
  getBindings() {
    let bindingsArray = this.bindingsArray;
    if (bindingsArray === null) {
      const bindings = this.bindings;
      this.bindingsArray = bindingsArray = this.material !== null ? [...bindings.vertex, ...bindings.fragment] : bindings.compute;
    }
    return bindingsArray;
  }
  setHashNode(node, hash2) {
    this.hashNodes[hash2] = node;
  }
  addNode(node) {
    if (this.nodes.includes(node) === false) {
      this.nodes.push(node);
      this.setHashNode(node, node.getHash(this));
    }
  }
  buildUpdateNodes() {
    for (const node of this.nodes) {
      const updateType = node.getUpdateType();
      const updateBeforeType = node.getUpdateBeforeType();
      if (updateType !== NodeUpdateType.NONE) {
        this.updateNodes.push(node.getSelf());
      }
      if (updateBeforeType !== NodeUpdateType.NONE) {
        this.updateBeforeNodes.push(node);
      }
    }
  }
  get currentNode() {
    return this.chaining[this.chaining.length - 1];
  }
  addChain(node) {
    this.chaining.push(node);
  }
  removeChain(node) {
    const lastChain = this.chaining.pop();
    if (lastChain !== node) {
      throw new Error("NodeBuilder: Invalid node chaining!");
    }
  }
  getMethod(method) {
    return method;
  }
  getNodeFromHash(hash2) {
    return this.hashNodes[hash2];
  }
  addFlow(shaderStage, node) {
    this.flowNodes[shaderStage].push(node);
    return node;
  }
  setContext(context2) {
    this.context = context2;
  }
  getContext() {
    return this.context;
  }
  setCache(cache3) {
    this.cache = cache3;
  }
  getCache() {
    return this.cache;
  }
  isAvailable() {
    return false;
  }
  getVertexIndex() {
    console.warn("Abstract function.");
  }
  getInstanceIndex() {
    console.warn("Abstract function.");
  }
  getFrontFacing() {
    console.warn("Abstract function.");
  }
  getFragCoord() {
    console.warn("Abstract function.");
  }
  isFlipY() {
    return false;
  }
  getTexture() {
    console.warn("Abstract function.");
  }
  getTextureLevel() {
    console.warn("Abstract function.");
  }
  // @TODO: rename to .generateConst()
  getConst(type, value = null) {
    if (value === null) {
      if (type === "float" || type === "int" || type === "uint")
        value = 0;
      else if (type === "bool")
        value = false;
      else if (type === "color")
        value = new Color();
      else if (type === "vec2")
        value = new Vector2();
      else if (type === "vec3")
        value = new Vector3();
      else if (type === "vec4")
        value = new Vector4();
    }
    if (type === "float")
      return toFloat(value);
    if (type === "int")
      return `${Math.round(value)}`;
    if (type === "uint")
      return value >= 0 ? `${Math.round(value)}u` : "0u";
    if (type === "bool")
      return value ? "true" : "false";
    if (type === "color")
      return `${this.getType("vec3")}( ${toFloat(value.r)}, ${toFloat(value.g)}, ${toFloat(value.b)} )`;
    const typeLength = this.getTypeLength(type);
    const componentType = this.getComponentType(type);
    const getConst = (value2) => this.getConst(componentType, value2);
    if (typeLength === 2) {
      return `${this.getType(type)}( ${getConst(value.x)}, ${getConst(value.y)} )`;
    } else if (typeLength === 3) {
      return `${this.getType(type)}( ${getConst(value.x)}, ${getConst(value.y)}, ${getConst(value.z)} )`;
    } else if (typeLength === 4) {
      return `${this.getType(type)}( ${getConst(value.x)}, ${getConst(value.y)}, ${getConst(value.z)}, ${getConst(value.w)} )`;
    } else if (typeLength > 4 && value && (value.isMatrix3 || value.isMatrix4)) {
      return `${this.getType(type)}( ${value.elements.map(getConst).join(", ")} )`;
    } else if (typeLength > 4) {
      return `${this.getType(type)}()`;
    }
    throw new Error(`NodeBuilder: Type '${type}' not found in generate constant attempt.`);
  }
  getType(type) {
    if (type === "color")
      return "vec3";
    return type;
  }
  generateMethod(method) {
    return method;
  }
  hasGeometryAttribute(name) {
    return this.geometry && this.geometry.getAttribute(name) !== void 0;
  }
  getAttribute(name, type) {
    const attributes = this.attributes;
    for (const attribute3 of attributes) {
      if (attribute3.name === name) {
        return attribute3;
      }
    }
    const attribute2 = new NodeAttribute_default(name, type);
    attributes.push(attribute2);
    return attribute2;
  }
  getPropertyName(node) {
    return node.name;
  }
  isVector(type) {
    return /vec\d/.test(type);
  }
  isMatrix(type) {
    return /mat\d/.test(type);
  }
  isReference(type) {
    return type === "void" || type === "property" || type === "sampler" || type === "texture" || type === "cubeTexture";
  }
  needsColorSpaceToLinear() {
    return false;
  }
  /** @deprecated, r152 */
  getTextureEncodingFromMap(map) {
    console.warn("THREE.NodeBuilder: Method .getTextureEncodingFromMap replaced by .getTextureColorSpaceFromMap in r152+.");
    return this.getTextureColorSpaceFromMap(map) === SRGBColorSpace ? sRGBEncoding : LinearEncoding;
  }
  getTextureColorSpaceFromMap(map) {
    let colorSpace;
    if (map && map.isTexture) {
      colorSpace = map.colorSpace;
    } else if (map && map.isWebGLRenderTarget) {
      colorSpace = map.texture.colorSpace;
    } else {
      colorSpace = NoColorSpace;
    }
    return colorSpace;
  }
  getComponentType(type) {
    type = this.getVectorType(type);
    if (type === "float" || type === "bool" || type === "int" || type === "uint")
      return type;
    const componentType = /(b|i|u|)(vec|mat)([2-4])/.exec(type);
    if (componentType === null)
      return null;
    if (componentType[1] === "b")
      return "bool";
    if (componentType[1] === "i")
      return "int";
    if (componentType[1] === "u")
      return "uint";
    return "float";
  }
  getVectorType(type) {
    if (type === "color")
      return "vec3";
    if (type === "texture")
      return "vec4";
    return type;
  }
  getTypeFromLength(length2, componentType = "float") {
    if (length2 === 1)
      return componentType;
    const baseType = typeFromLength.get(length2);
    const prefix = componentType === "float" ? "" : componentType[0];
    return prefix + baseType;
  }
  getTypeFromArray(array) {
    return typeFromArray.get(array.constructor);
  }
  getTypeFromAttribute(attribute2) {
    let dataAttribute = attribute2;
    if (attribute2.isInterleavedBufferAttribute)
      dataAttribute = attribute2.data;
    const array = dataAttribute.array;
    const itemSize = isNonPaddingElementArray.has(array.constructor) ? attribute2.itemSize : dataAttribute.stride || attribute2.itemSize;
    const normalized = attribute2.normalized;
    let arrayType;
    if (!(attribute2 instanceof Float16BufferAttribute) && normalized !== true) {
      arrayType = this.getTypeFromArray(array);
    }
    return this.getTypeFromLength(itemSize, arrayType);
  }
  getTypeLength(type) {
    const vecType = this.getVectorType(type);
    const vecNum = /vec([2-4])/.exec(vecType);
    if (vecNum !== null)
      return Number(vecNum[1]);
    if (vecType === "float" || vecType === "bool" || vecType === "int" || vecType === "uint")
      return 1;
    if (/mat3/.test(type) === true)
      return 9;
    if (/mat4/.test(type) === true)
      return 16;
    return 0;
  }
  getVectorFromMatrix(type) {
    return type.replace("mat", "vec");
  }
  changeComponentType(type, newComponentType) {
    return this.getTypeFromLength(this.getTypeLength(type), newComponentType);
  }
  getIntegerType(type) {
    const componentType = this.getComponentType(type);
    if (componentType === "int" || componentType === "uint")
      return type;
    return this.changeComponentType(type, "int");
  }
  addStack() {
    this.stack = stack(this.stack);
    return this.stack;
  }
  removeStack() {
    const currentStack = this.stack;
    this.stack = currentStack.parent;
    return currentStack;
  }
  getDataFromNode(node, shaderStage = this.shaderStage) {
    const cache3 = node.isGlobal(this) ? this.globalCache : this.cache;
    let nodeData = cache3.getNodeData(node);
    if (nodeData === void 0) {
      nodeData = {};
      cache3.setNodeData(node, nodeData);
    }
    if (nodeData[shaderStage] === void 0)
      nodeData[shaderStage] = {};
    return nodeData[shaderStage];
  }
  getNodeProperties(node, shaderStage = "any") {
    const nodeData = this.getDataFromNode(node, shaderStage);
    return nodeData.properties || (nodeData.properties = { outputNode: null });
  }
  getBufferAttributeFromNode(node, type) {
    const nodeData = this.getDataFromNode(node);
    let bufferAttribute2 = nodeData.bufferAttribute;
    if (bufferAttribute2 === void 0) {
      const index = this.uniforms.index++;
      bufferAttribute2 = new NodeAttribute_default("nodeAttribute" + index, type, node);
      this.bufferAttributes.push(bufferAttribute2);
      nodeData.bufferAttribute = bufferAttribute2;
    }
    return bufferAttribute2;
  }
  getStructTypeFromNode(node, shaderStage = this.shaderStage, name = null) {
    const nodeData = this.getDataFromNode(node, shaderStage);
    let nodeStruct = nodeData.structType;
    if (nodeStruct === void 0) {
      const index = this.structs.index++;
      node.name = `StructType${index}`;
      this.structs[shaderStage].push(node);
      nodeData.structType = node;
    }
    return node;
  }
  getUniformFromNode(node, type, shaderStage = this.shaderStage, name = null) {
    const nodeData = this.getDataFromNode(node, shaderStage);
    let nodeUniform = nodeData.uniform;
    if (nodeUniform === void 0) {
      const index = this.uniforms.index++;
      nodeUniform = new NodeUniform_default(name || "nodeUniform" + index, type, node);
      this.uniforms[shaderStage].push(nodeUniform);
      nodeData.uniform = nodeUniform;
    }
    return nodeUniform;
  }
  getVarFromNode(node, type, shaderStage = this.shaderStage) {
    const nodeData = this.getDataFromNode(node, shaderStage);
    let nodeVar = nodeData.variable;
    if (nodeVar === void 0) {
      const vars = this.vars[shaderStage];
      const index = vars.length;
      nodeVar = new NodeVar_default("nodeVar" + index, type);
      vars.push(nodeVar);
      nodeData.variable = nodeVar;
    }
    return nodeVar;
  }
  getVaryingFromNode(node, type) {
    const nodeData = this.getDataFromNode(node, "any");
    let nodeVarying = nodeData.varying;
    if (nodeVarying === void 0) {
      const varyings = this.varyings;
      const index = varyings.length;
      nodeVarying = new NodeVarying_default("nodeVarying" + index, type);
      varyings.push(nodeVarying);
      nodeData.varying = nodeVarying;
    }
    return nodeVarying;
  }
  getCodeFromNode(node, type, shaderStage = this.shaderStage) {
    const nodeData = this.getDataFromNode(node);
    let nodeCode = nodeData.code;
    if (nodeCode === void 0) {
      const codes = this.codes[shaderStage];
      const index = codes.length;
      nodeCode = new NodeCode_default("nodeCode" + index, type);
      codes.push(nodeCode);
      nodeData.code = nodeCode;
    }
    return nodeCode;
  }
  addLineFlowCode(code2) {
    if (code2 === "")
      return this;
    code2 = this.tab + code2;
    if (!/;\s*$/.test(code2)) {
      code2 = code2 + ";\n";
    }
    this.flow.code += code2;
    return this;
  }
  addFlowCode(code2) {
    this.flow.code += code2;
    return this;
  }
  addFlowTab() {
    this.tab += "	";
    return this;
  }
  removeFlowTab() {
    this.tab = this.tab.slice(0, -1);
    return this;
  }
  getFlowData(node) {
    return this.flowsData.get(node);
  }
  flowNode(node) {
    const output2 = node.getNodeType(this);
    const flowData = this.flowChildNode(node, output2);
    this.flowsData.set(node, flowData);
    return flowData;
  }
  flowChildNode(node, output2 = null) {
    const previousFlow = this.flow;
    const flow = {
      code: ""
    };
    this.flow = flow;
    flow.result = node.build(this, output2);
    this.flow = previousFlow;
    return flow;
  }
  flowNodeFromShaderStage(shaderStage, node, output2 = null, propertyName = null) {
    const previousShaderStage = this.shaderStage;
    this.setShaderStage(shaderStage);
    const flowData = this.flowChildNode(node, output2);
    if (propertyName !== null) {
      flowData.code += `${this.tab + propertyName} = ${flowData.result};
`;
    }
    this.flowCode[shaderStage] = this.flowCode[shaderStage] + flowData.code;
    this.setShaderStage(previousShaderStage);
    return flowData;
  }
  getAttributesArray() {
    return this.attributes.concat(this.bufferAttributes);
  }
  getAttributes() {
    console.warn("Abstract function.");
  }
  getVaryings() {
    console.warn("Abstract function.");
  }
  getVar(type, name) {
    return `${this.getType(type)} ${name}`;
  }
  getVars(shaderStage) {
    let snippet = "";
    const vars = this.vars[shaderStage];
    for (const variable of vars) {
      snippet += `${this.getVar(variable.type, variable.name)}; `;
    }
    return snippet;
  }
  getUniforms() {
    console.warn("Abstract function.");
  }
  getCodes(shaderStage) {
    const codes = this.codes[shaderStage];
    let code2 = "";
    for (const nodeCode of codes) {
      code2 += nodeCode.code + "\n";
    }
    return code2;
  }
  getHash() {
    return this.vertexShader + this.fragmentShader + this.computeShader;
  }
  setShaderStage(shaderStage) {
    this.shaderStage = shaderStage;
  }
  getShaderStage() {
    return this.shaderStage;
  }
  setBuildStage(buildStage) {
    this.buildStage = buildStage;
  }
  getBuildStage() {
    return this.buildStage;
  }
  buildCode() {
    console.warn("Abstract function.");
  }
  build() {
    for (const buildStage of defaultBuildStages) {
      this.setBuildStage(buildStage);
      if (this.context.vertex && this.context.vertex.isNode) {
        this.flowNodeFromShaderStage("vertex", this.context.vertex);
      }
      for (const shaderStage of shaderStages) {
        this.setShaderStage(shaderStage);
        const flowNodes = this.flowNodes[shaderStage];
        for (const node of flowNodes) {
          if (buildStage === "generate") {
            this.flowNode(node);
          } else {
            node.build(this);
          }
        }
      }
    }
    this.setBuildStage(null);
    this.setShaderStage(null);
    this.buildCode();
    this.buildUpdateNodes();
    return this;
  }
  getNodeUniform(uniformNode, type) {
    if (type === "float")
      return new FloatNodeUniform(uniformNode);
    if (type === "vec2")
      return new Vector2NodeUniform(uniformNode);
    if (type === "vec3")
      return new Vector3NodeUniform(uniformNode);
    if (type === "vec4")
      return new Vector4NodeUniform(uniformNode);
    if (type === "color")
      return new ColorNodeUniform(uniformNode);
    if (type === "mat3")
      return new Matrix3NodeUniform(uniformNode);
    if (type === "mat4")
      return new Matrix4NodeUniform(uniformNode);
    throw new Error(`Uniform "${type}" not declared.`);
  }
  createNodeMaterial(type) {
    return createNodeMaterialFromType(type);
  }
  format(snippet, fromType, toType) {
    fromType = this.getVectorType(fromType);
    toType = this.getVectorType(toType);
    if (fromType === toType || toType === null || this.isReference(toType)) {
      return snippet;
    }
    const fromTypeLength = this.getTypeLength(fromType);
    const toTypeLength = this.getTypeLength(toType);
    if (fromTypeLength > 4) {
      return snippet;
    }
    if (toTypeLength > 4 || toTypeLength === 0) {
      return snippet;
    }
    if (fromTypeLength === toTypeLength) {
      return `${this.getType(toType)}( ${snippet} )`;
    }
    if (fromTypeLength > toTypeLength) {
      return this.format(`${snippet}.${"xyz".slice(0, toTypeLength)}`, this.getTypeFromLength(toTypeLength, this.getComponentType(fromType)), toType);
    }
    if (toTypeLength === 4) {
      return `${this.getType(toType)}( ${this.format(snippet, fromType, "vec3")}, 1.0 )`;
    }
    if (fromTypeLength === 2) {
      return `${this.getType(toType)}( ${this.format(snippet, fromType, "vec2")}, 0.0 )`;
    }
    return `${this.getType(toType)}( ${snippet} )`;
  }
  getSignature() {
    return `// Three.js r${REVISION} - NodeMaterial System
`;
  }
};
var NodeBuilder_default = NodeBuilder;

// node_modules/three/examples/jsm/nodes/core/NodeFrame.js
var NodeFrame = class {
  constructor() {
    this.time = 0;
    this.deltaTime = 0;
    this.frameId = 0;
    this.renderId = 0;
    this.startTime = null;
    this.frameMap = /* @__PURE__ */ new WeakMap();
    this.frameBeforeMap = /* @__PURE__ */ new WeakMap();
    this.renderMap = /* @__PURE__ */ new WeakMap();
    this.renderBeforeMap = /* @__PURE__ */ new WeakMap();
    this.renderer = null;
    this.material = null;
    this.camera = null;
    this.object = null;
    this.scene = null;
  }
  updateBeforeNode(node) {
    const updateType = node.getUpdateBeforeType();
    if (updateType === NodeUpdateType.FRAME) {
      if (this.frameBeforeMap.get(node) !== this.frameId) {
        this.frameBeforeMap.set(node, this.frameId);
        node.updateBefore(this);
      }
    } else if (updateType === NodeUpdateType.RENDER) {
      if (this.renderBeforeMap.get(node) !== this.renderId || this.frameBeforeMap.get(node) !== this.frameId) {
        this.renderBeforeMap.set(node, this.renderId);
        this.frameBeforeMap.set(node, this.frameId);
        node.updateBefore(this);
      }
    } else if (updateType === NodeUpdateType.OBJECT) {
      node.updateBefore(this);
    }
  }
  updateNode(node) {
    const updateType = node.getUpdateType();
    if (updateType === NodeUpdateType.FRAME) {
      if (this.frameMap.get(node) !== this.frameId) {
        this.frameMap.set(node, this.frameId);
        node.update(this);
      }
    } else if (updateType === NodeUpdateType.RENDER) {
      if (this.renderMap.get(node) !== this.renderId || this.frameMap.get(node) !== this.frameId) {
        this.renderMap.set(node, this.renderId);
        this.frameMap.set(node, this.frameId);
        node.update(this);
      }
    } else if (updateType === NodeUpdateType.OBJECT) {
      node.update(this);
    }
  }
  update() {
    this.frameId++;
    if (this.lastTime === void 0)
      this.lastTime = performance.now();
    this.deltaTime = (performance.now() - this.lastTime) / 1e3;
    this.lastTime = performance.now();
    this.time += this.deltaTime;
  }
};
var NodeFrame_default = NodeFrame;

// node_modules/three/examples/jsm/nodes/core/NodeFunctionInput.js
var NodeFunctionInput = class {
  constructor(type, name, count = null, qualifier = "", isConst = false) {
    this.type = type;
    this.name = name;
    this.count = count;
    this.qualifier = qualifier;
    this.isConst = isConst;
  }
};
NodeFunctionInput.isNodeFunctionInput = true;
var NodeFunctionInput_default = NodeFunctionInput;

// node_modules/three/examples/jsm/nodes/core/StructTypeNode.js
var StructTypeNode = class extends Node_default {
  constructor(types) {
    super();
    this.types = types;
    this.isStructTypeNode = true;
  }
  getMemberTypes() {
    return this.types;
  }
};
var StructTypeNode_default = StructTypeNode;
addNodeClass(StructTypeNode);

// node_modules/three/examples/jsm/nodes/core/OutputStructNode.js
var OutputStructNode = class extends Node_default {
  constructor(...members) {
    super();
    this.isOutputStructNode = true;
    this.members = members;
  }
  construct(builder) {
    super.construct(builder);
    const members = this.members;
    const types = [];
    for (let i = 0; i < members.length; i++) {
      types.push(members[i].getNodeType(builder));
    }
    this.nodeType = builder.getStructTypeFromNode(new StructTypeNode_default(types)).name;
  }
  generate(builder, output2) {
    const nodeVar = builder.getVarFromNode(this, this.nodeType);
    const propertyName = builder.getPropertyName(nodeVar);
    const members = this.members;
    for (let i = 0; i < members.length; i++) {
      const snippet = members[i].build(builder, output2);
      builder.addLineFlowCode(`${propertyName}.m${i} = ${snippet}`);
    }
    return propertyName;
  }
};
var OutputStructNode_default = OutputStructNode;
var outputStruct = nodeProxy(OutputStructNode);
addNodeClass(OutputStructNode);

// node_modules/three/examples/jsm/nodes/math/HashNode.js
var HashNode = class extends Node_default {
  constructor(seedNode) {
    super();
    this.seedNode = seedNode;
  }
  construct() {
    const seed = this.seedNode;
    const state = add(mul(uint(seed), 747796405), 2891336453);
    const word = mul(bitXor(shiftRight(state, add(shiftRight(state, 28), 4)), state), 277803737);
    const uintResult = bitXor(shiftRight(word, 22), word);
    return mul(1 / 2 ** 32, uintResult);
  }
};
var HashNode_default = HashNode;
var hash = nodeProxy(HashNode);
addNodeElement("hash", hash);
addNodeClass(HashNode);

// node_modules/three/examples/jsm/nodes/utils/DiscardNode.js
var discardExpression;
var DiscardNode = class extends CondNode_default {
  constructor(condNode) {
    discardExpression = discardExpression || expression("discard");
    super(condNode, discardExpression);
  }
};
var DiscardNode_default = DiscardNode;
var discard = nodeProxy(DiscardNode);
addNodeElement("discard", discard);
addNodeClass(DiscardNode);

// node_modules/three/examples/jsm/nodes/utils/MatcapUVNode.js
var MatcapUVNode = class extends TempNode_default {
  constructor() {
    super("vec2");
  }
  construct() {
    const x = vec3(positionViewDirection.z, 0, positionViewDirection.x.negate()).normalize();
    const y = positionViewDirection.cross(x);
    return vec2(x.dot(transformedNormalView), y.dot(transformedNormalView)).mul(0.495).add(0.5);
  }
};
var MatcapUVNode_default = MatcapUVNode;
var matcapUV = nodeImmutable(MatcapUVNode);
addNodeClass(MatcapUVNode);

// node_modules/three/examples/jsm/nodes/utils/TimerNode.js
var TimerNode = class _TimerNode extends UniformNode_default {
  constructor(scope = _TimerNode.LOCAL, scale = 1, value = 0) {
    super(value);
    this.scope = scope;
    this.scale = scale;
    this.updateType = NodeUpdateType.FRAME;
  }
  /*
  	@TODO:
  	getNodeType( builder ) {
  
  		const scope = this.scope;
  
  		if ( scope === TimerNode.FRAME ) {
  
  			return 'uint';
  
  		}
  
  		return 'float';
  
  	}
  */
  update(frame) {
    const scope = this.scope;
    const scale = this.scale;
    if (scope === _TimerNode.LOCAL) {
      this.value += frame.deltaTime * scale;
    } else if (scope === _TimerNode.DELTA) {
      this.value = frame.deltaTime * scale;
    } else if (scope === _TimerNode.FRAME) {
      this.value = frame.frameId;
    } else {
      this.value = frame.time * scale;
    }
  }
  serialize(data) {
    super.serialize(data);
    data.scope = this.scope;
    data.scale = this.scale;
  }
  deserialize(data) {
    super.deserialize(data);
    this.scope = data.scope;
    this.scale = data.scale;
  }
};
TimerNode.LOCAL = "local";
TimerNode.GLOBAL = "global";
TimerNode.DELTA = "delta";
TimerNode.FRAME = "frame";
var TimerNode_default = TimerNode;
var timerLocal = (timeScale, value = 0) => nodeObject(new TimerNode(TimerNode.LOCAL, timeScale, value));
var timerGlobal = (timeScale, value = 0) => nodeObject(new TimerNode(TimerNode.GLOBAL, timeScale, value));
var timerDelta = (timeScale, value = 0) => nodeObject(new TimerNode(TimerNode.DELTA, timeScale, value));
var frameId = nodeImmutable(TimerNode, TimerNode.FRAME);
addNodeClass(TimerNode);

// node_modules/three/examples/jsm/nodes/utils/OscNode.js
var OscNode = class _OscNode extends Node_default {
  constructor(method = _OscNode.SINE, timeNode = timerLocal()) {
    super();
    this.method = method;
    this.timeNode = timeNode;
  }
  getNodeType(builder) {
    return this.timeNode.getNodeType(builder);
  }
  construct() {
    const method = this.method;
    const timeNode = nodeObject(this.timeNode);
    let outputNode = null;
    if (method === _OscNode.SINE) {
      outputNode = timeNode.add(0.75).mul(Math.PI * 2).sin().mul(0.5).add(0.5);
    } else if (method === _OscNode.SQUARE) {
      outputNode = timeNode.fract().round();
    } else if (method === _OscNode.TRIANGLE) {
      outputNode = timeNode.add(0.5).fract().mul(2).sub(1).abs();
    } else if (method === _OscNode.SAWTOOTH) {
      outputNode = timeNode.fract();
    }
    return outputNode;
  }
  serialize(data) {
    super.serialize(data);
    data.method = this.method;
  }
  deserialize(data) {
    super.deserialize(data);
    this.method = data.method;
  }
};
OscNode.SINE = "sine";
OscNode.SQUARE = "square";
OscNode.TRIANGLE = "triangle";
OscNode.SAWTOOTH = "sawtooth";
var OscNode_default = OscNode;
var oscSine = nodeProxy(OscNode, OscNode.SINE);
var oscSquare = nodeProxy(OscNode, OscNode.SQUARE);
var oscTriangle = nodeProxy(OscNode, OscNode.TRIANGLE);
var oscSawtooth = nodeProxy(OscNode, OscNode.SAWTOOTH);
addNodeClass(OscNode);

// node_modules/three/examples/jsm/nodes/utils/PackingNode.js
var PackingNode = class _PackingNode extends TempNode_default {
  constructor(scope, node) {
    super();
    this.scope = scope;
    this.node = node;
  }
  getNodeType(builder) {
    return this.node.getNodeType(builder);
  }
  construct() {
    const { scope, node } = this;
    let result = null;
    if (scope === _PackingNode.DIRECTION_TO_COLOR) {
      result = node.mul(0.5).add(0.5);
    } else if (scope === _PackingNode.COLOR_TO_DIRECTION) {
      result = node.mul(2).sub(1);
    }
    return result;
  }
};
PackingNode.DIRECTION_TO_COLOR = "directionToColor";
PackingNode.COLOR_TO_DIRECTION = "colorToDirection";
var PackingNode_default = PackingNode;
var directionToColor = nodeProxy(PackingNode, PackingNode.DIRECTION_TO_COLOR);
var colorToDirection = nodeProxy(PackingNode, PackingNode.COLOR_TO_DIRECTION);
addNodeElement("directionToColor", directionToColor);
addNodeElement("colorToDirection", colorToDirection);
addNodeClass(PackingNode);

// node_modules/three/examples/jsm/nodes/utils/RemapNode.js
var RemapNode = class extends Node_default {
  constructor(node, inLowNode, inHighNode, outLowNode, outHighNode) {
    super();
    this.node = node;
    this.inLowNode = inLowNode;
    this.inHighNode = inHighNode;
    this.outLowNode = outLowNode;
    this.outHighNode = outHighNode;
    this.doClamp = true;
  }
  construct() {
    const { node, inLowNode, inHighNode, outLowNode, outHighNode, doClamp } = this;
    let t = node.sub(inLowNode).div(inHighNode.sub(inLowNode));
    if (doClamp === true)
      t = t.clamp();
    return t.mul(outHighNode.sub(outLowNode)).add(outLowNode);
  }
};
var RemapNode_default = RemapNode;
var remap = nodeProxy(RemapNode, null, null, { doClamp: false });
var remapClamp = nodeProxy(RemapNode);
addNodeElement("remap", remap);
addNodeElement("remapClamp", remapClamp);
addNodeClass(RemapNode);

// node_modules/three/examples/jsm/nodes/utils/RotateUVNode.js
var RotateUVNode = class extends TempNode_default {
  constructor(uvNode, rotationNode, centerNode = vec2(0.5)) {
    super("vec2");
    this.uvNode = uvNode;
    this.rotationNode = rotationNode;
    this.centerNode = centerNode;
  }
  construct() {
    const { uvNode, rotationNode, centerNode } = this;
    const cosAngle = rotationNode.cos();
    const sinAngle = rotationNode.sin();
    const vector = uvNode.sub(centerNode);
    const rotatedVector = vec2(
      // @TODO: Maybe we can create mat2 and write something like rotationMatrix.mul( vector )?
      vec2(cosAngle, sinAngle).dot(vector),
      vec2(sinAngle.negate(), cosAngle).dot(vector)
    );
    return rotatedVector.add(centerNode);
  }
};
var RotateUVNode_default = RotateUVNode;
var rotateUV = nodeProxy(RotateUVNode);
addNodeElement("rotateUV", rotateUV);
addNodeClass(RotateUVNode);

// node_modules/three/examples/jsm/nodes/utils/SpriteSheetUVNode.js
var SpriteSheetUVNode = class extends Node_default {
  constructor(countNode, uvNode = uv(), frameNode = float(0)) {
    super("vec2");
    this.countNode = countNode;
    this.uvNode = uvNode;
    this.frameNode = frameNode;
  }
  construct() {
    const { frameNode, uvNode, countNode } = this;
    const { width, height } = countNode;
    const frameNum = frameNode.mod(width.mul(height)).floor();
    const column = frameNum.mod(width);
    const row = height.sub(frameNum.add(1).div(width).ceil());
    const scale = countNode.reciprocal();
    const uvFrameOffset = vec2(column, row);
    return uvNode.add(uvFrameOffset).mul(scale);
  }
};
var SpriteSheetUVNode_default = SpriteSheetUVNode;
var spritesheetUV = nodeProxy(SpriteSheetUVNode);
addNodeClass(SpriteSheetUVNode);

// node_modules/three/examples/jsm/nodes/utils/TriplanarTexturesNode.js
var TriplanarTexturesNode = class extends Node_default {
  constructor(textureXNode, textureYNode = null, textureZNode = null, scaleNode = float(1), positionNode = positionWorld, normalNode = normalWorld) {
    super("vec4");
    this.textureXNode = textureXNode;
    this.textureYNode = textureYNode;
    this.textureZNode = textureZNode;
    this.scaleNode = scaleNode;
    this.positionNode = positionNode;
    this.normalNode = normalNode;
  }
  construct() {
    const { textureXNode, textureYNode, textureZNode, scaleNode, positionNode, normalNode } = this;
    let bf = normalNode.abs().normalize();
    bf = bf.div(bf.dot(vec3(1)));
    const tx = positionNode.yz.mul(scaleNode);
    const ty = positionNode.zx.mul(scaleNode);
    const tz = positionNode.xy.mul(scaleNode);
    const textureX = textureXNode.value;
    const textureY = textureYNode !== null ? textureYNode.value : textureX;
    const textureZ = textureZNode !== null ? textureZNode.value : textureX;
    const cx = texture(textureX, tx).mul(bf.x);
    const cy = texture(textureY, ty).mul(bf.y);
    const cz = texture(textureZ, tz).mul(bf.z);
    return add(cx, cy, cz);
  }
};
var TriplanarTexturesNode_default = TriplanarTexturesNode;
var triplanarTextures = nodeProxy(TriplanarTexturesNode);
var triplanarTexture = (...params) => triplanarTextures(...params);
addNodeElement("triplanarTexture", triplanarTexture);
addNodeClass(TriplanarTexturesNode);

// node_modules/three/examples/jsm/nodes/accessors/TextureBicubicNode.js
var bC = 1 / 6;
var w0 = (a) => mul(bC, mul(a, mul(a, a.negate().add(3)).sub(3)).add(1));
var w1 = (a) => mul(bC, mul(a, mul(a, mul(3, a).sub(6))).add(4));
var w2 = (a) => mul(bC, mul(a, mul(a, mul(-3, a).add(3)).add(3)).add(1));
var w3 = (a) => mul(bC, pow(a, 3));
var g0 = (a) => w0(a).add(w1(a));
var g1 = (a) => w2(a).add(w3(a));
var h0 = (a) => add(-1, w1(a).div(w0(a).add(w1(a))));
var h1 = (a) => add(1, w3(a).div(w2(a).add(w3(a))));
var bicubic = (textureNode, texelSize, lod) => {
  const uv2 = textureNode.uvNode;
  const uvScaled = mul(uv2, texelSize.zw).add(0.5);
  const iuv = floor(uvScaled);
  const fuv = fract(uvScaled);
  const g0x = g0(fuv.x);
  const g1x = g1(fuv.x);
  const h0x = h0(fuv.x);
  const h1x = h1(fuv.x);
  const h0y = h0(fuv.y);
  const h1y = h1(fuv.y);
  const p0 = vec2(iuv.x.add(h0x), iuv.y.add(h0y)).sub(0.5).mul(texelSize.xy);
  const p1 = vec2(iuv.x.add(h1x), iuv.y.add(h0y)).sub(0.5).mul(texelSize.xy);
  const p2 = vec2(iuv.x.add(h0x), iuv.y.add(h1y)).sub(0.5).mul(texelSize.xy);
  const p3 = vec2(iuv.x.add(h1x), iuv.y.add(h1y)).sub(0.5).mul(texelSize.xy);
  const a = g0(fuv.y).mul(add(g0x.mul(textureNode.uv(p0).level(lod)), g1x.mul(textureNode.uv(p1).level(lod))));
  const b = g1(fuv.y).mul(add(g0x.mul(textureNode.uv(p2).level(lod)), g1x.mul(textureNode.uv(p3).level(lod))));
  return a.add(b);
};
var textureBicubicMethod = (textureNode, lodNode) => {
  const fLodSize = vec2(textureNode.size(int(lodNode)));
  const cLodSize = vec2(textureNode.size(int(lodNode.add(1))));
  const fLodSizeInv = div(1, fLodSize);
  const cLodSizeInv = div(1, cLodSize);
  const fSample = bicubic(textureNode, vec4(fLodSizeInv, fLodSize), floor(lodNode));
  const cSample = bicubic(textureNode, vec4(cLodSizeInv, cLodSize), ceil(lodNode));
  return fract(lodNode).mix(fSample, cSample);
};
var TextureBicubicNode = class extends TempNode_default {
  constructor(textureNode, blurNode = float(3)) {
    super("vec4");
    this.textureNode = textureNode;
    this.blurNode = blurNode;
  }
  construct() {
    return textureBicubicMethod(this.textureNode, this.blurNode);
  }
};
var TextureBicubicNode_default = TextureBicubicNode;
var textureBicubic = nodeProxy(TextureBicubicNode);
addNodeElement("bicubic", textureBicubic);
addNodeClass(TextureBicubicNode);

// node_modules/three/examples/jsm/nodes/accessors/PointUVNode.js
var PointUVNode = class extends Node_default {
  constructor() {
    super("vec2");
    this.isPointUVNode = true;
  }
  generate() {
    return "vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y )";
  }
};
var PointUVNode_default = PointUVNode;
var pointUV = nodeImmutable(PointUVNode);
addNodeClass(PointUVNode);

// node_modules/three/examples/jsm/nodes/accessors/SceneNode.js
var SceneNode = class _SceneNode extends Node_default {
  constructor(scope = _SceneNode.BACKGROUND_BLURRINESS, scene = null) {
    super();
    this.scope = scope;
    this.scene = scene;
  }
  construct(builder) {
    const scope = this.scope;
    const scene = this.scene !== null ? this.scene : builder.scene;
    let output2;
    if (scope === _SceneNode.BACKGROUND_BLURRINESS) {
      output2 = reference("backgroundBlurriness", "float", scene);
    } else if (scope === _SceneNode.BACKGROUND_INTENSITY) {
      output2 = reference("backgroundIntensity", "float", scene);
    } else {
      console.error("THREE.SceneNode: Unknown scope:", scope);
    }
    return output2;
  }
};
SceneNode.BACKGROUND_BLURRINESS = "backgroundBlurriness";
SceneNode.BACKGROUND_INTENSITY = "backgroundIntensity";
var SceneNode_default = SceneNode;
var backgroundBlurriness = nodeImmutable(SceneNode, SceneNode.BACKGROUND_BLURRINESS);
var backgroundIntensity = nodeImmutable(SceneNode, SceneNode.BACKGROUND_INTENSITY);
addNodeClass(SceneNode);

// node_modules/three/examples/jsm/nodes/accessors/StorageBufferNode.js
var StorageBufferNode = class extends BufferNode_default {
  constructor(value, bufferType, bufferCount = 0) {
    super(value, bufferType, bufferCount);
    this.isStorageBufferNode = true;
  }
  getInputType() {
    return "storageBuffer";
  }
};
var StorageBufferNode_default = StorageBufferNode;
var storage = (value, type, count) => nodeObject(new StorageBufferNode(value, type, count));
addNodeClass(StorageBufferNode);

// node_modules/three/examples/jsm/nodes/accessors/TextureStoreNode.js
var TextureStoreNode = class extends TextureNode_default {
  constructor(value, uvNode, storeNode = null) {
    super(value, uvNode);
    this.storeNode = storeNode;
    this.isStoreTextureNode = true;
  }
  getNodeType() {
    return "void";
  }
};
var TextureStoreNode_default = TextureStoreNode;
var textureStore = nodeProxy(TextureStoreNode);
addNodeClass(TextureStoreNode);

// node_modules/three/examples/jsm/nodes/accessors/UserDataNode.js
var UserDataNode = class extends ReferenceNode_default {
  constructor(property2, inputType, userData2 = null) {
    super(property2, inputType, userData2);
    this.userData = userData2;
  }
  update(frame) {
    this.object = this.userData !== null ? this.userData : frame.object.userData;
    super.update(frame);
  }
};
var UserDataNode_default = UserDataNode;
var userData = (name, inputType, userData2) => nodeObject(new UserDataNode(name, inputType, userData2));
addNodeClass(UserDataNode);

// node_modules/three/examples/jsm/nodes/display/BlendModeNode.js
var BurnNode = tslFn(({ base, blend }) => {
  const fn = (c) => blend[c].lessThan(EPSILON).cond(blend[c], base[c].oneMinus().div(blend[c]).oneMinus().max(0));
  return vec3(fn("x"), fn("y"), fn("z"));
});
var DodgeNode = tslFn(({ base, blend }) => {
  const fn = (c) => blend[c].equal(1).cond(blend[c], base[c].div(blend[c].oneMinus()).max(0));
  return vec3(fn("x"), fn("y"), fn("z"));
});
var ScreenNode = tslFn(({ base, blend }) => {
  const fn = (c) => base[c].oneMinus().mul(blend[c].oneMinus()).oneMinus();
  return vec3(fn("x"), fn("y"), fn("z"));
});
var OverlayNode = tslFn(({ base, blend }) => {
  const fn = (c) => base[c].lessThan(0.5).cond(base[c].mul(blend[c], 2), base[c].oneMinus().mul(blend[c].oneMinus()).oneMinus());
  return vec3(fn("x"), fn("y"), fn("z"));
});
var BlendModeNode = class _BlendModeNode extends TempNode_default {
  constructor(blendMode, baseNode, blendNode) {
    super();
    this.blendMode = blendMode;
    this.baseNode = baseNode;
    this.blendNode = blendNode;
  }
  construct() {
    const { blendMode, baseNode, blendNode } = this;
    const params = { base: baseNode, blend: blendNode };
    let outputNode = null;
    if (blendMode === _BlendModeNode.BURN) {
      outputNode = BurnNode(params);
    } else if (blendMode === _BlendModeNode.DODGE) {
      outputNode = DodgeNode(params);
    } else if (blendMode === _BlendModeNode.SCREEN) {
      outputNode = ScreenNode(params);
    } else if (blendMode === _BlendModeNode.OVERLAY) {
      outputNode = OverlayNode(params);
    }
    return outputNode;
  }
};
BlendModeNode.BURN = "burn";
BlendModeNode.DODGE = "dodge";
BlendModeNode.SCREEN = "screen";
BlendModeNode.OVERLAY = "overlay";
var BlendModeNode_default = BlendModeNode;
var burn = nodeProxy(BlendModeNode, BlendModeNode.BURN);
var dodge = nodeProxy(BlendModeNode, BlendModeNode.DODGE);
var overlay = nodeProxy(BlendModeNode, BlendModeNode.OVERLAY);
var screen = nodeProxy(BlendModeNode, BlendModeNode.SCREEN);
addNodeElement("burn", burn);
addNodeElement("dodge", dodge);
addNodeElement("overlay", overlay);
addNodeElement("screen", screen);
addNodeClass(BlendModeNode);

// node_modules/three/examples/jsm/nodes/display/ColorAdjustmentNode.js
var saturationNode = tslFn(({ color: color2, adjustment }) => {
  return adjustment.mix(luminance(color2), color2);
});
var vibranceNode = tslFn(({ color: color2, adjustment }) => {
  const average = add(color2.r, color2.g, color2.b).div(3);
  const mx = color2.r.max(color2.g.max(color2.b));
  const amt = mx.sub(average).mul(adjustment).mul(-3);
  return mix(color2, mx, amt);
});
var hueNode = tslFn(({ color: color2, adjustment }) => {
  const RGBtoYIQ = mat3(0.299, 0.587, 0.114, 0.595716, -0.274453, -0.321263, 0.211456, -0.522591, 0.311135);
  const YIQtoRGB = mat3(1, 0.9563, 0.621, 1, -0.2721, -0.6474, 1, -1.107, 1.7046);
  const yiq = RGBtoYIQ.mul(color2);
  const hue2 = yiq.z.atan2(yiq.y).add(adjustment);
  const chroma = yiq.yz.length();
  return YIQtoRGB.mul(vec3(yiq.x, chroma.mul(hue2.cos()), chroma.mul(hue2.sin())));
});
var ColorAdjustmentNode = class _ColorAdjustmentNode extends TempNode_default {
  constructor(method, colorNode, adjustmentNode = float(1)) {
    super("vec3");
    this.method = method;
    this.colorNode = colorNode;
    this.adjustmentNode = adjustmentNode;
  }
  construct() {
    const { method, colorNode, adjustmentNode } = this;
    const callParams = { color: colorNode, adjustment: adjustmentNode };
    let outputNode = null;
    if (method === _ColorAdjustmentNode.SATURATION) {
      outputNode = saturationNode(callParams);
    } else if (method === _ColorAdjustmentNode.VIBRANCE) {
      outputNode = vibranceNode(callParams);
    } else if (method === _ColorAdjustmentNode.HUE) {
      outputNode = hueNode(callParams);
    } else {
      console.error(`${this.type}: Method "${this.method}" not supported!`);
    }
    return outputNode;
  }
};
ColorAdjustmentNode.SATURATION = "saturation";
ColorAdjustmentNode.VIBRANCE = "vibrance";
ColorAdjustmentNode.HUE = "hue";
var ColorAdjustmentNode_default = ColorAdjustmentNode;
var saturation = nodeProxy(ColorAdjustmentNode, ColorAdjustmentNode.SATURATION);
var vibrance = nodeProxy(ColorAdjustmentNode, ColorAdjustmentNode.VIBRANCE);
var hue = nodeProxy(ColorAdjustmentNode, ColorAdjustmentNode.HUE);
var lumaCoeffs = vec3(0.2125, 0.7154, 0.0721);
var luminance = (color2, luma = lumaCoeffs) => dot(color2, luma);
addNodeElement("saturation", saturation);
addNodeElement("vibrance", vibrance);
addNodeElement("hue", hue);
addNodeClass(ColorAdjustmentNode);

// node_modules/three/examples/jsm/nodes/display/PosterizeNode.js
var PosterizeNode = class extends TempNode_default {
  constructor(sourceNode, stepsNode) {
    super();
    this.sourceNode = sourceNode;
    this.stepsNode = stepsNode;
  }
  construct() {
    const { sourceNode, stepsNode } = this;
    return sourceNode.mul(stepsNode).floor().div(stepsNode);
  }
};
var PosterizeNode_default = PosterizeNode;
var posterize = nodeProxy(PosterizeNode);
addNodeElement("posterize", posterize);
addNodeClass(PosterizeNode);

// node_modules/three/examples/jsm/nodes/display/ToneMappingNode.js
var LinearToneMappingNode = tslFn(({ color: color2, exposure }) => {
  return color2.mul(exposure).clamp();
});
var ReinhardToneMappingNode = tslFn(({ color: color2, exposure }) => {
  color2 = color2.mul(exposure);
  return color2.div(color2.add(1)).clamp();
});
var OptimizedCineonToneMappingNode = tslFn(({ color: color2, exposure }) => {
  color2 = color2.mul(exposure);
  color2 = color2.sub(4e-3).max(0);
  const a = color2.mul(color2.mul(6.2).add(0.5));
  const b = color2.mul(color2.mul(6.2).add(1.7)).add(0.06);
  return a.div(b).pow(2.2);
});
var RRTAndODTFit = tslFn(({ color: color2 }) => {
  const a = color2.mul(color2.add(0.0245786)).sub(90537e-9);
  const b = color2.mul(color2.add(0.432951).mul(0.983729)).add(0.238081);
  return a.div(b);
});
var ACESFilmicToneMappingNode = tslFn(({ color: color2, exposure }) => {
  const ACESInputMat = mat3(
    0.59719,
    0.35458,
    0.04823,
    0.076,
    0.90834,
    0.01566,
    0.0284,
    0.13383,
    0.83777
  );
  const ACESOutputMat = mat3(
    1.60475,
    -0.53108,
    -0.07367,
    -0.10208,
    1.10813,
    -605e-5,
    -327e-5,
    -0.07276,
    1.07602
  );
  color2 = color2.mul(exposure).div(0.6);
  color2 = ACESInputMat.mul(color2);
  color2 = RRTAndODTFit({ color: color2 });
  color2 = ACESOutputMat.mul(color2);
  return color2.clamp();
});
var toneMappingLib = {
  [LinearToneMapping]: LinearToneMappingNode,
  [ReinhardToneMapping]: ReinhardToneMappingNode,
  [CineonToneMapping]: OptimizedCineonToneMappingNode,
  [ACESFilmicToneMapping]: ACESFilmicToneMappingNode
};
var ToneMappingNode = class extends TempNode_default {
  constructor(toneMapping2 = NoToneMapping, exposureNode = float(1), colorNode = null) {
    super("vec3");
    this.toneMapping = toneMapping2;
    this.exposureNode = exposureNode;
    this.colorNode = colorNode;
  }
  getCacheKey() {
    let cacheKey = super.getCacheKey();
    cacheKey = "{toneMapping:" + this.toneMapping + ",nodes:" + cacheKey + "}";
    return cacheKey;
  }
  construct(builder) {
    const colorNode = this.colorNode || builder.context.color;
    const toneMapping2 = this.toneMapping;
    if (toneMapping2 === NoToneMapping)
      return colorNode;
    const toneMappingParams = { exposure: this.exposureNode, color: colorNode };
    const toneMappingNode = toneMappingLib[toneMapping2];
    let outputNode = null;
    if (toneMappingNode) {
      outputNode = toneMappingNode(toneMappingParams);
    } else {
      console.error("ToneMappingNode: Unsupported Tone Mapping configuration.", toneMapping2);
      outputNode = colorNode;
    }
    return outputNode;
  }
};
var ToneMappingNode_default = ToneMappingNode;
var toneMapping = (mapping, exposure, color2) => nodeObject(new ToneMappingNode(mapping, nodeObject(exposure), nodeObject(color2)));
addNodeClass(ToneMappingNode);

// node_modules/three/examples/jsm/nodes/display/ViewportNode.js
var resolution;
var viewportResult;
var ViewportNode = class _ViewportNode extends Node_default {
  constructor(scope) {
    super();
    this.scope = scope;
    this.isViewportNode = true;
  }
  getNodeType() {
    return this.scope === _ViewportNode.COORDINATE || this.scope === _ViewportNode.VIEWPORT ? "vec4" : "vec2";
  }
  getUpdateType() {
    let updateType = NodeUpdateType.NONE;
    if (this.scope === _ViewportNode.RESOLUTION || this.scope === _ViewportNode.VIEWPORT) {
      updateType = NodeUpdateType.FRAME;
    }
    this.updateType = updateType;
    return updateType;
  }
  update({ renderer }) {
    if (this.scope === _ViewportNode.VIEWPORT) {
      renderer.getViewport(viewportResult);
    } else {
      renderer.getDrawingBufferSize(resolution);
    }
  }
  construct(builder) {
    const scope = this.scope;
    if (scope === _ViewportNode.COORDINATE)
      return;
    let output2 = null;
    if (scope === _ViewportNode.RESOLUTION) {
      output2 = uniform(resolution || (resolution = new Vector2()));
    } else if (scope === _ViewportNode.VIEWPORT) {
      output2 = uniform(viewportResult || (viewportResult = new Vector4()));
    } else {
      const coordinateNode = vec2(new _ViewportNode(_ViewportNode.COORDINATE));
      const resolutionNode = new _ViewportNode(_ViewportNode.RESOLUTION);
      output2 = coordinateNode.div(resolutionNode);
      let outX = output2.x;
      let outY = output2.y;
      if (/top/i.test(scope) && builder.isFlipY())
        outY = outY.oneMinus();
      else if (/bottom/i.test(scope) && builder.isFlipY() === false)
        outY = outY.oneMinus();
      if (/right/i.test(scope))
        outX = outX.oneMinus();
      output2 = vec2(outX, outY);
    }
    return output2;
  }
  generate(builder) {
    if (this.scope === _ViewportNode.COORDINATE) {
      return builder.getFragCoord();
    }
    return super.generate(builder);
  }
};
ViewportNode.COORDINATE = "coordinate";
ViewportNode.RESOLUTION = "resolution";
ViewportNode.VIEWPORT = "viewport";
ViewportNode.TOP_LEFT = "topLeft";
ViewportNode.BOTTOM_LEFT = "bottomLeft";
ViewportNode.TOP_RIGHT = "topRight";
ViewportNode.BOTTOM_RIGHT = "bottomRight";
var ViewportNode_default = ViewportNode;
var viewportCoordinate = nodeImmutable(ViewportNode, ViewportNode.COORDINATE);
var viewportResolution = nodeImmutable(ViewportNode, ViewportNode.RESOLUTION);
var viewport = nodeImmutable(ViewportNode, ViewportNode.VIEWPORT);
var viewportTopLeft = nodeImmutable(ViewportNode, ViewportNode.TOP_LEFT);
var viewportBottomLeft = nodeImmutable(ViewportNode, ViewportNode.BOTTOM_LEFT);
var viewportTopRight = nodeImmutable(ViewportNode, ViewportNode.TOP_RIGHT);
var viewportBottomRight = nodeImmutable(ViewportNode, ViewportNode.BOTTOM_RIGHT);
addNodeClass(ViewportNode);

// node_modules/three/examples/jsm/nodes/display/ViewportTextureNode.js
var _size = new Vector2();
var ViewportTextureNode = class extends TextureNode_default {
  constructor(uvNode = viewportTopLeft, levelNode = null, framebufferTexture = null) {
    if (framebufferTexture === null) {
      framebufferTexture = new FramebufferTexture();
      framebufferTexture.minFilter = LinearMipmapLinearFilter;
    }
    super(framebufferTexture, uvNode, levelNode);
    this.generateMipmaps = false;
    this.isOutputTextureNode = true;
    this.updateBeforeType = NodeUpdateType.FRAME;
  }
  updateBefore(frame) {
    const renderer = frame.renderer;
    renderer.getDrawingBufferSize(_size);
    const framebufferTexture = this.value;
    if (framebufferTexture.image.width !== _size.width || framebufferTexture.image.height !== _size.height) {
      framebufferTexture.image.width = _size.width;
      framebufferTexture.image.height = _size.height;
      framebufferTexture.needsUpdate = true;
    }
    const currentGenerateMipmaps = framebufferTexture.generateMipmaps;
    framebufferTexture.generateMipmaps = this.generateMipmaps;
    renderer.copyFramebufferToTexture(framebufferTexture);
    framebufferTexture.generateMipmaps = currentGenerateMipmaps;
  }
  clone() {
    return new this.constructor(this.uvNode, this.levelNode, this.value);
  }
};
var ViewportTextureNode_default = ViewportTextureNode;
var viewportTexture = nodeProxy(ViewportTextureNode);
var viewportMipTexture = nodeProxy(ViewportTextureNode, null, null, { generateMipmaps: true });
addNodeElement("viewportTexture", viewportTexture);
addNodeElement("viewportMipTexture", viewportMipTexture);
addNodeClass(ViewportTextureNode);

// node_modules/three/examples/jsm/nodes/display/ViewportSharedTextureNode.js
var sharedFramebuffer = null;
var ViewportSharedTextureNode = class extends ViewportTextureNode_default {
  constructor(uvNode = viewportTopLeft, levelNode = null) {
    if (sharedFramebuffer === null) {
      sharedFramebuffer = new FramebufferTexture();
    }
    super(uvNode, levelNode, sharedFramebuffer);
  }
};
var ViewportSharedTextureNode_default = ViewportSharedTextureNode;
var viewportSharedTexture = nodeProxy(ViewportSharedTextureNode);
addNodeElement("viewportSharedTexture", viewportSharedTexture);
addNodeClass(ViewportSharedTextureNode);

// node_modules/three/examples/jsm/nodes/display/ViewportDepthTextureNode.js
var sharedDepthbuffer = null;
var ViewportDepthTextureNode = class extends ViewportTextureNode_default {
  constructor(uvNode = viewportTopLeft, levelNode = null) {
    if (sharedDepthbuffer === null) {
      sharedDepthbuffer = new DepthTexture();
      sharedDepthbuffer.minFilter = LinearMipmapLinearFilter;
      sharedDepthbuffer.type = UnsignedIntType;
      sharedDepthbuffer.format = DepthFormat;
    }
    super(uvNode, levelNode, sharedDepthbuffer);
  }
};
var ViewportDepthTextureNode_default = ViewportDepthTextureNode;
var viewportDepthTexture = nodeProxy(ViewportDepthTextureNode);
addNodeElement("viewportDepthTexture", viewportDepthTexture);
addNodeClass(ViewportDepthTextureNode);

// node_modules/three/examples/jsm/nodes/display/ViewportDepthNode.js
var ViewportDepthNode = class _ViewportDepthNode extends Node_default {
  constructor(scope, textureNode = null) {
    super("float");
    this.scope = scope;
    this.textureNode = textureNode;
    this.isViewportDepthNode = true;
  }
  construct() {
    const { scope } = this;
    let node = null;
    if (scope === _ViewportDepthNode.DEPTH) {
      node = viewZToOrthographicDepth(positionView.z, cameraNear, cameraFar);
    } else if (scope === _ViewportDepthNode.DEPTH_TEXTURE) {
      const texture2 = this.textureNode || viewportDepthTexture();
      const viewZ = perspectiveDepthToViewZ(texture2, cameraNear, cameraFar);
      node = viewZToOrthographicDepth(viewZ, cameraNear, cameraFar);
    }
    return node;
  }
};
var viewZToOrthographicDepth = (viewZ, near, far) => viewZ.add(near).div(near.sub(far));
var orthographicDepthToViewZ = (depth2, near, far) => near.sub(far).mul(depth2).sub(near);
var viewZToPerspectiveDepth = (viewZ, near, far) => near.add(viewZ).mul(far).div(near.sub(far).mul(viewZ));
var perspectiveDepthToViewZ = (depth2, near, far) => near.mul(far).div(far.sub(near).mul(depth2).sub(far));
ViewportDepthNode.DEPTH = "depth";
ViewportDepthNode.DEPTH_TEXTURE = "depthTexture";
var ViewportDepthNode_default = ViewportDepthNode;
var depth = nodeImmutable(ViewportDepthNode, ViewportDepthNode.DEPTH);
var depthTexture = nodeProxy(ViewportDepthNode, ViewportDepthNode.DEPTH_TEXTURE);
addNodeClass(ViewportDepthNode);

// node_modules/three/examples/jsm/nodes/code/CodeNode.js
var CodeNode = class extends Node_default {
  constructor(code2 = "", includes3 = [], language = "") {
    super("code");
    this.isCodeNode = true;
    this.code = code2;
    this.language = language;
    this._includes = includes3;
  }
  setIncludes(includes3) {
    this._includes = includes3;
    return this;
  }
  getIncludes() {
    return this._includes;
  }
  generate(builder) {
    const includes3 = this.getIncludes(builder);
    for (const include of includes3) {
      include.build(builder);
    }
    const nodeCode = builder.getCodeFromNode(this, this.getNodeType(builder));
    nodeCode.code = this.code;
    return nodeCode.code;
  }
  serialize(data) {
    super.serialize(data);
    data.code = this.code;
    data.language = this.language;
  }
  deserialize(data) {
    super.deserialize(data);
    this.code = data.code;
    this.language = data.language;
  }
};
var CodeNode_default = CodeNode;
var code = nodeProxy(CodeNode);
var js = (src, includes3) => code(src, includes3, "js");
var wgsl = (src, includes3) => code(src, includes3, "wgsl");
var glsl = (src, includes3) => code(src, includes3, "glsl");
addNodeClass(CodeNode);

// node_modules/three/examples/jsm/nodes/code/FunctionCallNode.js
var FunctionCallNode = class extends TempNode_default {
  constructor(functionNode = null, parameters = {}) {
    super();
    this.functionNode = functionNode;
    this.parameters = parameters;
  }
  setParameters(parameters) {
    this.parameters = parameters;
    return this;
  }
  getParameters() {
    return this.parameters;
  }
  getNodeType(builder) {
    return this.functionNode.getNodeType(builder);
  }
  generate(builder) {
    const params = [];
    const functionNode = this.functionNode;
    const inputs = functionNode.getInputs(builder);
    const parameters = this.parameters;
    if (Array.isArray(parameters)) {
      for (let i = 0; i < parameters.length; i++) {
        const inputNode = inputs[i];
        const node = parameters[i];
        params.push(node.build(builder, inputNode.type));
      }
    } else {
      for (const inputNode of inputs) {
        const node = parameters[inputNode.name];
        if (node !== void 0) {
          params.push(node.build(builder, inputNode.type));
        } else {
          throw new Error(`FunctionCallNode: Input '${inputNode.name}' not found in FunctionNode.`);
        }
      }
    }
    const functionName = functionNode.build(builder, "property");
    return `${functionName}( ${params.join(", ")} )`;
  }
};
var FunctionCallNode_default = FunctionCallNode;
var call = (func, ...params) => {
  params = params.length > 1 || params[0] && params[0].isNode === true ? nodeArray(params) : nodeObjects(params[0]);
  return nodeObject(new FunctionCallNode(nodeObject(func), params));
};
addNodeElement("call", call);
addNodeClass(FunctionCallNode);

// node_modules/three/examples/jsm/nodes/code/FunctionNode.js
var FunctionNode = class extends CodeNode_default {
  constructor(code2 = "", includes3 = [], language = "") {
    super(code2, includes3, language);
    this.keywords = {};
  }
  getNodeType(builder) {
    return this.getNodeFunction(builder).type;
  }
  getInputs(builder) {
    return this.getNodeFunction(builder).inputs;
  }
  getNodeFunction(builder) {
    const nodeData = builder.getDataFromNode(this);
    let nodeFunction = nodeData.nodeFunction;
    if (nodeFunction === void 0) {
      nodeFunction = builder.parser.parseFunction(this.code);
      nodeData.nodeFunction = nodeFunction;
    }
    return nodeFunction;
  }
  generate(builder, output2) {
    super.generate(builder);
    const nodeFunction = this.getNodeFunction(builder);
    const name = nodeFunction.name;
    const type = nodeFunction.type;
    const nodeCode = builder.getCodeFromNode(this, type);
    if (name !== "") {
      nodeCode.name = name;
    }
    const propertyName = builder.getPropertyName(nodeCode);
    let code2 = this.getNodeFunction(builder).getCode(propertyName);
    const keywords = this.keywords;
    const keywordsProperties = Object.keys(keywords);
    if (keywordsProperties.length > 0) {
      for (const property2 of keywordsProperties) {
        const propertyRegExp = new RegExp(`\\b${property2}\\b`, "g");
        const nodeProperty = keywords[property2].build(builder, "property");
        code2 = code2.replace(propertyRegExp, nodeProperty);
      }
    }
    nodeCode.code = code2;
    if (output2 === "property") {
      return propertyName;
    } else {
      return builder.format(`${propertyName}()`, type, output2);
    }
  }
};
var FunctionNode_default = FunctionNode;
var nativeFn = (code2, includes3, language = "") => {
  let functionNode = null;
  return (...params) => {
    if (functionNode === null)
      functionNode = nodeObject(new FunctionNode(code2, includes3, language));
    return functionNode.call(...params);
  };
};
var glslFn = (code2, includes3) => nativeFn(code2, includes3, "glsl");
var wgslFn = (code2, includes3) => nativeFn(code2, includes3, "wgsl");
addNodeClass(FunctionNode);

// node_modules/three/examples/jsm/nodes/code/ScriptableValueNode.js
var ScriptableValueNode = class extends Node_default {
  constructor(value = null) {
    super();
    this._value = value;
    this._cache = null;
    this.inputType = null;
    this.outpuType = null;
    this.events = new EventDispatcher();
    this.isScriptableValueNode = true;
  }
  get isScriptableOutputNode() {
    return this.outputType !== null;
  }
  set value(val) {
    if (this._value === val)
      return;
    if (this._cache && this.inputType === "URL" && this.value.value instanceof ArrayBuffer) {
      URL.revokeObjectURL(this._cache);
      this._cache = null;
    }
    this._value = val;
    this.events.dispatchEvent({ type: "change" });
    this.refresh();
  }
  get value() {
    return this._value;
  }
  refresh() {
    this.events.dispatchEvent({ type: "refresh" });
  }
  getValue() {
    const value = this.value;
    if (value && this._cache === null && this.inputType === "URL" && value.value instanceof ArrayBuffer) {
      this._cache = URL.createObjectURL(new Blob([value.value]));
    } else if (value && value.value !== null && value.value !== void 0 && ((this.inputType === "URL" || this.inputType === "String") && typeof value.value === "string" || this.inputType === "Number" && typeof value.value === "number" || this.inputType === "Vector2" && value.value.isVector2 || this.inputType === "Vector3" && value.value.isVector3 || this.inputType === "Vector4" && value.value.isVector4 || this.inputType === "Color" && value.value.isColor || this.inputType === "Matrix3" && value.value.isMatrix3 || this.inputType === "Matrix4" && value.value.isMatrix4)) {
      return value.value;
    }
    return this._cache || value;
  }
  getNodeType(builder) {
    return this.value && this.value.isNode ? this.value.getNodeType(builder) : "float";
  }
  construct() {
    return this.value && this.value.isNode ? this.value : float();
  }
  serialize(data) {
    super.serialize(data);
    if (this.value !== null) {
      if (this.inputType === "ArrayBuffer") {
        data.value = arrayBufferToBase64(this.value);
      } else {
        data.value = this.value ? this.value.toJSON(data.meta).uuid : null;
      }
    } else {
      data.value = null;
    }
    data.inputType = this.inputType;
    data.outputType = this.outputType;
  }
  deserialize(data) {
    super.deserialize(data);
    let value = null;
    if (data.value !== null) {
      if (data.inputType === "ArrayBuffer") {
        value = base64ToArrayBuffer(data.value);
      } else if (data.inputType === "Texture") {
        value = data.meta.textures[data.value];
      } else {
        value = data.meta.nodes[data.value] || null;
      }
    }
    this.value = value;
    this.inputType = data.inputType;
    this.outputType = data.outputType;
  }
};
var ScriptableValueNode_default = ScriptableValueNode;
var scriptableValue = nodeProxy(ScriptableValueNode);
addNodeElement("scriptableValue", scriptableValue);
addNodeClass(ScriptableValueNode);

// node_modules/three/examples/jsm/nodes/code/ScriptableNode.js
var Resources = class extends Map {
  get(key, callback = null, ...params) {
    if (this.has(key))
      return super.get(key);
    if (callback !== null) {
      const value = callback(...params);
      this.set(key, value);
      return value;
    }
  }
};
var Parameters = class {
  constructor(scriptableNode) {
    this.scriptableNode = scriptableNode;
  }
  get parameters() {
    return this.scriptableNode.parameters;
  }
  get layout() {
    return this.scriptableNode.getLayout();
  }
  getInputLayout(id2) {
    return this.scriptableNode.getInputLayout(id2);
  }
  get(name) {
    const param = this.parameters[name];
    const value = param ? param.getValue() : null;
    return value;
  }
};
var global = new Resources();
var ScriptableNode = class extends Node_default {
  constructor(codeNode = null, parameters = {}) {
    super();
    this.codeNode = codeNode;
    this.parameters = parameters;
    this._local = new Resources();
    this._output = scriptableValue();
    this._outputs = {};
    this._source = this.source;
    this._method = null;
    this._object = null;
    this._value = null;
    this._needsOutputUpdate = true;
    this.onRefresh = this.onRefresh.bind(this);
    this.isScriptableNode = true;
  }
  get source() {
    return this.codeNode ? this.codeNode.code : "";
  }
  setLocal(name, value) {
    return this._local.set(name, value);
  }
  getLocal(name) {
    return this._local.get(name);
  }
  onRefresh() {
    this._refresh();
  }
  getInputLayout(id2) {
    for (const element2 of this.getLayout()) {
      if (element2.inputType && (element2.id === id2 || element2.name === id2)) {
        return element2;
      }
    }
  }
  getOutputLayout(id2) {
    for (const element2 of this.getLayout()) {
      if (element2.outputType && (element2.id === id2 || element2.name === id2)) {
        return element2;
      }
    }
  }
  setOutput(name, value) {
    const outputs = this._outputs;
    if (outputs[name] === void 0) {
      outputs[name] = scriptableValue(value);
    } else {
      outputs[name].value = value;
    }
    return this;
  }
  getOutput(name) {
    return this._outputs[name];
  }
  getParameter(name) {
    return this.parameters[name];
  }
  setParameter(name, value) {
    const parameters = this.parameters;
    if (value && value.isScriptableNode) {
      this.deleteParameter(name);
      parameters[name] = value;
      parameters[name].getDefaultOutput().events.addEventListener("refresh", this.onRefresh);
    } else if (value && value.isScriptableValueNode) {
      this.deleteParameter(name);
      parameters[name] = value;
      parameters[name].events.addEventListener("refresh", this.onRefresh);
    } else if (parameters[name] === void 0) {
      parameters[name] = scriptableValue(value);
      parameters[name].events.addEventListener("refresh", this.onRefresh);
    } else {
      parameters[name].value = value;
    }
    return this;
  }
  getValue() {
    return this.getDefaultOutput().getValue();
  }
  deleteParameter(name) {
    let valueNode = this.parameters[name];
    if (valueNode) {
      if (valueNode.isScriptableNode)
        valueNode = valueNode.getDefaultOutput();
      valueNode.events.removeEventListener("refresh", this.onRefresh);
    }
    return this;
  }
  clearParameters() {
    for (const name of Object.keys(this.parameters)) {
      this.deleteParameter(name);
    }
    this.needsUpdate = true;
    return this;
  }
  call(name, ...params) {
    const object = this.getObject();
    const method = object[name];
    if (typeof method === "function") {
      return method(...params);
    }
  }
  async callAsync(name, ...params) {
    const object = this.getObject();
    const method = object[name];
    if (typeof method === "function") {
      return method.constructor.name === "AsyncFunction" ? await method(...params) : method(...params);
    }
  }
  getNodeType(builder) {
    return this.getDefaultOutputNode().getNodeType(builder);
  }
  refresh(output2 = null) {
    if (output2 !== null) {
      this.getOutput(output2).refresh();
    } else {
      this._refresh();
    }
  }
  getObject() {
    if (this.needsUpdate)
      this.dispose();
    if (this._object !== null)
      return this._object;
    const refresh = () => this.refresh();
    const setOutput = (id2, value) => this.setOutput(id2, value);
    const parameters = new Parameters(this);
    const THREE = global.get("THREE");
    const TSL = global.get("TSL");
    const method = this.getMethod(this.codeNode);
    const params = [parameters, this._local, global, refresh, setOutput, THREE, TSL];
    this._object = method(...params);
    const layout = this._object.layout;
    if (layout) {
      if (layout.cache === false) {
        this._local.clear();
      }
      this._output.outputType = layout.outputType || null;
      if (Array.isArray(layout.elements)) {
        for (const element2 of layout.elements) {
          const id2 = element2.id || element2.name;
          if (element2.inputType) {
            if (this.getParameter(id2) === void 0)
              this.setParameter(id2, null);
            this.getParameter(id2).inputType = element2.inputType;
          }
          if (element2.outputType) {
            if (this.getOutput(id2) === void 0)
              this.setOutput(id2, null);
            this.getOutput(id2).outputType = element2.outputType;
          }
        }
      }
    }
    return this._object;
  }
  deserialize(data) {
    super.deserialize(data);
    for (const name in this.parameters) {
      let valueNode = this.parameters[name];
      if (valueNode.isScriptableNode)
        valueNode = valueNode.getDefaultOutput();
      valueNode.events.addEventListener("refresh", this.onRefresh);
    }
  }
  getLayout() {
    return this.getObject().layout;
  }
  getDefaultOutputNode() {
    const output2 = this.getDefaultOutput().value;
    if (output2 && output2.isNode) {
      return output2;
    }
    return float();
  }
  getDefaultOutput() {
    return this._exec()._output;
  }
  getMethod() {
    if (this.needsUpdate)
      this.dispose();
    if (this._method !== null)
      return this._method;
    const parametersProps = ["parameters", "local", "global", "refresh", "setOutput", "THREE", "TSL"];
    const interfaceProps = ["layout", "init", "main", "dispose"];
    const properties = interfaceProps.join(", ");
    const declarations = "var " + properties + "; var output = {};\n";
    const returns = "\nreturn { ...output, " + properties + " };";
    const code2 = declarations + this.codeNode.code + returns;
    this._method = new Function(...parametersProps, code2);
    return this._method;
  }
  dispose() {
    if (this._method === null)
      return;
    if (this._object && typeof this._object.dispose === "function") {
      this._object.dispose();
    }
    this._method = null;
    this._object = null;
    this._source = null;
    this._value = null;
    this._needsOutputUpdate = true;
    this._output.value = null;
    this._outputs = {};
  }
  construct() {
    return this.getDefaultOutputNode();
  }
  set needsUpdate(value) {
    if (value === true)
      this.dispose();
  }
  get needsUpdate() {
    return this.source !== this._source;
  }
  _exec() {
    if (this.codeNode === null)
      return this;
    if (this._needsOutputUpdate === true) {
      this._value = this.call("main");
      this._needsOutputUpdate = false;
    }
    this._output.value = this._value;
    return this;
  }
  _refresh() {
    this.needsUpdate = true;
    this._exec();
    this._output.refresh();
  }
};
var ScriptableNode_default = ScriptableNode;
var scriptable = nodeProxy(ScriptableNode);
addNodeElement("scriptable", scriptable);
addNodeClass(ScriptableNode);

// node_modules/three/examples/jsm/nodes/fog/FogNode.js
var FogNode = class extends Node_default {
  constructor(colorNode, factorNode) {
    super("float");
    this.isFogNode = true;
    this.colorNode = colorNode;
    this.factorNode = factorNode;
  }
  mixAssign(outputNode) {
    return this.mix(outputNode, this.colorNode);
  }
  construct() {
    return this.factorNode;
  }
};
var FogNode_default = FogNode;
var fog = nodeProxy(FogNode);
addNodeElement("fog", fog);
addNodeClass(FogNode);

// node_modules/three/examples/jsm/nodes/fog/FogRangeNode.js
var FogRangeNode = class extends FogNode_default {
  constructor(colorNode, nearNode, farNode) {
    super(colorNode);
    this.isFogRangeNode = true;
    this.nearNode = nearNode;
    this.farNode = farNode;
  }
  construct() {
    return smoothstep(this.nearNode, this.farNode, positionView.z.negate());
  }
};
var FogRangeNode_default = FogRangeNode;
var rangeFog = nodeProxy(FogRangeNode);
addNodeElement("rangeFog", rangeFog);
addNodeClass(FogRangeNode);

// node_modules/three/examples/jsm/nodes/fog/FogExp2Node.js
var FogExp2Node = class extends FogNode_default {
  constructor(colorNode, densityNode) {
    super(colorNode);
    this.isFogExp2Node = true;
    this.densityNode = densityNode;
  }
  construct() {
    const depthNode = positionView.z.negate();
    const densityNode = this.densityNode;
    return densityNode.mul(densityNode, depthNode, depthNode).negate().exp().oneMinus();
  }
};
var FogExp2Node_default = FogExp2Node;
var densityFog = nodeProxy(FogExp2Node);
addNodeElement("densityFog", densityFog);
addNodeClass(FogExp2Node);

// node_modules/three/examples/jsm/nodes/geometry/RangeNode.js
var min2 = null;
var max2 = null;
var RangeNode = class extends Node_default {
  constructor(minNode = float(), maxNode = float()) {
    super();
    this.minNode = minNode;
    this.maxNode = maxNode;
  }
  getVectorLength(builder) {
    const minLength = builder.getTypeLength(getValueType(this.minNode.value));
    const maxLength = builder.getTypeLength(getValueType(this.maxNode.value));
    return minLength > maxLength ? minLength : maxLength;
  }
  getNodeType(builder) {
    return builder.object.isInstancedMesh === true ? builder.getTypeFromLength(this.getVectorLength(builder)) : "float";
  }
  construct(builder) {
    const object = builder.object;
    let output2 = null;
    if (object.isInstancedMesh === true) {
      const minValue = this.minNode.value;
      const maxValue = this.maxNode.value;
      const minLength = builder.getTypeLength(getValueType(minValue));
      const maxLength = builder.getTypeLength(getValueType(maxValue));
      min2 = min2 || new Vector4();
      max2 = max2 || new Vector4();
      min2.setScalar(0);
      max2.setScalar(0);
      if (minLength === 1)
        min2.setScalar(minValue);
      else if (minValue.isColor)
        min2.set(minValue.r, minValue.g, minValue.b);
      else
        min2.set(minValue.x, minValue.y, minValue.z || 0, minValue.w || 0);
      if (maxLength === 1)
        max2.setScalar(maxValue);
      else if (maxValue.isColor)
        max2.set(maxValue.r, maxValue.g, maxValue.b);
      else
        max2.set(maxValue.x, maxValue.y, maxValue.z || 0, maxValue.w || 0);
      const stride = 4;
      const length2 = stride * object.count;
      const array = new Float32Array(length2);
      for (let i = 0; i < length2; i++) {
        const index = i % stride;
        const minElementValue = min2.getComponent(index);
        const maxElementValue = max2.getComponent(index);
        array[i] = MathUtils.lerp(minElementValue, maxElementValue, Math.random());
      }
      const nodeType = this.getNodeType(builder);
      output2 = buffer(array, "vec4", object.count).element(instanceIndex).convert(nodeType);
    } else {
      output2 = float(0);
    }
    return output2;
  }
};
var RangeNode_default = RangeNode;
var range = nodeProxy(RangeNode);
addNodeClass(RangeNode);

// node_modules/three/examples/jsm/nodes/gpgpu/ComputeNode.js
var ComputeNode = class extends Node_default {
  constructor(computeNode, count, workgroupSize = [64]) {
    super("void");
    this.isComputeNode = true;
    this.computeNode = computeNode;
    this.count = count;
    this.workgroupSize = workgroupSize;
    this.dispatchCount = 0;
    this.version = 1;
    this.updateType = NodeUpdateType.OBJECT;
    this.updateDispatchCount();
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(value) {
    if (value === true)
      this.version++;
  }
  updateDispatchCount() {
    const { count, workgroupSize } = this;
    let size = workgroupSize[0];
    for (let i = 1; i < workgroupSize.length; i++)
      size *= workgroupSize[i];
    this.dispatchCount = Math.ceil(count / size);
  }
  onInit() {
  }
  update({ renderer }) {
    renderer.compute(this);
  }
  generate(builder) {
    const { shaderStage } = builder;
    if (shaderStage === "compute") {
      const snippet = this.computeNode.build(builder, "void");
      if (snippet !== "") {
        builder.addLineFlowCode(snippet);
      }
    }
  }
};
var ComputeNode_default = ComputeNode;
var compute = (node, count, workgroupSize) => nodeObject(new ComputeNode(nodeObject(node), count, workgroupSize));
addNodeElement("compute", compute);
addNodeClass(ComputeNode);

// node_modules/three/examples/jsm/nodes/lighting/LightNode.js
var LightNode = class _LightNode extends Node_default {
  constructor(scope = _LightNode.TARGET_DIRECTION, light = null) {
    super();
    this.scope = scope;
    this.light = light;
  }
  construct() {
    const { scope, light } = this;
    let output2 = null;
    if (scope === _LightNode.TARGET_DIRECTION) {
      output2 = cameraViewMatrix.transformDirection(objectPosition(light).sub(objectPosition(light.target)));
    }
    return output2;
  }
  serialize(data) {
    super.serialize(data);
    data.scope = this.scope;
  }
  deserialize(data) {
    super.deserialize(data);
    this.scope = data.scope;
  }
};
LightNode.TARGET_DIRECTION = "targetDirection";
var LightNode_default = LightNode;
var lightTargetDirection = nodeProxy(LightNode, LightNode.TARGET_DIRECTION);
addNodeClass(LightNode);

// node_modules/three/examples/jsm/nodes/lighting/LightUtils.js
var getDistanceAttenuation = tslFn((inputs) => {
  const { lightDistance, cutoffDistance, decayExponent } = inputs;
  const distanceFalloff = lightDistance.pow(decayExponent).max(0.01).reciprocal();
  return cutoffDistance.greaterThan(0).cond(
    distanceFalloff.mul(lightDistance.div(cutoffDistance).pow4().oneMinus().clamp().pow2()),
    distanceFalloff
  );
});

// node_modules/three/examples/jsm/nodes/lighting/PointLightNode.js
var PointLightNode = class extends AnalyticLightNode_default {
  constructor(light = null) {
    super(light);
    this.cutoffDistanceNode = uniform(0);
    this.decayExponentNode = uniform(0);
  }
  update(frame) {
    const { light } = this;
    super.update(frame);
    this.cutoffDistanceNode.value = light.distance;
    this.decayExponentNode.value = light.decay;
  }
  construct(builder) {
    const { colorNode, cutoffDistanceNode, decayExponentNode, light } = this;
    const lightingModel = builder.context.lightingModel;
    const lVector = objectViewPosition(light).sub(positionView);
    const lightDirection = lVector.normalize();
    const lightDistance = lVector.length();
    const lightAttenuation = getDistanceAttenuation({
      lightDistance,
      cutoffDistance: cutoffDistanceNode,
      decayExponent: decayExponentNode
    });
    const lightColor = colorNode.mul(lightAttenuation);
    const reflectedLight = builder.context.reflectedLight;
    lightingModel.direct({
      lightDirection,
      lightColor,
      reflectedLight
    });
  }
};
var PointLightNode_default = PointLightNode;
addLightNode(PointLight, PointLightNode);
addNodeClass(PointLightNode);

// node_modules/three/examples/jsm/nodes/lighting/DirectionalLightNode.js
var DirectionalLightNode = class extends AnalyticLightNode_default {
  constructor(light = null) {
    super(light);
  }
  construct(builder) {
    super.construct(builder);
    const lightingModel = builder.context.lightingModel;
    const lightColor = this.colorNode;
    const lightDirection = lightTargetDirection(this.light);
    const reflectedLight = builder.context.reflectedLight;
    lightingModel.direct({
      lightDirection,
      lightColor,
      reflectedLight
    });
  }
};
var DirectionalLightNode_default = DirectionalLightNode;
addLightNode(DirectionalLight, DirectionalLightNode);
addNodeClass(DirectionalLightNode);

// node_modules/three/examples/jsm/nodes/lighting/SpotLightNode.js
var SpotLightNode = class extends AnalyticLightNode_default {
  constructor(light = null) {
    super(light);
    this.coneCosNode = uniform(0);
    this.penumbraCosNode = uniform(0);
    this.cutoffDistanceNode = uniform(0);
    this.decayExponentNode = uniform(0);
  }
  update(frame) {
    super.update(frame);
    const { light } = this;
    this.coneCosNode.value = Math.cos(light.angle);
    this.penumbraCosNode.value = Math.cos(light.angle * (1 - light.penumbra));
    this.cutoffDistanceNode.value = light.distance;
    this.decayExponentNode.value = light.decay;
  }
  getSpotAttenuation(angleCosine) {
    const { coneCosNode, penumbraCosNode } = this;
    return smoothstep(coneCosNode, penumbraCosNode, angleCosine);
  }
  construct(builder) {
    super.construct(builder);
    const lightingModel = builder.context.lightingModel;
    const { colorNode, cutoffDistanceNode, decayExponentNode, light } = this;
    const lVector = objectViewPosition(light).sub(positionView);
    const lightDirection = lVector.normalize();
    const angleCos = lightDirection.dot(lightTargetDirection(light));
    const spotAttenuation = this.getSpotAttenuation(angleCos);
    const lightDistance = lVector.length();
    const lightAttenuation = getDistanceAttenuation({
      lightDistance,
      cutoffDistance: cutoffDistanceNode,
      decayExponent: decayExponentNode
    });
    const lightColor = colorNode.mul(spotAttenuation).mul(lightAttenuation);
    const reflectedLight = builder.context.reflectedLight;
    lightingModel.direct({
      lightDirection,
      lightColor,
      reflectedLight
    });
  }
};
var SpotLightNode_default = SpotLightNode;
addLightNode(SpotLight, SpotLightNode);
addNodeClass(SpotLightNode);

// node_modules/three/examples/jsm/lights/IESSpotLight.js
var IESSpotLight = class extends SpotLight {
  constructor(color2, intensity, distance2, angle, penumbra, decay) {
    super(color2, intensity, distance2, angle, penumbra, decay);
    this.iesMap = null;
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.iesMap = source.iesMap;
    return this;
  }
};
var IESSpotLight_default = IESSpotLight;

// node_modules/three/examples/jsm/nodes/lighting/IESSpotLightNode.js
var IESSpotLightNode = class extends SpotLightNode_default {
  getSpotAttenuation(angleCosine) {
    const iesMap = this.light.iesMap;
    let spotAttenuation = null;
    if (iesMap && iesMap.isTexture === true) {
      const angle = angleCosine.acos().mul(1 / Math.PI);
      spotAttenuation = texture(iesMap, vec2(angle, 0), 0).r;
    } else {
      spotAttenuation = super.getSpotAttenuation(angleCosine);
    }
    return spotAttenuation;
  }
};
var IESSpotLightNode_default = IESSpotLightNode;
addLightNode(IESSpotLight_default, IESSpotLightNode);
addNodeClass(IESSpotLightNode);

// node_modules/three/examples/jsm/nodes/lighting/AmbientLightNode.js
var AmbientLightNode = class extends AnalyticLightNode_default {
  constructor(light = null) {
    super(light);
  }
  construct({ context: context2 }) {
    context2.irradiance.addAssign(this.colorNode);
  }
};
var AmbientLightNode_default = AmbientLightNode;
addLightNode(AmbientLight, AmbientLightNode);
addNodeClass(AmbientLightNode);

// node_modules/three/examples/jsm/nodes/lighting/HemisphereLightNode.js
var HemisphereLightNode = class extends AnalyticLightNode_default {
  constructor(light = null) {
    super(light);
    this.lightPositionNode = objectPosition(light);
    this.lightDirectionNode = this.lightPositionNode.normalize();
    this.groundColorNode = uniform(new Color());
  }
  update(frame) {
    const { light } = this;
    super.update(frame);
    this.lightPositionNode.object3d = light;
    this.groundColorNode.value.copy(light.groundColor).multiplyScalar(light.intensity);
  }
  construct(builder) {
    const { colorNode, groundColorNode, lightDirectionNode } = this;
    const dotNL = normalView.dot(lightDirectionNode);
    const hemiDiffuseWeight = dotNL.mul(0.5).add(0.5);
    const irradiance = mix(groundColorNode, colorNode, hemiDiffuseWeight);
    builder.context.irradiance.addAssign(irradiance);
  }
};
var HemisphereLightNode_default = HemisphereLightNode;
addLightNode(HemisphereLight, HemisphereLightNode);
addNodeClass(HemisphereLightNode);

// node_modules/three/examples/jsm/nodes/procedural/CheckerNode.js
var checkerShaderNode = tslFn((inputs) => {
  const uv2 = inputs.uv.mul(2);
  const cx = uv2.x.floor();
  const cy = uv2.y.floor();
  const result = cx.add(cy).mod(2);
  return result.sign();
});
var CheckerNode = class extends TempNode_default {
  constructor(uvNode = uv()) {
    super("float");
    this.uvNode = uvNode;
  }
  generate(builder) {
    return checkerShaderNode({ uv: this.uvNode }).build(builder);
  }
};
var CheckerNode_default = CheckerNode;
var checker = nodeProxy(CheckerNode);
addNodeElement("checker", checker);
addNodeClass(CheckerNode);

// node_modules/three/examples/jsm/nodes/loaders/NodeLoader.js
var NodeLoader = class extends Loader {
  constructor(manager) {
    super(manager);
    this.textures = {};
  }
  load(url, onLoad, onProgress, onError) {
    const loader = new FileLoader(this.manager);
    loader.setPath(this.path);
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(this.withCredentials);
    loader.load(url, (text) => {
      try {
        onLoad(this.parse(JSON.parse(text)));
      } catch (e) {
        if (onError) {
          onError(e);
        } else {
          console.error(e);
        }
        this.manager.itemError(url);
      }
    }, onProgress, onError);
  }
  parseNodes(json) {
    const nodes = {};
    if (json !== void 0) {
      for (const nodeJSON of json) {
        const { uuid, type } = nodeJSON;
        nodes[uuid] = nodeObject(createNodeFromType(type));
        nodes[uuid].uuid = uuid;
      }
      const meta = { nodes, textures: this.textures };
      for (const nodeJSON of json) {
        nodeJSON.meta = meta;
        const node = nodes[nodeJSON.uuid];
        node.deserialize(nodeJSON);
        delete nodeJSON.meta;
      }
    }
    return nodes;
  }
  parse(json) {
    const node = nodeObject(createNodeFromType(json.type));
    node.uuid = json.uuid;
    const nodes = this.parseNodes(json.nodes);
    const meta = { nodes, textures: this.textures };
    json.meta = meta;
    node.deserialize(json);
    delete json.meta;
    return node;
  }
  setTextures(value) {
    this.textures = value;
    return this;
  }
};
var NodeLoader_default = NodeLoader;

// node_modules/three/examples/jsm/nodes/materials/LineBasicNodeMaterial.js
var defaultValues = new LineBasicMaterial();
var LineBasicNodeMaterial = class extends NodeMaterial_default {
  constructor(parameters) {
    super();
    this.isLineBasicNodeMaterial = true;
    this.lights = false;
    this.normals = false;
    this.setDefaultValues(defaultValues);
    this.setValues(parameters);
  }
};
var LineBasicNodeMaterial_default = LineBasicNodeMaterial;
addNodeMaterial(LineBasicNodeMaterial);

// node_modules/three/examples/jsm/nodes/accessors/LineMaterialNode.js
var LineMaterialNode = class extends MaterialNode_default {
  constructor(scope) {
    super(scope);
  }
  construct(builder) {
    return this.getFloat(builder, this.scope);
  }
};
LineMaterialNode.SCALE = "scale";
LineMaterialNode.DASH_SIZE = "dashSize";
LineMaterialNode.GAP_SIZE = "gapSize";
var materialLineScale = nodeImmutable(LineMaterialNode, LineMaterialNode.SCALE);
var materialLineDashSize = nodeImmutable(LineMaterialNode, LineMaterialNode.DASH_SIZE);
var materialLineGapSize = nodeImmutable(LineMaterialNode, LineMaterialNode.GAP_SIZE);
addNodeClass(LineMaterialNode);

// node_modules/three/examples/jsm/nodes/materials/LineDashedNodeMaterial.js
var defaultValues2 = new LineDashedMaterial();
var LineDashedNodeMaterial = class extends NodeMaterial_default {
  constructor(parameters) {
    super();
    this.isLineDashedNodeMaterial = true;
    this.lights = false;
    this.normals = false;
    this.setDefaultValues(defaultValues2);
    this.offsetNode = null;
    this.dashScaleNode = null;
    this.dashSizeNode = null;
    this.gapSizeNode = null;
    this.setValues(parameters);
  }
  constructVariants({ stack: stack2 }) {
    const offsetNode = this.offsetNode;
    const dashScaleNode = this.dashScaleNode ? float(this.dashScaleNode) : materialLineScale;
    const dashSizeNode = this.dashSizeNode ? float(this.dashSizeNode) : materialLineDashSize;
    const gapSizeNode = this.dashSizeNode ? float(this.dashGapNode) : materialLineGapSize;
    stack2.assign(dashSize, dashSizeNode);
    stack2.assign(gapSize, gapSizeNode);
    const vLineDistance = varying(attribute("lineDistance").mul(dashScaleNode));
    const vLineDistanceOffset = offsetNode ? vLineDistance.add(offsetNode) : vLineDistance;
    stack2.add(vLineDistanceOffset.mod(dashSize.add(gapSize)).greaterThan(dashSize).discard());
  }
};
var LineDashedNodeMaterial_default = LineDashedNodeMaterial;
addNodeMaterial(LineDashedNodeMaterial);

// node_modules/three/examples/jsm/nodes/materials/MeshNormalNodeMaterial.js
var defaultValues3 = new MeshNormalMaterial();
var MeshNormalNodeMaterial = class extends NodeMaterial_default {
  constructor(parameters) {
    super();
    this.isMeshNormalNodeMaterial = true;
    this.colorSpace = false;
    this.setDefaultValues(defaultValues3);
    this.setValues(parameters);
  }
  constructDiffuseColor({ stack: stack2 }) {
    const opacityNode = this.opacityNode ? float(this.opacityNode) : materialOpacity;
    stack2.assign(diffuseColor, vec4(directionToColor(transformedNormalView), opacityNode));
  }
};
var MeshNormalNodeMaterial_default = MeshNormalNodeMaterial;
addNodeMaterial(MeshNormalNodeMaterial);

// node_modules/three/examples/jsm/nodes/materials/MeshBasicNodeMaterial.js
var defaultValues4 = new MeshBasicMaterial();
var MeshBasicNodeMaterial = class extends NodeMaterial_default {
  constructor(parameters) {
    super();
    this.isMeshBasicNodeMaterial = true;
    this.lights = false;
    this.setDefaultValues(defaultValues4);
    this.setValues(parameters);
  }
};
var MeshBasicNodeMaterial_default = MeshBasicNodeMaterial;
addNodeMaterial(MeshBasicNodeMaterial);

// node_modules/three/examples/jsm/nodes/functions/BSDF/F_Schlick.js
var F_Schlick = tslFn(({ f0, f90, dotVH }) => {
  const fresnel = dotVH.mul(-5.55473).sub(6.98316).mul(dotVH).exp2();
  return f0.mul(fresnel.oneMinus()).add(f90.mul(fresnel));
});
var F_Schlick_default = F_Schlick;

// node_modules/three/examples/jsm/nodes/functions/BSDF/BRDF_Lambert.js
var BRDF_Lambert = tslFn((inputs) => {
  return inputs.diffuseColor.mul(1 / Math.PI);
});
var BRDF_Lambert_default = BRDF_Lambert;

// node_modules/three/examples/jsm/nodes/functions/PhongLightingModel.js
var G_BlinnPhong_Implicit = () => float(0.25);
var D_BlinnPhong = tslFn(({ dotNH }) => {
  return shininess.mul(0.5 / Math.PI).add(1).mul(dotNH.pow(shininess));
});
var BRDF_BlinnPhong = tslFn(({ lightDirection }) => {
  const halfDir = lightDirection.add(positionViewDirection).normalize();
  const dotNH = transformedNormalView.dot(halfDir).clamp();
  const dotVH = positionViewDirection.dot(halfDir).clamp();
  const F = F_Schlick_default({ f0: specularColor, f90: 1, dotVH });
  const G = G_BlinnPhong_Implicit();
  const D = D_BlinnPhong({ dotNH });
  return F.mul(G).mul(D);
});
var PhongLightingModel = class extends LightingModel_default {
  constructor(specular = true) {
    super();
    this.specular = specular;
  }
  direct({ lightDirection, lightColor, reflectedLight }) {
    const dotNL = transformedNormalView.dot(lightDirection).clamp();
    const irradiance = dotNL.mul(lightColor);
    reflectedLight.directDiffuse.addAssign(irradiance.mul(BRDF_Lambert_default({ diffuseColor: diffuseColor.rgb })));
    if (this.specular === true) {
      reflectedLight.directSpecular.addAssign(irradiance.mul(BRDF_BlinnPhong({ lightDirection })).mul(materialSpecularStrength));
    }
  }
  indirectDiffuse({ irradiance, reflectedLight }) {
    reflectedLight.indirectDiffuse.addAssign(irradiance.mul(BRDF_Lambert_default({ diffuseColor })));
  }
};
var PhongLightingModel_default = PhongLightingModel;

// node_modules/three/examples/jsm/nodes/materials/MeshLambertNodeMaterial.js
var defaultValues5 = new MeshLambertMaterial();
var MeshLambertNodeMaterial = class extends NodeMaterial_default {
  constructor(parameters) {
    super();
    this.isMeshLambertNodeMaterial = true;
    this.lights = true;
    this.setDefaultValues(defaultValues5);
    this.setValues(parameters);
  }
  constructLightingModel() {
    return new PhongLightingModel_default(false);
  }
};
var MeshLambertNodeMaterial_default = MeshLambertNodeMaterial;
addNodeMaterial(MeshLambertNodeMaterial);

// node_modules/three/examples/jsm/nodes/materials/MeshPhongNodeMaterial.js
var defaultValues6 = new MeshPhongMaterial();
var MeshPhongNodeMaterial = class extends NodeMaterial_default {
  constructor(parameters) {
    super();
    this.isMeshPhongNodeMaterial = true;
    this.lights = true;
    this.shininessNode = null;
    this.specularNode = null;
    this.setDefaultValues(defaultValues6);
    this.setValues(parameters);
  }
  constructLightingModel() {
    return new PhongLightingModel_default();
  }
  constructVariants({ stack: stack2 }) {
    const shininessNode = (this.shininessNode ? float(this.shininessNode) : materialShininess).max(1e-4);
    stack2.assign(shininess, shininessNode);
    const specularNode = this.specularNode || materialSpecularColor;
    stack2.assign(specularColor, specularNode);
  }
  copy(source) {
    this.shininessNode = source.shininessNode;
    this.specularNode = source.specularNode;
    return super.copy(source);
  }
};
var MeshPhongNodeMaterial_default = MeshPhongNodeMaterial;
addNodeMaterial(MeshPhongNodeMaterial);

// node_modules/three/examples/jsm/nodes/functions/material/getGeometryRoughness.js
var getGeometryRoughness = tslFn(() => {
  const dxy = normalGeometry.dFdx().abs().max(normalGeometry.dFdy().abs());
  const geometryRoughness = dxy.x.max(dxy.y).max(dxy.z);
  return geometryRoughness;
});
var getGeometryRoughness_default = getGeometryRoughness;

// node_modules/three/examples/jsm/nodes/functions/material/getRoughness.js
var getRoughness = tslFn((inputs) => {
  const { roughness: roughness2 } = inputs;
  const geometryRoughness = getGeometryRoughness_default();
  let roughnessFactor = roughness2.max(0.0525);
  roughnessFactor = roughnessFactor.add(geometryRoughness);
  roughnessFactor = roughnessFactor.min(1);
  return roughnessFactor;
});
var getRoughness_default = getRoughness;

// node_modules/three/examples/jsm/nodes/functions/BSDF/V_GGX_SmithCorrelated.js
var V_GGX_SmithCorrelated = tslFn((inputs) => {
  const { alpha, dotNL, dotNV } = inputs;
  const a2 = alpha.pow2();
  const gv = dotNL.mul(a2.add(a2.oneMinus().mul(dotNV.pow2())).sqrt());
  const gl = dotNV.mul(a2.add(a2.oneMinus().mul(dotNL.pow2())).sqrt());
  return div(0.5, gv.add(gl).max(EPSILON));
});
var V_GGX_SmithCorrelated_default = V_GGX_SmithCorrelated;

// node_modules/three/examples/jsm/nodes/functions/BSDF/D_GGX.js
var D_GGX = tslFn((inputs) => {
  const { alpha, dotNH } = inputs;
  const a2 = alpha.pow2();
  const denom = dotNH.pow2().mul(a2.oneMinus()).oneMinus();
  return a2.div(denom.pow2()).mul(1 / Math.PI);
});
var D_GGX_default = D_GGX;

// node_modules/three/examples/jsm/nodes/functions/BSDF/BRDF_GGX.js
var BRDF_GGX = tslFn((inputs) => {
  const { lightDirection, f0, f90, roughness: roughness2, iridescenceFresnel } = inputs;
  const normalView2 = inputs.normalView || transformedNormalView;
  const alpha = roughness2.pow2();
  const halfDir = lightDirection.add(positionViewDirection).normalize();
  const dotNL = normalView2.dot(lightDirection).clamp();
  const dotNV = normalView2.dot(positionViewDirection).clamp();
  const dotNH = normalView2.dot(halfDir).clamp();
  const dotVH = positionViewDirection.dot(halfDir).clamp();
  let F = F_Schlick_default({ f0, f90, dotVH });
  if (iridescenceFresnel) {
    F = iridescence.mix(F, iridescenceFresnel);
  }
  const V = V_GGX_SmithCorrelated_default({ alpha, dotNL, dotNV });
  const D = D_GGX_default({ alpha, dotNH });
  return F.mul(V).mul(D);
});
var BRDF_GGX_default = BRDF_GGX;

// node_modules/three/examples/jsm/nodes/functions/BSDF/DFGApprox.js
var DFGApprox = tslFn((inputs) => {
  const { roughness: roughness2 } = inputs;
  const dotNV = inputs.dotNV || transformedNormalView.dot(positionViewDirection).clamp();
  const c0 = vec4(-1, -0.0275, -0.572, 0.022);
  const c1 = vec4(1, 0.0425, 1.04, -0.04);
  const r = roughness2.mul(c0).add(c1);
  const a004 = r.x.mul(r.x).min(dotNV.mul(-9.28).exp2()).mul(r.x).add(r.y);
  const fab = vec2(-1.04, 1.04).mul(a004).add(r.zw);
  return fab;
});
var DFGApprox_default = DFGApprox;

// node_modules/three/examples/jsm/nodes/functions/BSDF/EnvironmentBRDF.js
var EnvironmentBRDF = tslFn((inputs) => {
  const { dotNV, specularColor: specularColor2, specularF90, roughness: roughness2 } = inputs;
  const fab = DFGApprox_default({ dotNV, roughness: roughness2 });
  return specularColor2.mul(fab.x).add(specularF90.mul(fab.y));
});
var EnvironmentBRDF_default = EnvironmentBRDF;

// node_modules/three/examples/jsm/nodes/functions/BSDF/Schlick_to_F0.js
var Schlick_to_F0 = tslFn(({ f, f90, dotVH }) => {
  const x = dotVH.oneMinus().saturate();
  const x2 = x.mul(x);
  const x5 = x.mul(x2, x2).clamp(0, 0.9999);
  return f.sub(vec3(f90).mul(x5)).div(x5.oneMinus());
});
var Schlick_to_F0_default = Schlick_to_F0;

// node_modules/three/examples/jsm/nodes/functions/BSDF/BRDF_Sheen.js
var D_Charlie = (roughness2, dotNH) => {
  const alpha = roughness2.pow2();
  const invAlpha = float(1).div(alpha);
  const cos2h = dotNH.pow2();
  const sin2h = cos2h.oneMinus().max(78125e-7);
  return float(2).add(invAlpha).mul(sin2h.pow(invAlpha.mul(0.5))).div(2 * Math.PI);
};
var V_Neubelt = (dotNV, dotNL) => {
  return float(1).div(float(4).mul(dotNL.add(dotNV).sub(dotNL.mul(dotNV))));
};
var BRDF_Sheen = tslFn(({ lightDirection }) => {
  const halfDir = lightDirection.add(positionViewDirection).normalize();
  const dotNL = transformedNormalView.dot(lightDirection).clamp();
  const dotNV = transformedNormalView.dot(positionViewDirection).clamp();
  const dotNH = transformedNormalView.dot(halfDir).clamp();
  const D = D_Charlie(sheenRoughness, dotNH);
  const V = V_Neubelt(dotNV, dotNL);
  return sheen.mul(D).mul(V);
});
var BRDF_Sheen_default = BRDF_Sheen;

// node_modules/three/examples/jsm/nodes/functions/PhysicalLightingModel.js
var XYZ_TO_REC709 = mat3(
  3.2404542,
  -0.969266,
  0.0556434,
  -1.5371385,
  1.8760108,
  -0.2040259,
  -0.4985314,
  0.041556,
  1.0572252
);
var Fresnel0ToIor = (fresnel0) => {
  const sqrtF0 = fresnel0.sqrt();
  return vec3(1).add(sqrtF0).div(vec3(1).sub(sqrtF0));
};
var IorToFresnel0 = (transmittedIor, incidentIor) => {
  return transmittedIor.sub(incidentIor).div(transmittedIor.add(incidentIor)).pow2();
};
var evalSensitivity = (OPD, shift) => {
  const phase = OPD.mul(2 * Math.PI * 1e-9);
  const val = vec3(54856e-17, 44201e-17, 52481e-17);
  const pos = vec3(1681e3, 1795300, 2208400);
  const VAR = vec3(43278e5, 93046e5, 66121e5);
  const x = float(9747e-17 * Math.sqrt(2 * Math.PI * 45282e5)).mul(phase.mul(2239900).add(shift.x).cos()).mul(phase.pow2().mul(-45282e5).exp());
  let xyz = val.mul(VAR.mul(2 * Math.PI).sqrt()).mul(pos.mul(phase).add(shift).cos()).mul(phase.pow2().negate().mul(VAR).exp());
  xyz = vec3(xyz.x.add(x), xyz.y, xyz.z).div(10685e-11);
  const rgb = XYZ_TO_REC709.mul(xyz);
  return rgb;
};
var evalIridescence = (outsideIOR, eta2, cosTheta1, thinFilmThickness, baseF0) => {
  const iridescenceIOR2 = mix(outsideIOR, eta2, smoothstep(0, 0.03, thinFilmThickness));
  const sinTheta2Sq = outsideIOR.div(iridescenceIOR2).pow2().mul(float(1).sub(cosTheta1.pow2()));
  const cosTheta2Sq = float(1).sub(sinTheta2Sq);
  const cosTheta2 = cosTheta2Sq.sqrt();
  const R0 = IorToFresnel0(iridescenceIOR2, outsideIOR);
  const R12 = F_Schlick_default({ f0: R0, f90: 1, dotVH: cosTheta1 });
  const T121 = R12.oneMinus();
  const phi12 = iridescenceIOR2.lessThan(outsideIOR).cond(Math.PI, 0);
  const phi21 = float(Math.PI).sub(phi12);
  const baseIOR = Fresnel0ToIor(baseF0.clamp(0, 0.9999));
  const R1 = IorToFresnel0(baseIOR, iridescenceIOR2.vec3());
  const R23 = F_Schlick_default({ f0: R1, f90: 1, dotVH: cosTheta2 });
  const phi23 = vec3(
    baseIOR.x.lessThan(iridescenceIOR2).cond(Math.PI, 0),
    baseIOR.y.lessThan(iridescenceIOR2).cond(Math.PI, 0),
    baseIOR.z.lessThan(iridescenceIOR2).cond(Math.PI, 0)
  );
  const OPD = iridescenceIOR2.mul(thinFilmThickness, cosTheta2, 2);
  const phi = vec3(phi21).add(phi23);
  const R123 = R12.mul(R23).clamp(1e-5, 0.9999);
  const r123 = R123.sqrt();
  const Rs = T121.pow2().mul(R23).div(vec3(1).sub(R123));
  const C0 = R12.add(Rs);
  let I = C0;
  let Cm = Rs.sub(T121);
  for (let m = 1; m <= 2; ++m) {
    Cm = Cm.mul(r123);
    const Sm = evalSensitivity(float(m).mul(OPD), float(m).mul(phi)).mul(2);
    I = I.add(Cm.mul(Sm));
  }
  return I.max(vec3(0));
};
var IBLSheenBRDF = (normal, viewDir, roughness2) => {
  const dotNV = normal.dot(viewDir).saturate();
  const r2 = roughness2.pow2();
  const a = cond(
    roughness2.lessThan(0.25),
    float(-339.2).mul(r2).add(float(161.4).mul(roughness2)).sub(25.9),
    float(-8.48).mul(r2).add(float(14.3).mul(roughness2)).sub(9.95)
  );
  const b = cond(
    roughness2.lessThan(0.25),
    float(44).mul(r2).sub(float(23.7).mul(roughness2)).add(3.26),
    float(1.97).mul(r2).sub(float(3.27).mul(roughness2)).add(0.72)
  );
  const DG = cond(roughness2.lessThan(0.25), 0, float(0.1).mul(roughness2).sub(0.025)).add(a.mul(dotNV).add(b).exp());
  return DG.mul(1 / Math.PI).saturate();
};
var clearcoatF0 = vec3(0.04);
var clearcoatF90 = vec3(1);
var PhysicalLightingModel = class extends LightingModel_default {
  constructor(clearcoat2 = true, sheen2 = true, iridescence2 = true) {
    super();
    this.clearcoat = clearcoat2;
    this.sheen = sheen2;
    this.iridescence = iridescence2;
    this.clearcoatRadiance = null;
    this.clearcoatSpecular = null;
    this.sheenSpecular = null;
    this.iridescenceFresnel = null;
    this.iridescenceF0 = null;
  }
  init({ reflectedLight }) {
    if (this.clearcoat === true) {
      this.clearcoatRadiance = vec3().temp();
      this.clearcoatSpecular = vec3().temp();
      const dotNVcc = transformedClearcoatNormalView.dot(positionViewDirection).clamp();
      const Fcc = F_Schlick_default({
        dotVH: dotNVcc,
        f0: clearcoatF0,
        f90: clearcoatF90
      });
      const outgoingLight = reflectedLight.total;
      const clearcoatLight = outgoingLight.mul(clearcoat.mul(Fcc).oneMinus()).add(this.clearcoatSpecular.mul(clearcoat));
      outgoingLight.assign(clearcoatLight);
    }
    if (this.sheen === true) {
      this.sheenSpecular = vec3().temp();
      const outgoingLight = reflectedLight.total;
      const sheenEnergyComp = sheen.r.max(sheen.g).max(sheen.b).mul(0.157).oneMinus();
      const sheenLight = outgoingLight.mul(sheenEnergyComp).add(this.sheenSpecular);
      outgoingLight.assign(sheenLight);
    }
    if (this.iridescence === true) {
      const dotNVi = transformedNormalView.dot(positionViewDirection).clamp();
      this.iridescenceFresnel = evalIridescence(float(1), iridescenceIOR, dotNVi, iridescenceThickness, specularColor);
      this.iridescenceF0 = Schlick_to_F0_default({ f: this.iridescenceFresnel, f90: 1, dotVH: dotNVi });
    }
  }
  // Fdez-Agüera's "Multiple-Scattering Microfacet Model for Real-Time Image Based Lighting"
  // Approximates multiscattering in order to preserve energy.
  // http://www.jcgt.org/published/0008/01/03/
  computeMultiscattering(singleScatter, multiScatter, specularF90 = float(1)) {
    const fab = DFGApprox_default({ roughness });
    const Fr = this.iridescenceF0 ? iridescence.mix(specularColor, this.iridescenceF0) : specularColor;
    const FssEss = Fr.mul(fab.x).add(specularF90.mul(fab.y));
    const Ess = fab.x.add(fab.y);
    const Ems = Ess.oneMinus();
    const Favg = specularColor.add(specularColor.oneMinus().mul(0.047619));
    const Fms = FssEss.mul(Favg).div(Ems.mul(Favg).oneMinus());
    singleScatter.addAssign(FssEss);
    multiScatter.addAssign(Fms.mul(Ems));
  }
  direct({ lightDirection, lightColor, reflectedLight }) {
    const dotNL = transformedNormalView.dot(lightDirection).clamp();
    const irradiance = dotNL.mul(lightColor);
    if (this.sheen === true) {
      this.sheenSpecular.addAssign(irradiance.mul(BRDF_Sheen_default({ lightDirection })));
    }
    if (this.clearcoat === true) {
      const dotNLcc = transformedClearcoatNormalView.dot(lightDirection).clamp();
      const ccIrradiance = dotNLcc.mul(lightColor);
      this.clearcoatSpecular.addAssign(ccIrradiance.mul(BRDF_GGX_default({ lightDirection, f0: clearcoatF0, f90: clearcoatF90, roughness: clearcoatRoughness, normalView: transformedClearcoatNormalView })));
    }
    reflectedLight.directDiffuse.addAssign(irradiance.mul(BRDF_Lambert_default({ diffuseColor: diffuseColor.rgb })));
    reflectedLight.directSpecular.addAssign(irradiance.mul(BRDF_GGX_default({ lightDirection, f0: specularColor, f90: 1, roughness, iridescence: this.iridescence, iridescenceFresnel: this.iridescenceFresnel })));
  }
  indirectDiffuse({ irradiance, reflectedLight }) {
    reflectedLight.indirectDiffuse.addAssign(irradiance.mul(BRDF_Lambert_default({ diffuseColor })));
  }
  indirectSpecular({ radiance, iblIrradiance, reflectedLight }) {
    if (this.sheen === true) {
      this.sheenSpecular.addAssign(iblIrradiance.mul(
        sheen,
        IBLSheenBRDF(transformedNormalView, positionViewDirection, sheenRoughness)
      ));
    }
    if (this.clearcoat === true) {
      const dotNVcc = transformedClearcoatNormalView.dot(positionViewDirection).clamp();
      const clearcoatEnv = EnvironmentBRDF_default({
        dotNV: dotNVcc,
        specularColor: clearcoatF0,
        specularF90: clearcoatF90,
        roughness: clearcoatRoughness
      });
      this.clearcoatSpecular.addAssign(this.clearcoatRadiance.mul(clearcoatEnv));
    }
    const singleScattering = vec3().temp();
    const multiScattering = vec3().temp();
    const cosineWeightedIrradiance = iblIrradiance.mul(1 / Math.PI);
    this.computeMultiscattering(singleScattering, multiScattering);
    const totalScattering = singleScattering.add(multiScattering);
    const diffuse = diffuseColor.mul(totalScattering.r.max(totalScattering.g).max(totalScattering.b).oneMinus());
    reflectedLight.indirectSpecular.addAssign(radiance.mul(singleScattering));
    reflectedLight.indirectSpecular.addAssign(multiScattering.mul(cosineWeightedIrradiance));
    reflectedLight.indirectDiffuse.addAssign(diffuse.mul(cosineWeightedIrradiance));
  }
  ambientOcclusion({ ambientOcclusion, reflectedLight }) {
    const dotNV = transformedNormalView.dot(positionViewDirection).clamp();
    const aoNV = dotNV.add(ambientOcclusion);
    const aoExp = roughness.mul(-16).oneMinus().negate().exp2();
    const aoNode = ambientOcclusion.sub(aoNV.pow(aoExp).oneMinus()).clamp();
    reflectedLight.indirectDiffuse.mulAssign(ambientOcclusion);
    reflectedLight.indirectSpecular.mulAssign(aoNode);
  }
};
var PhysicalLightingModel_default = PhysicalLightingModel;

// node_modules/three/examples/jsm/nodes/materials/MeshStandardNodeMaterial.js
var defaultValues7 = new MeshStandardMaterial();
var MeshStandardNodeMaterial = class extends NodeMaterial_default {
  constructor(parameters) {
    super();
    this.isMeshStandardNodeMaterial = true;
    this.emissiveNode = null;
    this.metalnessNode = null;
    this.roughnessNode = null;
    this.setDefaultValues(defaultValues7);
    this.setValues(parameters);
  }
  constructLightingModel() {
    return new PhysicalLightingModel_default(false, false);
  }
  constructVariants({ stack: stack2 }) {
    const metalnessNode = this.metalnessNode ? float(this.metalnessNode) : materialMetalness;
    stack2.assign(metalness, metalnessNode);
    let roughnessNode = this.roughnessNode ? float(this.roughnessNode) : materialRoughness;
    roughnessNode = getRoughness_default({ roughness: roughnessNode });
    stack2.assign(roughness, roughnessNode);
    const specularColorNode = mix(vec3(0.04), diffuseColor.rgb, metalnessNode);
    stack2.assign(specularColor, specularColorNode);
    stack2.assign(diffuseColor, vec4(diffuseColor.rgb.mul(metalnessNode.oneMinus()), diffuseColor.a));
  }
  copy(source) {
    this.emissiveNode = source.emissiveNode;
    this.metalnessNode = source.metalnessNode;
    this.roughnessNode = source.roughnessNode;
    return super.copy(source);
  }
};
var MeshStandardNodeMaterial_default = MeshStandardNodeMaterial;
addNodeMaterial(MeshStandardNodeMaterial);

// node_modules/three/examples/jsm/nodes/materials/MeshPhysicalNodeMaterial.js
var defaultValues8 = new MeshPhysicalMaterial();
var MeshPhysicalNodeMaterial = class extends MeshStandardNodeMaterial_default {
  constructor(parameters) {
    super();
    this.isMeshPhysicalNodeMaterial = true;
    this.clearcoatNode = null;
    this.clearcoatRoughnessNode = null;
    this.clearcoatNormalNode = null;
    this.sheenNode = null;
    this.sheenRoughnessNode = null;
    this.iridescenceNode = null;
    this.iridescenceIORNode = null;
    this.iridescenceThicknessNode = null;
    this.specularIntensityNode = null;
    this.specularColorNode = null;
    this.transmissionNode = null;
    this.thicknessNode = null;
    this.attenuationDistanceNode = null;
    this.attenuationColorNode = null;
    this.setDefaultValues(defaultValues8);
    this.setValues(parameters);
  }
  constructLightingModel() {
    return new PhysicalLightingModel_default();
  }
  constructVariants(builder) {
    super.constructVariants(builder);
    const { stack: stack2 } = builder;
    const clearcoatNode = this.clearcoatNode ? float(this.clearcoatNode) : materialClearcoat;
    const clearcoatRoughnessNode = this.clearcoatRoughnessNode ? float(this.clearcoatRoughnessNode) : materialClearcoatRoughness;
    stack2.assign(clearcoat, clearcoatNode);
    stack2.assign(clearcoatRoughness, clearcoatRoughnessNode);
    const sheenNode = this.sheenNode ? vec3(this.sheenNode) : materialSheen;
    const sheenRoughnessNode = this.sheenRoughnessNode ? float(this.sheenRoughnessNode) : materialSheenRoughness;
    stack2.assign(sheen, sheenNode);
    stack2.assign(sheenRoughness, sheenRoughnessNode);
    const iridescenceNode = this.iridescenceNode ? float(this.iridescenceNode) : materialIridescence;
    const iridescenceIORNode = this.iridescenceIORNode ? float(this.iridescenceIORNode) : materialIridescenceIOR;
    const iridescenceThicknessNode = this.iridescenceThicknessNode ? float(this.iridescenceThicknessNode) : materialIridescenceThickness;
    stack2.assign(iridescence, iridescenceNode);
    stack2.assign(iridescenceIOR, iridescenceIORNode);
    stack2.assign(iridescenceThickness, iridescenceThicknessNode);
  }
  constructNormal(builder) {
    super.constructNormal(builder);
    const clearcoatNormalNode = this.clearcoatNormalNode ? vec3(this.clearcoatNormalNode) : materialClearcoatNormal;
    builder.stack.assign(transformedClearcoatNormalView, clearcoatNormalNode);
  }
  copy(source) {
    this.clearcoatNode = source.clearcoatNode;
    this.clearcoatRoughnessNode = source.clearcoatRoughnessNode;
    this.clearcoatNormalNode = source.clearcoatNormalNode;
    this.sheenNode = source.sheenNode;
    this.sheenRoughnessNode = source.sheenRoughnessNode;
    this.iridescenceNode = source.iridescenceNode;
    this.iridescenceIORNode = source.iridescenceIORNode;
    this.iridescenceThicknessNode = source.iridescenceThicknessNode;
    this.specularIntensityNode = source.specularIntensityNode;
    this.specularColorNode = source.specularColorNode;
    this.transmissionNode = source.transmissionNode;
    this.thicknessNode = source.thicknessNode;
    this.attenuationDistanceNode = source.attenuationDistanceNode;
    this.attenuationColorNode = source.attenuationColorNode;
    return super.copy(source);
  }
};
var MeshPhysicalNodeMaterial_default = MeshPhysicalNodeMaterial;
addNodeMaterial(MeshPhysicalNodeMaterial);

// node_modules/three/examples/jsm/nodes/materials/PointsNodeMaterial.js
var defaultValues9 = new PointsMaterial();
var PointsNodeMaterial = class extends NodeMaterial_default {
  constructor(parameters) {
    super();
    this.isPointsNodeMaterial = true;
    this.lights = false;
    this.normals = false;
    this.transparent = true;
    this.colorNode = null;
    this.opacityNode = null;
    this.alphaTestNode = null;
    this.lightNode = null;
    this.sizeNode = null;
    this.positionNode = null;
    this.setDefaultValues(defaultValues9);
    this.setValues(parameters);
  }
  copy(source) {
    this.sizeNode = source.sizeNode;
    return super.copy(source);
  }
};
var PointsNodeMaterial_default = PointsNodeMaterial;
addNodeMaterial(PointsNodeMaterial);

// node_modules/three/examples/jsm/nodes/materials/SpriteNodeMaterial.js
var defaultValues10 = new SpriteMaterial();
var SpriteNodeMaterial = class extends NodeMaterial_default {
  constructor(parameters) {
    super();
    this.isSpriteNodeMaterial = true;
    this.lights = false;
    this.normals = false;
    this.colorNode = null;
    this.opacityNode = null;
    this.alphaTestNode = null;
    this.lightNode = null;
    this.positionNode = null;
    this.rotationNode = null;
    this.scaleNode = null;
    this.setDefaultValues(defaultValues10);
    this.setValues(parameters);
  }
  constructPosition({ object, context: context2 }) {
    const { positionNode, rotationNode, scaleNode } = this;
    const vertex = positionLocal;
    let mvPosition = modelViewMatrix.mul(vec3(positionNode || 0));
    let scale = vec2(modelWorldMatrix[0].xyz.length(), modelWorldMatrix[1].xyz.length());
    if (scaleNode !== null) {
      scale = scale.mul(scaleNode);
    }
    let alignedPosition = vertex.xy;
    if (object.center && object.center.isVector2 === true) {
      alignedPosition = alignedPosition.sub(uniform(object.center).sub(0.5));
    }
    alignedPosition = alignedPosition.mul(scale);
    const rotation = float(rotationNode || materialRotation);
    const cosAngle = rotation.cos();
    const sinAngle = rotation.sin();
    const rotatedPosition = vec2(
      // @TODO: Maybe we can create mat2 and write something like rotationMatrix.mul( alignedPosition )?
      vec2(cosAngle, sinAngle.negate()).dot(alignedPosition),
      vec2(sinAngle, cosAngle).dot(alignedPosition)
    );
    mvPosition = vec4(mvPosition.xy.add(rotatedPosition), mvPosition.zw);
    const modelViewProjection2 = cameraProjectionMatrix.mul(mvPosition);
    context2.vertex = vertex;
    return modelViewProjection2;
  }
  copy(source) {
    this.positionNode = source.positionNode;
    this.rotationNode = source.rotationNode;
    this.scaleNode = source.scaleNode;
    return super.copy(source);
  }
};
var SpriteNodeMaterial_default = SpriteNodeMaterial;
addNodeMaterial(SpriteNodeMaterial);

// node_modules/three/examples/jsm/nodes/loaders/NodeMaterialLoader.js
var superFromTypeFunction = MaterialLoader.createMaterialFromType;
MaterialLoader.createMaterialFromType = function(type) {
  const material = createNodeMaterialFromType(type);
  if (material !== void 0) {
    return material;
  }
  return superFromTypeFunction.call(this, type);
};
var NodeMaterialLoader = class extends MaterialLoader {
  constructor(manager) {
    super(manager);
    this.nodes = {};
  }
  parse(json) {
    const material = super.parse(json);
    const nodes = this.nodes;
    const inputNodes = json.inputNodes;
    for (const property2 in inputNodes) {
      const uuid = inputNodes[property2];
      material[property2] = nodes[uuid];
    }
    return material;
  }
  setNodes(value) {
    this.nodes = value;
    return this;
  }
};
var NodeMaterialLoader_default = NodeMaterialLoader;

// node_modules/three/examples/jsm/nodes/loaders/NodeObjectLoader.js
var NodeObjectLoader = class extends ObjectLoader {
  constructor(manager) {
    super(manager);
    this._nodesJSON = null;
  }
  parse(json, onLoad) {
    this._nodesJSON = json.nodes;
    const data = super.parse(json, onLoad);
    this._nodesJSON = null;
    return data;
  }
  parseNodes(json, textures) {
    if (json !== void 0) {
      const loader = new NodeLoader_default();
      loader.setTextures(textures);
      return loader.parseNodes(json);
    }
    return {};
  }
  parseMaterials(json, textures) {
    const materials = {};
    if (json !== void 0) {
      const nodes = this.parseNodes(this._nodesJSON, textures);
      const loader = new NodeMaterialLoader_default();
      loader.setTextures(textures);
      loader.setNodes(nodes);
      for (let i = 0, l = json.length; i < l; i++) {
        const data = json[i];
        materials[data.uuid] = loader.parse(data);
      }
    }
    return materials;
  }
};
var NodeObjectLoader_default = NodeObjectLoader;

// node_modules/three/examples/jsm/nodes/core/NodeParser.js
var NodeParser = class {
  parseFunction() {
    console.warn("Abstract function.");
  }
};
var NodeParser_default = NodeParser;

// node_modules/three/examples/jsm/nodes/core/NodeFunction.js
var NodeFunction = class {
  constructor(type, inputs, name = "", presicion = "") {
    this.type = type;
    this.inputs = inputs;
    this.name = name;
    this.presicion = presicion;
  }
  getCode() {
    console.warn("Abstract function.");
  }
};
NodeFunction.isNodeFunction = true;
var NodeFunction_default = NodeFunction;

// node_modules/three/examples/jsm/nodes/parsers/GLSLNodeFunction.js
var declarationRegexp = /^\s*(highp|mediump|lowp)?\s*([a-z_0-9]+)\s*([a-z_0-9]+)?\s*\(([\s\S]*?)\)/i;
var propertiesRegexp = /[a-z_0-9]+/ig;
var pragmaMain = "#pragma main";
var parse = (source) => {
  source = source.trim();
  const pragmaMainIndex = source.indexOf(pragmaMain);
  const mainCode = pragmaMainIndex !== -1 ? source.slice(pragmaMainIndex + pragmaMain.length) : source;
  const declaration = mainCode.match(declarationRegexp);
  if (declaration !== null && declaration.length === 5) {
    const inputsCode = declaration[4];
    const propsMatches = [];
    let nameMatch = null;
    while ((nameMatch = propertiesRegexp.exec(inputsCode)) !== null) {
      propsMatches.push(nameMatch);
    }
    const inputs = [];
    let i = 0;
    while (i < propsMatches.length) {
      const isConst = propsMatches[i][0] === "const";
      if (isConst === true) {
        i++;
      }
      let qualifier = propsMatches[i][0];
      if (qualifier === "in" || qualifier === "out" || qualifier === "inout") {
        i++;
      } else {
        qualifier = "";
      }
      const type2 = propsMatches[i++][0];
      let count = Number.parseInt(propsMatches[i][0]);
      if (Number.isNaN(count) === false)
        i++;
      else
        count = null;
      const name2 = propsMatches[i++][0];
      inputs.push(new NodeFunctionInput_default(type2, name2, count, qualifier, isConst));
    }
    const blockCode = mainCode.substring(declaration[0].length);
    const name = declaration[3] !== void 0 ? declaration[3] : "";
    const type = declaration[2];
    const presicion = declaration[1] !== void 0 ? declaration[1] : "";
    const headerCode = pragmaMainIndex !== -1 ? source.slice(0, pragmaMainIndex) : "";
    return {
      type,
      inputs,
      name,
      presicion,
      inputsCode,
      blockCode,
      headerCode
    };
  } else {
    throw new Error("FunctionNode: Function is not a GLSL code.");
  }
};
var GLSLNodeFunction = class extends NodeFunction_default {
  constructor(source) {
    const { type, inputs, name, presicion, inputsCode, blockCode, headerCode } = parse(source);
    super(type, inputs, name, presicion);
    this.inputsCode = inputsCode;
    this.blockCode = blockCode;
    this.headerCode = headerCode;
  }
  getCode(name = this.name) {
    let code2;
    const blockCode = this.blockCode;
    if (blockCode !== "") {
      const { type, inputsCode, headerCode, presicion } = this;
      let declarationCode = `${type} ${name} ( ${inputsCode.trim()} )`;
      if (presicion !== "") {
        declarationCode = `${presicion} ${declarationCode}`;
      }
      code2 = headerCode + declarationCode + blockCode;
    } else {
      code2 = "";
    }
    return code2;
  }
};
var GLSLNodeFunction_default = GLSLNodeFunction;

// node_modules/three/examples/jsm/nodes/parsers/GLSLNodeParser.js
var GLSLNodeParser = class extends NodeParser_default {
  parseFunction(source) {
    return new GLSLNodeFunction_default(source);
  }
};
var GLSLNodeParser_default = GLSLNodeParser;

// node_modules/three/examples/jsm/nodes/materialx/lib/mx_noise.js
var mx_noise = glsl(`float mx_select(bool b, float t, float f)
{
    return b ? t : f;
}

float mx_negate_if(float val, bool b)
{
    return b ? -val : val;
}

int mx_floor(float x)
{
    return int(floor(x));
}

// return mx_floor as well as the fractional remainder
float mx_floorfrac(float x, out int i)
{
    i = mx_floor(x);
    return x - float(i);
}

float mx_bilerp(float v0, float v1, float v2, float v3, float s, float t)
{
    float s1 = 1.0 - s;
    return (1.0 - t) * (v0*s1 + v1*s) + t * (v2*s1 + v3*s);
}
vec3 mx_bilerp(vec3 v0, vec3 v1, vec3 v2, vec3 v3, float s, float t)
{
    float s1 = 1.0 - s;
    return (1.0 - t) * (v0*s1 + v1*s) + t * (v2*s1 + v3*s);
}
float mx_trilerp(float v0, float v1, float v2, float v3, float v4, float v5, float v6, float v7, float s, float t, float r)
{
    float s1 = 1.0 - s;
    float t1 = 1.0 - t;
    float r1 = 1.0 - r;
    return (r1*(t1*(v0*s1 + v1*s) + t*(v2*s1 + v3*s)) +
            r*(t1*(v4*s1 + v5*s) + t*(v6*s1 + v7*s)));
}
vec3 mx_trilerp(vec3 v0, vec3 v1, vec3 v2, vec3 v3, vec3 v4, vec3 v5, vec3 v6, vec3 v7, float s, float t, float r)
{
    float s1 = 1.0 - s;
    float t1 = 1.0 - t;
    float r1 = 1.0 - r;
    return (r1*(t1*(v0*s1 + v1*s) + t*(v2*s1 + v3*s)) +
            r*(t1*(v4*s1 + v5*s) + t*(v6*s1 + v7*s)));
}

// 2 and 3 dimensional gradient functions - perform a dot product against a
// randomly chosen vector. Note that the gradient vector is not normalized, but
// this only affects the overal "scale" of the result, so we simply account for
// the scale by multiplying in the corresponding "perlin" function.
float mx_gradient_float(uint hash, float x, float y)
{
    // 8 possible directions (+-1,+-2) and (+-2,+-1)
    uint h = hash & 7u;
    float u = mx_select(h<4u, x, y);
    float v = 2.0 * mx_select(h<4u, y, x);
    // compute the dot product with (x,y).
    return mx_negate_if(u, bool(h&1u)) + mx_negate_if(v, bool(h&2u));
}
float mx_gradient_float(uint hash, float x, float y, float z)
{
    // use vectors pointing to the edges of the cube
    uint h = hash & 15u;
    float u = mx_select(h<8u, x, y);
    float v = mx_select(h<4u, y, mx_select((h==12u)||(h==14u), x, z));
    return mx_negate_if(u, bool(h&1u)) + mx_negate_if(v, bool(h&2u));
}
vec3 mx_gradient_vec3(uvec3 hash, float x, float y)
{
    return vec3(mx_gradient_float(hash.x, x, y), mx_gradient_float(hash.y, x, y), mx_gradient_float(hash.z, x, y));
}
vec3 mx_gradient_vec3(uvec3 hash, float x, float y, float z)
{
    return vec3(mx_gradient_float(hash.x, x, y, z), mx_gradient_float(hash.y, x, y, z), mx_gradient_float(hash.z, x, y, z));
}
// Scaling factors to normalize the result of gradients above.
// These factors were experimentally calculated to be:
//    2D:   0.6616
//    3D:   0.9820
float mx_gradient_scale2d(float v) { return 0.6616 * v; }
float mx_gradient_scale3d(float v) { return 0.9820 * v; }
vec3 mx_gradient_scale2d(vec3 v) { return 0.6616 * v; }
vec3 mx_gradient_scale3d(vec3 v) { return 0.9820 * v; }

/// Bitwise circular rotation left by k bits (for 32 bit unsigned integers)
uint mx_rotl32(uint x, int k)
{
    return (x<<k) | (x>>(32-k));
}

void mx_bjmix(inout uint a, inout uint b, inout uint c)
{
    a -= c; a ^= mx_rotl32(c, 4); c += b;
    b -= a; b ^= mx_rotl32(a, 6); a += c;
    c -= b; c ^= mx_rotl32(b, 8); b += a;
    a -= c; a ^= mx_rotl32(c,16); c += b;
    b -= a; b ^= mx_rotl32(a,19); a += c;
    c -= b; c ^= mx_rotl32(b, 4); b += a;
}

// Mix up and combine the bits of a, b, and c (doesn't change them, but
// returns a hash of those three original values).
uint mx_bjfinal(uint a, uint b, uint c)
{
    c ^= b; c -= mx_rotl32(b,14);
    a ^= c; a -= mx_rotl32(c,11);
    b ^= a; b -= mx_rotl32(a,25);
    c ^= b; c -= mx_rotl32(b,16);
    a ^= c; a -= mx_rotl32(c,4);
    b ^= a; b -= mx_rotl32(a,14);
    c ^= b; c -= mx_rotl32(b,24);
    return c;
}

// Convert a 32 bit integer into a floating point number in [0,1]
float mx_bits_to_01(uint bits)
{
    return float(bits) / float(uint(0xffffffff));
}

float mx_fade(float t)
{
   return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);
}

uint mx_hash_int(int x)
{
    uint len = 1u;
    uint seed = uint(0xdeadbeef) + (len << 2u) + 13u;
    return mx_bjfinal(seed+uint(x), seed, seed);
}

uint mx_hash_int(int x, int y)
{
    uint len = 2u;
    uint a, b, c;
    a = b = c = uint(0xdeadbeef) + (len << 2u) + 13u;
    a += uint(x);
    b += uint(y);
    return mx_bjfinal(a, b, c);
}

uint mx_hash_int(int x, int y, int z)
{
    uint len = 3u;
    uint a, b, c;
    a = b = c = uint(0xdeadbeef) + (len << 2u) + 13u;
    a += uint(x);
    b += uint(y);
    c += uint(z);
    return mx_bjfinal(a, b, c);
}

uint mx_hash_int(int x, int y, int z, int xx)
{
    uint len = 4u;
    uint a, b, c;
    a = b = c = uint(0xdeadbeef) + (len << 2u) + 13u;
    a += uint(x);
    b += uint(y);
    c += uint(z);
    mx_bjmix(a, b, c);
    a += uint(xx);
    return mx_bjfinal(a, b, c);
}

uint mx_hash_int(int x, int y, int z, int xx, int yy)
{
    uint len = 5u;
    uint a, b, c;
    a = b = c = uint(0xdeadbeef) + (len << 2u) + 13u;
    a += uint(x);
    b += uint(y);
    c += uint(z);
    mx_bjmix(a, b, c);
    a += uint(xx);
    b += uint(yy);
    return mx_bjfinal(a, b, c);
}

uvec3 mx_hash_vec3(int x, int y)
{
    uint h = mx_hash_int(x, y);
    // we only need the low-order bits to be random, so split out
    // the 32 bit result into 3 parts for each channel
    uvec3 result;
    result.x = (h      ) & 0xFFu;
    result.y = (h >> 8 ) & 0xFFu;
    result.z = (h >> 16) & 0xFFu;
    return result;
}

uvec3 mx_hash_vec3(int x, int y, int z)
{
    uint h = mx_hash_int(x, y, z);
    // we only need the low-order bits to be random, so split out
    // the 32 bit result into 3 parts for each channel
    uvec3 result;
    result.x = (h      ) & 0xFFu;
    result.y = (h >> 8 ) & 0xFFu;
    result.z = (h >> 16) & 0xFFu;
    return result;
}

float mx_perlin_noise_float(vec2 p)
{
    int X, Y;
    float fx = mx_floorfrac(p.x, X);
    float fy = mx_floorfrac(p.y, Y);
    float u = mx_fade(fx);
    float v = mx_fade(fy);
    float result = mx_bilerp(
        mx_gradient_float(mx_hash_int(X  , Y  ), fx    , fy     ),
        mx_gradient_float(mx_hash_int(X+1, Y  ), fx-1.0, fy     ),
        mx_gradient_float(mx_hash_int(X  , Y+1), fx    , fy-1.0),
        mx_gradient_float(mx_hash_int(X+1, Y+1), fx-1.0, fy-1.0),
        u, v);
    return mx_gradient_scale2d(result);
}

float mx_perlin_noise_float(vec3 p)
{
    int X, Y, Z;
    float fx = mx_floorfrac(p.x, X);
    float fy = mx_floorfrac(p.y, Y);
    float fz = mx_floorfrac(p.z, Z);
    float u = mx_fade(fx);
    float v = mx_fade(fy);
    float w = mx_fade(fz);
    float result = mx_trilerp(
        mx_gradient_float(mx_hash_int(X  , Y  , Z  ), fx    , fy    , fz     ),
        mx_gradient_float(mx_hash_int(X+1, Y  , Z  ), fx-1.0, fy    , fz     ),
        mx_gradient_float(mx_hash_int(X  , Y+1, Z  ), fx    , fy-1.0, fz     ),
        mx_gradient_float(mx_hash_int(X+1, Y+1, Z  ), fx-1.0, fy-1.0, fz     ),
        mx_gradient_float(mx_hash_int(X  , Y  , Z+1), fx    , fy    , fz-1.0),
        mx_gradient_float(mx_hash_int(X+1, Y  , Z+1), fx-1.0, fy    , fz-1.0),
        mx_gradient_float(mx_hash_int(X  , Y+1, Z+1), fx    , fy-1.0, fz-1.0),
        mx_gradient_float(mx_hash_int(X+1, Y+1, Z+1), fx-1.0, fy-1.0, fz-1.0),
        u, v, w);
    return mx_gradient_scale3d(result);
}

vec3 mx_perlin_noise_vec3(vec2 p)
{
    int X, Y;
    float fx = mx_floorfrac(p.x, X);
    float fy = mx_floorfrac(p.y, Y);
    float u = mx_fade(fx);
    float v = mx_fade(fy);
    vec3 result = mx_bilerp(
        mx_gradient_vec3(mx_hash_vec3(X  , Y  ), fx    , fy     ),
        mx_gradient_vec3(mx_hash_vec3(X+1, Y  ), fx-1.0, fy     ),
        mx_gradient_vec3(mx_hash_vec3(X  , Y+1), fx    , fy-1.0),
        mx_gradient_vec3(mx_hash_vec3(X+1, Y+1), fx-1.0, fy-1.0),
        u, v);
    return mx_gradient_scale2d(result);
}

vec3 mx_perlin_noise_vec3(vec3 p)
{
    int X, Y, Z;
    float fx = mx_floorfrac(p.x, X);
    float fy = mx_floorfrac(p.y, Y);
    float fz = mx_floorfrac(p.z, Z);
    float u = mx_fade(fx);
    float v = mx_fade(fy);
    float w = mx_fade(fz);
    vec3 result = mx_trilerp(
        mx_gradient_vec3(mx_hash_vec3(X  , Y  , Z  ), fx    , fy    , fz     ),
        mx_gradient_vec3(mx_hash_vec3(X+1, Y  , Z  ), fx-1.0, fy    , fz     ),
        mx_gradient_vec3(mx_hash_vec3(X  , Y+1, Z  ), fx    , fy-1.0, fz     ),
        mx_gradient_vec3(mx_hash_vec3(X+1, Y+1, Z  ), fx-1.0, fy-1.0, fz     ),
        mx_gradient_vec3(mx_hash_vec3(X  , Y  , Z+1), fx    , fy    , fz-1.0),
        mx_gradient_vec3(mx_hash_vec3(X+1, Y  , Z+1), fx-1.0, fy    , fz-1.0),
        mx_gradient_vec3(mx_hash_vec3(X  , Y+1, Z+1), fx    , fy-1.0, fz-1.0),
        mx_gradient_vec3(mx_hash_vec3(X+1, Y+1, Z+1), fx-1.0, fy-1.0, fz-1.0),
        u, v, w);
    return mx_gradient_scale3d(result);
}

float mx_cell_noise_float(float p)
{
    int ix = mx_floor(p);
    return mx_bits_to_01(mx_hash_int(ix));
}

float mx_cell_noise_float(vec2 p)
{
    int ix = mx_floor(p.x);
    int iy = mx_floor(p.y);
    return mx_bits_to_01(mx_hash_int(ix, iy));
}

float mx_cell_noise_float(vec3 p)
{
    int ix = mx_floor(p.x);
    int iy = mx_floor(p.y);
    int iz = mx_floor(p.z);
    return mx_bits_to_01(mx_hash_int(ix, iy, iz));
}

float mx_cell_noise_float(vec4 p)
{
    int ix = mx_floor(p.x);
    int iy = mx_floor(p.y);
    int iz = mx_floor(p.z);
    int iw = mx_floor(p.w);
    return mx_bits_to_01(mx_hash_int(ix, iy, iz, iw));
}

vec3 mx_cell_noise_vec3(float p)
{
    int ix = mx_floor(p);
    return vec3(
            mx_bits_to_01(mx_hash_int(ix, 0)),
            mx_bits_to_01(mx_hash_int(ix, 1)),
            mx_bits_to_01(mx_hash_int(ix, 2))
    );
}

vec3 mx_cell_noise_vec3(vec2 p)
{
    int ix = mx_floor(p.x);
    int iy = mx_floor(p.y);
    return vec3(
            mx_bits_to_01(mx_hash_int(ix, iy, 0)),
            mx_bits_to_01(mx_hash_int(ix, iy, 1)),
            mx_bits_to_01(mx_hash_int(ix, iy, 2))
    );
}

vec3 mx_cell_noise_vec3(vec3 p)
{
    int ix = mx_floor(p.x);
    int iy = mx_floor(p.y);
    int iz = mx_floor(p.z);
    return vec3(
            mx_bits_to_01(mx_hash_int(ix, iy, iz, 0)),
            mx_bits_to_01(mx_hash_int(ix, iy, iz, 1)),
            mx_bits_to_01(mx_hash_int(ix, iy, iz, 2))
    );
}

vec3 mx_cell_noise_vec3(vec4 p)
{
    int ix = mx_floor(p.x);
    int iy = mx_floor(p.y);
    int iz = mx_floor(p.z);
    int iw = mx_floor(p.w);
    return vec3(
            mx_bits_to_01(mx_hash_int(ix, iy, iz, iw, 0)),
            mx_bits_to_01(mx_hash_int(ix, iy, iz, iw, 1)),
            mx_bits_to_01(mx_hash_int(ix, iy, iz, iw, 2))
    );
}

float mx_fractal_noise_float(vec3 p, int octaves, float lacunarity, float diminish)
{
    float result = 0.0;
    float amplitude = 1.0;
    for (int i = 0;  i < octaves; ++i)
    {
        result += amplitude * mx_perlin_noise_float(p);
        amplitude *= diminish;
        p *= lacunarity;
    }
    return result;
}

vec3 mx_fractal_noise_vec3(vec3 p, int octaves, float lacunarity, float diminish)
{
    vec3 result = vec3(0.0);
    float amplitude = 1.0;
    for (int i = 0;  i < octaves; ++i)
    {
        result += amplitude * mx_perlin_noise_vec3(p);
        amplitude *= diminish;
        p *= lacunarity;
    }
    return result;
}

vec2 mx_fractal_noise_vec2(vec3 p, int octaves, float lacunarity, float diminish)
{
    return vec2(mx_fractal_noise_float(p, octaves, lacunarity, diminish),
                mx_fractal_noise_float(p+vec3(19, 193, 17), octaves, lacunarity, diminish));
}

vec4 mx_fractal_noise_vec4(vec3 p, int octaves, float lacunarity, float diminish)
{
    vec3  c = mx_fractal_noise_vec3(p, octaves, lacunarity, diminish);
    float f = mx_fractal_noise_float(p+vec3(19, 193, 17), octaves, lacunarity, diminish);
    return vec4(c, f);
}

float mx_worley_distance(vec2 p, int x, int y, int xoff, int yoff, float jitter, int metric)
{
    vec3  tmp = mx_cell_noise_vec3(vec2(x+xoff, y+yoff));
    vec2  off = vec2(tmp.x, tmp.y);

    off -= 0.5f;
    off *= jitter;
    off += 0.5f;

    vec2 cellpos = vec2(float(x), float(y)) + off;
    vec2 diff = cellpos - p;
    if (metric == 2)
        return abs(diff.x) + abs(diff.y);       // Manhattan distance
    if (metric == 3)
        return max(abs(diff.x), abs(diff.y));   // Chebyshev distance
    // Either Euclidian or Distance^2
    return dot(diff, diff);
}

float mx_worley_distance(vec3 p, int x, int y, int z, int xoff, int yoff, int zoff, float jitter, int metric)
{
    vec3  off = mx_cell_noise_vec3(vec3(x+xoff, y+yoff, z+zoff));

    off -= 0.5f;
    off *= jitter;
    off += 0.5f;

    vec3 cellpos = vec3(float(x), float(y), float(z)) + off;
    vec3 diff = cellpos - p;
    if (metric == 2)
        return abs(diff.x) + abs(diff.y) + abs(diff.z); // Manhattan distance
    if (metric == 3)
        return max(max(abs(diff.x), abs(diff.y)), abs(diff.z)); // Chebyshev distance
    // Either Euclidian or Distance^2
    return dot(diff, diff);
}

float mx_worley_noise_float(vec2 p, float jitter, int metric)
{
    int X, Y;
    vec2 localpos = vec2(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y));
    float sqdist = 1e6f;        // Some big number for jitter > 1 (not all GPUs may be IEEE)
    for (int x = -1; x <= 1; ++x)
    {
        for (int y = -1; y <= 1; ++y)
        {
            float dist = mx_worley_distance(localpos, x, y, X, Y, jitter, metric);
            sqdist = min(sqdist, dist);
        }
    }
    if (metric == 0)
        sqdist = sqrt(sqdist);
    return sqdist;
}

vec2 mx_worley_noise_vec2(vec2 p, float jitter, int metric)
{
    int X, Y;
    vec2 localpos = vec2(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y));
    vec2 sqdist = vec2(1e6f, 1e6f);
    for (int x = -1; x <= 1; ++x)
    {
        for (int y = -1; y <= 1; ++y)
        {
            float dist = mx_worley_distance(localpos, x, y, X, Y, jitter, metric);
            if (dist < sqdist.x)
            {
                sqdist.y = sqdist.x;
                sqdist.x = dist;
            }
            else if (dist < sqdist.y)
            {
                sqdist.y = dist;
            }
        }
    }
    if (metric == 0)
        sqdist = sqrt(sqdist);
    return sqdist;
}

vec3 mx_worley_noise_vec3(vec2 p, float jitter, int metric)
{
    int X, Y;
    vec2 localpos = vec2(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y));
    vec3 sqdist = vec3(1e6f, 1e6f, 1e6f);
    for (int x = -1; x <= 1; ++x)
    {
        for (int y = -1; y <= 1; ++y)
        {
            float dist = mx_worley_distance(localpos, x, y, X, Y, jitter, metric);
            if (dist < sqdist.x)
            {
                sqdist.z = sqdist.y;
                sqdist.y = sqdist.x;
                sqdist.x = dist;
            }
            else if (dist < sqdist.y)
            {
                sqdist.z = sqdist.y;
                sqdist.y = dist;
            }
            else if (dist < sqdist.z)
            {
                sqdist.z = dist;
            }
        }
    }
    if (metric == 0)
        sqdist = sqrt(sqdist);
    return sqdist;
}

float mx_worley_noise_float(vec3 p, float jitter, int metric)
{
    int X, Y, Z;
    vec3 localpos = vec3(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y), mx_floorfrac(p.z, Z));
    float sqdist = 1e6f;
    for (int x = -1; x <= 1; ++x)
    {
        for (int y = -1; y <= 1; ++y)
        {
            for (int z = -1; z <= 1; ++z)
            {
                float dist = mx_worley_distance(localpos, x, y, z, X, Y, Z, jitter, metric);
                sqdist = min(sqdist, dist);
            }
        }
    }
    if (metric == 0)
        sqdist = sqrt(sqdist);
    return sqdist;
}

vec2 mx_worley_noise_vec2(vec3 p, float jitter, int metric)
{
    int X, Y, Z;
    vec3 localpos = vec3(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y), mx_floorfrac(p.z, Z));
    vec2 sqdist = vec2(1e6f, 1e6f);
    for (int x = -1; x <= 1; ++x)
    {
        for (int y = -1; y <= 1; ++y)
        {
            for (int z = -1; z <= 1; ++z)
            {
                float dist = mx_worley_distance(localpos, x, y, z, X, Y, Z, jitter, metric);
                if (dist < sqdist.x)
                {
                    sqdist.y = sqdist.x;
                    sqdist.x = dist;
                }
                else if (dist < sqdist.y)
                {
                    sqdist.y = dist;
                }
            }
        }
    }
    if (metric == 0)
        sqdist = sqrt(sqdist);
    return sqdist;
}

vec3 mx_worley_noise_vec3(vec3 p, float jitter, int metric)
{
    int X, Y, Z;
    vec3 localpos = vec3(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y), mx_floorfrac(p.z, Z));
    vec3 sqdist = vec3(1e6f, 1e6f, 1e6f);
    for (int x = -1; x <= 1; ++x)
    {
        for (int y = -1; y <= 1; ++y)
        {
            for (int z = -1; z <= 1; ++z)
            {
                float dist = mx_worley_distance(localpos, x, y, z, X, Y, Z, jitter, metric);
                if (dist < sqdist.x)
                {
                    sqdist.z = sqdist.y;
                    sqdist.y = sqdist.x;
                    sqdist.x = dist;
                }
                else if (dist < sqdist.y)
                {
                    sqdist.z = sqdist.y;
                    sqdist.y = dist;
                }
                else if (dist < sqdist.z)
                {
                    sqdist.z = dist;
                }
            }
        }
    }
    if (metric == 0)
        sqdist = sqrt(sqdist);
    return sqdist;
}`);
var includes = [mx_noise];
var mx_perlin_noise_float = glslFn("float mx_perlin_noise_float( any p )", includes);
var mx_perlin_noise_vec2 = glslFn("vec2 mx_perlin_noise_vec2( any p )", includes);
var mx_perlin_noise_vec3 = glslFn("vec3 mx_perlin_noise_vec3( any p )", includes);
var mx_cell_noise_float = glslFn("float mx_cell_noise_float( vec3 p )", includes);
var mx_worley_noise_float = glslFn("float mx_worley_noise_float( any p, float jitter, int metric )", includes);
var mx_worley_noise_vec2 = glslFn("float mx_worley_noise_vec2( any p, float jitter, int metric )", includes);
var mx_worley_noise_vec3 = glslFn("float mx_worley_noise_vec3( any p, float jitter, int metric )", includes);
var mx_fractal_noise_float = glslFn("float mx_fractal_noise_float( vec3 p, int octaves, float lacunarity, float diminish )", includes);
var mx_fractal_noise_vec2 = glslFn("float mx_fractal_noise_vec2( vec3 p, int octaves, float lacunarity, float diminish )", includes);
var mx_fractal_noise_vec3 = glslFn("float mx_fractal_noise_vec3( vec3 p, int octaves, float lacunarity, float diminish )", includes);
var mx_fractal_noise_vec4 = glslFn("float mx_fractal_noise_vec4( vec3 p, int octaves, float lacunarity, float diminish )", includes);

// node_modules/three/examples/jsm/nodes/materialx/lib/mx_hsv.js
var mx_hsvtorgb = glslFn(`vec3 mx_hsvtorgb(vec3 hsv)
{
    // Reference for this technique: Foley & van Dam
    float h = hsv.x; float s = hsv.y; float v = hsv.z;
    if (s < 0.0001f) {
      return vec3 (v, v, v);
    } else {
        h = 6.0f * (h - floor(h));  // expand to [0..6)
        int hi = int(trunc(h));
        float f = h - float(hi);
        float p = v * (1.0f-s);
        float q = v * (1.0f-s*f);
        float t = v * (1.0f-s*(1.0f-f));
        if (hi == 0)
            return vec3 (v, t, p);
        else if (hi == 1)
            return vec3 (q, v, p);
        else if (hi == 2)
            return vec3 (p, v, t);
        else if (hi == 3)
            return vec3 (p, q, v);
        else if (hi == 4)
            return vec3 (t, p, v);
        return vec3 (v, p, q);
    }
}`);
var mx_rgbtohsv = glslFn(`vec3 mx_rgbtohsv(vec3 c)
{
    // See Foley & van Dam
    float r = c.x; float g = c.y; float b = c.z;
    float mincomp = min (r, min(g, b));
    float maxcomp = max (r, max(g, b));
    float delta = maxcomp - mincomp;  // chroma
    float h, s, v;
    v = maxcomp;
    if (maxcomp > 0.0f)
        s = delta / maxcomp;
    else s = 0.0f;
    if (s <= 0.0f)
        h = 0.0f;
    else {
        if      (r >= maxcomp) h = (g-b) / delta;
        else if (g >= maxcomp) h = 2.0f + (b-r) / delta;
        else                   h = 4.0f + (r-g) / delta;
        h *= (1.0f/6.0f);
        if (h < 0.0f)
            h += 1.0f;
    }
    return vec3(h, s, v);
}`);

// node_modules/three/examples/jsm/nodes/materialx/lib/mx_transform_color.js
var mx_transform_color = glsl(`#define M_AP1_TO_REC709 mat3(1.705079555511475, -0.1297005265951157, -0.02416634373366833, -0.6242334842681885, 1.138468623161316, -0.1246141716837883, -0.0808461606502533, -0.008768022060394287, 1.148780584335327)

vec3 mx_srgb_texture_to_lin_rec709(vec3 color)
{
    bvec3 isAbove = greaterThan(color, vec3(0.04045));
    vec3 linSeg = color / 12.92;
    vec3 powSeg = pow(max(color + vec3(0.055), vec3(0.0)) / 1.055, vec3(2.4));
    return mix(linSeg, powSeg, isAbove);
}`);
var includes2 = [mx_transform_color];
var mx_srgb_texture_to_lin_rec709 = glslFn("vec3 mx_srgb_texture_to_lin_rec709( vec3 color )", includes2);

// node_modules/three/examples/jsm/nodes/materialx/MaterialXNodes.js
var mx_aastep = (threshold, value) => {
  threshold = float(threshold);
  value = float(value);
  const afwidth = vec2(value.dFdx(), value.dFdy()).length().mul(0.7071067811865476);
  return smoothstep(threshold.sub(afwidth), threshold.add(afwidth), value);
};
var _ramp = (a, b, uv2, p) => mix(a, b, uv2[p].clamp());
var mx_ramplr = (valuel, valuer, texcoord = uv()) => _ramp(valuel, valuer, texcoord, "x");
var mx_ramptb = (valuet, valueb, texcoord = uv()) => _ramp(valuet, valueb, texcoord, "y");
var _split = (a, b, center, uv2, p) => mix(a, b, mx_aastep(center, uv2[p]));
var mx_splitlr = (valuel, valuer, center, texcoord = uv()) => _split(valuel, valuer, center, texcoord, "x");
var mx_splittb = (valuet, valueb, center, texcoord = uv()) => _split(valuet, valueb, center, texcoord, "y");
var mx_transform_uv = (uv_scale = 1, uv_offset = 0, uv_geo = uv()) => uv_geo.mul(uv_scale).add(uv_offset);
var mx_safepower = (in1, in2 = 1) => {
  in1 = float(in1);
  return in1.abs().pow(in2).mul(in1.sign());
};
var mx_contrast = (input, amount = 1, pivot = 0.5) => float(input).sub(pivot).mul(amount).add(pivot);
var mx_noise_float = (texcoord = uv(), amplitude = 1, pivot = 0) => mx_perlin_noise_float(texcoord.convert("vec2|vec3")).mul(amplitude).add(pivot);
var mx_noise_vec2 = (texcoord = uv(), amplitude = 1, pivot = 0) => mx_perlin_noise_vec2(texcoord.convert("vec2|vec3")).mul(amplitude).add(pivot);
var mx_noise_vec3 = (texcoord = uv(), amplitude = 1, pivot = 0) => mx_perlin_noise_vec3(texcoord.convert("vec2|vec3")).mul(amplitude).add(pivot);
var mx_noise_vec4 = (texcoord = uv(), amplitude = 1, pivot = 0) => {
  texcoord = texcoord.convert("vec2|vec3");
  const noise_vec4 = vec4(mx_perlin_noise_vec3(texcoord), mx_perlin_noise_float(texcoord.add(vec2(19, 73))));
  return noise_vec4.mul(amplitude).add(pivot);
};
var mx_worley_noise_float2 = (texcoord = uv(), jitter = 1) => mx_worley_noise_float(texcoord.convert("vec2|vec3"), jitter, 1);
var mx_worley_noise_vec22 = (texcoord = uv(), jitter = 1) => mx_worley_noise_vec2(texcoord.convert("vec2|vec3"), jitter, 1);
var mx_worley_noise_vec32 = (texcoord = uv(), jitter = 1) => mx_worley_noise_vec3(texcoord.convert("vec2|vec3"), jitter, 1);
var mx_cell_noise_float2 = (texcoord = uv()) => mx_cell_noise_float(texcoord.convert("vec2|vec3"));
var mx_fractal_noise_float2 = (position = uv(), octaves = 3, lacunarity = 2, diminish = 0.5, amplitude = 1) => mx_fractal_noise_float(position, octaves, lacunarity, diminish).mul(amplitude);
var mx_fractal_noise_vec22 = (position = uv(), octaves = 3, lacunarity = 2, diminish = 0.5, amplitude = 1) => mx_fractal_noise_vec2(position, octaves, lacunarity, diminish).mul(amplitude);
var mx_fractal_noise_vec32 = (position = uv(), octaves = 3, lacunarity = 2, diminish = 0.5, amplitude = 1) => mx_fractal_noise_vec3(position, octaves, lacunarity, diminish).mul(amplitude);
var mx_fractal_noise_vec42 = (position = uv(), octaves = 3, lacunarity = 2, diminish = 0.5, amplitude = 1) => mx_fractal_noise_vec4(position, octaves, lacunarity, diminish).mul(amplitude);
export {
  AONode_default as AONode,
  AmbientLightNode_default as AmbientLightNode,
  AnalyticLightNode_default as AnalyticLightNode,
  ArrayElementNode_default as ArrayElementNode,
  ArrayUniformNode_default as ArrayUniformNode,
  AttributeNode_default as AttributeNode,
  BRDF_GGX_default as BRDF_GGX,
  BRDF_Lambert_default as BRDF_Lambert,
  BitangentNode_default as BitangentNode,
  BlendModeNode_default as BlendModeNode,
  BufferAttributeNode_default as BufferAttributeNode,
  BufferNode_default as BufferNode,
  BypassNode_default as BypassNode,
  CacheNode_default as CacheNode,
  CameraNode_default as CameraNode,
  CheckerNode_default as CheckerNode,
  CodeNode_default as CodeNode,
  ColorAdjustmentNode_default as ColorAdjustmentNode,
  ColorSpaceNode_default as ColorSpaceNode,
  ComputeNode_default as ComputeNode,
  CondNode_default as CondNode,
  ConstNode_default as ConstNode,
  ContextNode_default as ContextNode,
  ConvertNode_default as ConvertNode,
  CubeTextureNode_default as CubeTextureNode,
  DFGApprox_default as DFGApprox,
  D_GGX_default as D_GGX,
  DirectionalLightNode_default as DirectionalLightNode,
  DiscardNode_default as DiscardNode,
  EPSILON,
  EnvironmentNode_default as EnvironmentNode,
  EquirectUVNode_default as EquirectUVNode,
  ExpressionNode_default as ExpressionNode,
  ExtendedMaterialNode_default as ExtendedMaterialNode,
  F_Schlick_default as F_Schlick,
  FogExp2Node_default as FogExp2Node,
  FogNode_default as FogNode,
  FogRangeNode_default as FogRangeNode,
  FrontFacingNode_default as FrontFacingNode,
  FunctionCallNode_default as FunctionCallNode,
  FunctionNode_default as FunctionNode,
  GLSLNodeParser_default as GLSLNodeParser,
  HashNode_default as HashNode,
  HemisphereLightNode_default as HemisphereLightNode,
  IESSpotLightNode_default as IESSpotLightNode,
  INFINITY,
  IndexNode_default as IndexNode,
  InstanceNode_default as InstanceNode,
  JoinNode_default as JoinNode,
  LightNode_default as LightNode,
  LightingContextNode_default as LightingContextNode,
  LightingModel_default as LightingModel,
  LightingNode_default as LightingNode,
  LightsNode_default as LightsNode,
  LineBasicNodeMaterial_default as LineBasicNodeMaterial,
  LineDashedNodeMaterial_default as LineDashedNodeMaterial,
  LoopNode_default as LoopNode,
  MatcapUVNode_default as MatcapUVNode,
  MaterialNode_default as MaterialNode,
  MaterialReferenceNode_default as MaterialReferenceNode,
  MathNode_default as MathNode,
  MaxMipLevelNode_default as MaxMipLevelNode,
  MeshBasicNodeMaterial_default as MeshBasicNodeMaterial,
  MeshLambertNodeMaterial_default as MeshLambertNodeMaterial,
  MeshNormalNodeMaterial_default as MeshNormalNodeMaterial,
  MeshPhongNodeMaterial_default as MeshPhongNodeMaterial,
  MeshPhysicalNodeMaterial_default as MeshPhysicalNodeMaterial,
  MeshStandardNodeMaterial_default as MeshStandardNodeMaterial,
  ModelNode_default as ModelNode,
  ModelViewProjectionNode_default as ModelViewProjectionNode,
  MorphNode_default as MorphNode,
  Node_default as Node,
  NodeAttribute_default as NodeAttribute,
  NodeBuilder_default as NodeBuilder,
  NodeCache_default as NodeCache,
  NodeCode_default as NodeCode,
  NodeFrame_default as NodeFrame,
  NodeFunctionInput_default as NodeFunctionInput,
  NodeKeywords_default as NodeKeywords,
  NodeLoader_default as NodeLoader,
  NodeMaterial_default as NodeMaterial,
  NodeMaterialLoader_default as NodeMaterialLoader,
  NodeObjectLoader_default as NodeObjectLoader,
  NodeShaderStage,
  NodeType,
  NodeUniform_default as NodeUniform,
  NodeUpdateType,
  NodeUtils_exports as NodeUtils,
  NodeVar_default as NodeVar,
  NodeVarying_default as NodeVarying,
  NormalMapNode_default as NormalMapNode,
  NormalNode_default as NormalNode,
  Object3DNode_default as Object3DNode,
  OperatorNode_default as OperatorNode,
  OscNode_default as OscNode,
  OutputStructNode_default as OutputStructNode,
  PackingNode_default as PackingNode,
  PhongLightingModel_default as PhongLightingModel,
  PhysicalLightingModel_default as PhysicalLightingModel,
  PointLightNode_default as PointLightNode,
  PointUVNode_default as PointUVNode,
  PointsNodeMaterial_default as PointsNodeMaterial,
  PositionNode_default as PositionNode,
  PosterizeNode_default as PosterizeNode,
  PropertyNode_default as PropertyNode,
  RangeNode_default as RangeNode,
  ReferenceNode_default as ReferenceNode,
  ReflectVectorNode_default as ReflectVectorNode,
  RemapNode_default as RemapNode,
  RotateUVNode_default as RotateUVNode,
  SceneNode_default as SceneNode,
  ScriptableNode_default as ScriptableNode,
  ScriptableValueNode_default as ScriptableValueNode,
  ShaderNode,
  SkinningNode_default as SkinningNode,
  SpecularMIPLevelNode_default as SpecularMIPLevelNode,
  SplitNode_default as SplitNode,
  SpotLightNode_default as SpotLightNode,
  SpriteNodeMaterial_default as SpriteNodeMaterial,
  SpriteSheetUVNode_default as SpriteSheetUVNode,
  StackNode_default as StackNode,
  StorageBufferNode_default as StorageBufferNode,
  TBNViewMatrix,
  TangentNode_default as TangentNode,
  TempNode_default as TempNode,
  TextureBicubicNode_default as TextureBicubicNode,
  TextureNode_default as TextureNode,
  TextureStoreNode_default as TextureStoreNode,
  TimerNode_default as TimerNode,
  ToneMappingNode_default as ToneMappingNode,
  TriplanarTexturesNode_default as TriplanarTexturesNode,
  UVNode_default as UVNode,
  UniformNode_default as UniformNode,
  UserDataNode_default as UserDataNode,
  V_GGX_SmithCorrelated_default as V_GGX_SmithCorrelated,
  VarNode_default as VarNode,
  VaryingNode_default as VaryingNode,
  ViewportDepthNode_default as ViewportDepthNode,
  ViewportDepthTextureNode_default as ViewportDepthTextureNode,
  ViewportNode_default as ViewportNode,
  ViewportSharedTextureNode_default as ViewportSharedTextureNode,
  ViewportTextureNode_default as ViewportTextureNode,
  abs,
  acos,
  add,
  addLightNode,
  addNodeClass,
  addNodeElement,
  addNodeMaterial,
  and,
  arrayBuffer,
  asin,
  assign,
  atan,
  atan2,
  attribute,
  backgroundBlurriness,
  backgroundIntensity,
  bitAnd,
  bitOr,
  bitXor,
  bitangentGeometry,
  bitangentLocal,
  bitangentView,
  bitangentWorld,
  bmat3,
  bmat4,
  bool,
  buffer,
  bufferAttribute,
  burn,
  bvec2,
  bvec3,
  bvec4,
  bypass,
  cache,
  call,
  cameraFar,
  cameraNear,
  cameraNormalMatrix,
  cameraPosition,
  cameraProjectionMatrix,
  cameraViewMatrix,
  cameraWorldMatrix,
  ceil,
  checker,
  clamp,
  code,
  color,
  colorSpaceToLinear,
  colorToDirection,
  compute,
  cond,
  context,
  convert,
  cos,
  createNodeFromType,
  createNodeMaterialFromType,
  cross,
  cubeTexture,
  dFdx,
  dFdy,
  defaultBuildStages,
  defaultShaderStages,
  degrees,
  densityFog,
  depth,
  depthTexture,
  difference,
  diffuseColor,
  directionToColor,
  discard,
  distance,
  div,
  dodge,
  dot,
  dynamicBufferAttribute,
  element,
  equal,
  equirectUV,
  exp,
  exp2,
  expression,
  faceDirection,
  faceForward,
  float,
  floor,
  fog,
  fract,
  frameId,
  frontFacing,
  fwidth,
  getConstNodeType,
  getDistanceAttenuation,
  getGeometryRoughness_default as getGeometryRoughness,
  getRoughness_default as getRoughness,
  global,
  glsl,
  glslFn,
  greaterThan,
  greaterThanEqual,
  hash,
  hue,
  imat3,
  imat4,
  instance,
  instanceIndex,
  instancedBufferAttribute,
  instancedDynamicBufferAttribute,
  int,
  inverseSqrt,
  ivec2,
  ivec3,
  ivec4,
  js,
  label,
  length,
  lessThan,
  lessThanEqual,
  lightTargetDirection,
  lightingContext,
  lights,
  lightsWithoutWrap,
  linearToColorSpace,
  linearTosRGB,
  log,
  log2,
  loop,
  lumaCoeffs,
  luminance,
  mat3,
  mat4,
  matcapUV,
  materialAlphaTest,
  materialColor,
  materialEmissive,
  materialMetalness,
  materialNormal,
  materialOpacity,
  materialReference,
  materialReflectivity,
  materialRotation,
  materialRoughness,
  materialSheen,
  materialSheenRoughness,
  materialShininess,
  materialSpecularColor,
  max,
  maxMipLevel,
  metalness,
  min,
  mix,
  mod,
  modelDirection,
  modelNormalMatrix,
  modelPosition,
  modelScale,
  modelViewMatrix,
  modelViewPosition,
  modelViewProjection,
  modelWorldMatrix,
  morph,
  mul,
  mx_aastep,
  mx_cell_noise_float2 as mx_cell_noise_float,
  mx_contrast,
  mx_fractal_noise_float2 as mx_fractal_noise_float,
  mx_fractal_noise_vec22 as mx_fractal_noise_vec2,
  mx_fractal_noise_vec32 as mx_fractal_noise_vec3,
  mx_fractal_noise_vec42 as mx_fractal_noise_vec4,
  mx_hsvtorgb,
  mx_noise_float,
  mx_noise_vec2,
  mx_noise_vec3,
  mx_noise_vec4,
  mx_ramplr,
  mx_ramptb,
  mx_rgbtohsv,
  mx_safepower,
  mx_splitlr,
  mx_splittb,
  mx_srgb_texture_to_lin_rec709,
  mx_transform_uv,
  mx_worley_noise_float2 as mx_worley_noise_float,
  mx_worley_noise_vec22 as mx_worley_noise_vec2,
  mx_worley_noise_vec32 as mx_worley_noise_vec3,
  negate,
  nodeArray,
  nodeImmutable,
  nodeObject,
  nodeObjects,
  nodeProxy,
  normalGeometry,
  normalLocal,
  normalMap,
  normalView,
  normalWorld,
  normalize,
  objectDirection,
  objectNormalMatrix,
  objectPosition,
  objectScale,
  objectViewMatrix,
  objectViewPosition,
  objectWorldMatrix,
  oneMinus,
  or,
  orthographicDepthToViewZ,
  oscSawtooth,
  oscSine,
  oscSquare,
  oscTriangle,
  output,
  outputStruct,
  overlay,
  perspectiveDepthToViewZ,
  pointUV,
  positionGeometry,
  positionLocal,
  positionView,
  positionViewDirection,
  positionWorld,
  positionWorldDirection,
  posterize,
  pow,
  pow2,
  pow3,
  pow4,
  property,
  radians,
  range,
  rangeFog,
  reciprocal,
  reference,
  reflect,
  reflectVector,
  refract,
  remainder,
  remap,
  remapClamp,
  rotateUV,
  roughness,
  round,
  sRGBToLinear,
  sampler,
  saturate,
  saturation,
  screen,
  scriptable,
  scriptableValue,
  shader,
  shaderStages,
  shiftLeft,
  shiftRight,
  shininess,
  sign,
  sin,
  skinning,
  smoothstep,
  specularColor,
  specularMIPLevel,
  split,
  spritesheetUV,
  sqrt,
  stack,
  step,
  storage,
  string,
  sub,
  tan,
  tangentGeometry,
  tangentLocal,
  tangentView,
  tangentWorld,
  temp,
  texture,
  textureBicubic,
  textureStore,
  timerDelta,
  timerGlobal,
  timerLocal,
  toneMapping,
  transformDirection,
  transformedBitangentView,
  transformedBitangentWorld,
  transformedClearcoatNormalView,
  transformedNormalView,
  transformedNormalWorld,
  transformedTangentView,
  transformedTangentWorld,
  triplanarTexture,
  triplanarTextures,
  trunc,
  tslFn,
  uint,
  umat3,
  umat4,
  uniform,
  userData,
  uv,
  uvec2,
  uvec3,
  uvec4,
  varying,
  vec2,
  vec3,
  vec4,
  vectorComponents,
  vertexIndex,
  vibrance,
  viewZToOrthographicDepth,
  viewZToPerspectiveDepth,
  viewportBottomLeft,
  viewportBottomRight,
  viewportCoordinate,
  viewportDepthTexture,
  viewportMipTexture,
  viewportResolution,
  viewportSharedTexture,
  viewportTexture,
  viewportTopLeft,
  viewportTopRight,
  wgsl,
  wgslFn,
  xor
};
//# sourceMappingURL=three_nodes.js.map
